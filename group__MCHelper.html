<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: MC Truth Helpers</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MC Truth Helpers<div class="ingroups"><a class="el" href="group__PhysUtils.html">PhysUtils</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1mc_1_1ParticleParser.html">usr::mc::ParticleParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple interface for wrapping a two particle function and thw 1 particle function in the same interface.  <a href="classusr_1_1mc_1_1ParticleParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9a47940e09ff0a5ca7125603e8842fa4"><td class="memItemLeft" align="right" valign="top"><a id="ga9a47940e09ff0a5ca7125603e8842fa4" name="ga9a47940e09ff0a5ca7125603e8842fa4"></a>
typedef <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::pp</b></td></tr>
<tr class="separator:ga9a47940e09ff0a5ca7125603e8842fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2724d68bbff648b26572059ad24d753c"><td class="memItemLeft" align="right" valign="top"><a id="ga2724d68bbff648b26572059ad24d753c" name="ga2724d68bbff648b26572059ad24d753c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga2724d68bbff648b26572059ad24d753c">usr::mc::PID</a> { <br />
&#160;&#160;<b>DOWN_QUARK_ID</b> = 1
, <b>UP_QUARK_ID</b> = 2
, <b>STRANGE_QUARK_ID</b> = 3
, <b>CHARM_QUARK_ID</b> = 4
, <br />
&#160;&#160;<b>BOTTOM_QUARK_ID</b> = 5
, <b>TOP_QUARK_ID</b> = 6
, <b>ELEC_ID</b> = 11
, <b>ELECNU_ID</b> = 12
, <br />
&#160;&#160;<b>MUON_ID</b> = 13
, <b>MUONNU_ID</b> = 14
, <b>TAU_ID</b> = 15
, <b>TAUNU_ID</b> = 16
, <br />
&#160;&#160;<b>GLUON_ID</b> = 21
, <b>GAMMA_ID</b> = 22
, <b>Z_BOSON_ID</b> = 23
, <b>W_BOSON_ID</b> = 24
, <br />
&#160;&#160;<b>HIGGS_BOSON_ID</b> = 25
<br />
 }</td></tr>
<tr class="memdesc:ga2724d68bbff648b26572059ad24d753c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard model particle ids in enum format (add negative sign for anti-particle) <br /></td></tr>
<tr class="separator:ga2724d68bbff648b26572059ad24d753c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga00f4e68beba9d7485bea62b404000ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga00f4e68beba9d7485bea62b404000ef8">usr::mc::HasCorrectiveParent</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:ga00f4e68beba9d7485bea62b404000ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking if the particle has radiative correction particle in neighboring topology.  <a href="group__MCHelper.html#ga00f4e68beba9d7485bea62b404000ef8">More...</a><br /></td></tr>
<tr class="separator:ga00f4e68beba9d7485bea62b404000ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd3521b754061c5d4097956d336d86a"><td class="memItemLeft" align="right" valign="top"><a id="ga7bd3521b754061c5d4097956d336d86a" name="ga7bd3521b754061c5d4097956d336d86a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::HasCorrectiveChildren</b> (const reco::Candidate *)</td></tr>
<tr class="separator:ga7bd3521b754061c5d4097956d336d86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051512096ed15956c1da8707844b7d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga051512096ed15956c1da8707844b7d41">usr::mc::HasDaughter</a> (const reco::Candidate *x, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_target)</td></tr>
<tr class="memdesc:ga051512096ed15956c1da8707844b7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has daughter particle that matches a certain criteria.  <a href="group__MCHelper.html#ga051512096ed15956c1da8707844b7d41">More...</a><br /></td></tr>
<tr class="separator:ga051512096ed15956c1da8707844b7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d2c3956672bc0a4afdd96b71776499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga75d2c3956672bc0a4afdd96b71776499">usr::mc::HasMother</a> (const reco::Candidate *x, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_target)</td></tr>
<tr class="memdesc:ga75d2c3956672bc0a4afdd96b71776499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has mother particle that matches a certain criteria.  <a href="group__MCHelper.html#ga75d2c3956672bc0a4afdd96b71776499">More...</a><br /></td></tr>
<tr class="separator:ga75d2c3956672bc0a4afdd96b71776499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50754510d59bdc389312fde8279fc0ad"><td class="memItemLeft" align="right" valign="top"><a id="ga50754510d59bdc389312fde8279fc0ad" name="ga50754510d59bdc389312fde8279fc0ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::Any</b> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:ga50754510d59bdc389312fde8279fc0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used for getting all topology particle in BFS order. <br /></td></tr>
<tr class="separator:ga50754510d59bdc389312fde8279fc0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1723244bf34f975c66d557ed0a065e9"><td class="memItemLeft" align="right" valign="top"><a id="gaf1723244bf34f975c66d557ed0a065e9" name="gaf1723244bf34f975c66d557ed0a065e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::NoTermination</b> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:gaf1723244bf34f975c66d557ed0a065e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function required for no-termination condition in topology crawling. <br /></td></tr>
<tr class="separator:gaf1723244bf34f975c66d557ed0a065e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c121cab7773e2a31f1aaf54d6e99ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const reco::Candidate * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga60c121cab7773e2a31f1aaf54d6e99ed">usr::mc::FindAll</a> (const std::vector&lt; reco::GenParticle &gt; &amp;genlist, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_target)</td></tr>
<tr class="memdesc:ga60c121cab7773e2a31f1aaf54d6e99ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning a list of gen particles pointer that match a certain selection criteria.  <a href="group__MCHelper.html#ga60c121cab7773e2a31f1aaf54d6e99ed">More...</a><br /></td></tr>
<tr class="separator:ga60c121cab7773e2a31f1aaf54d6e99ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b29dca6e83fa81781fff5b00e4711c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const reco::Candidate * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga3b29dca6e83fa81781fff5b00e4711c3">usr::mc::FindDecendants</a> (const reco::Candidate *x, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_target, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_terminate)</td></tr>
<tr class="memdesc:ga3b29dca6e83fa81781fff5b00e4711c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the decendants of a particle in the decay topology that matches a certain criteria.  <a href="group__MCHelper.html#ga3b29dca6e83fa81781fff5b00e4711c3">More...</a><br /></td></tr>
<tr class="separator:ga3b29dca6e83fa81781fff5b00e4711c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b0defc2f6f1b3c3c479c40b3cd4f60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const reco::Candidate * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga31b0defc2f6f1b3c3c479c40b3cd4f60">usr::mc::FindAncestors</a> (const reco::Candidate *x, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_target, const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;is_terminate)</td></tr>
<tr class="memdesc:ga31b0defc2f6f1b3c3c479c40b3cd4f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ancestors of a particle in the decay topology that matches a certain criteria.  <a href="group__MCHelper.html#ga31b0defc2f6f1b3c3c479c40b3cd4f60">More...</a><br /></td></tr>
<tr class="separator:ga31b0defc2f6f1b3c3c479c40b3cd4f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10553b3fa46ba6418ea9f2449609a0b8"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga10553b3fa46ba6418ea9f2449609a0b8">usr::mc::GetLastInChain</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:ga10553b3fa46ba6418ea9f2449609a0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last particle in a radiative correction chain.  <a href="group__MCHelper.html#ga10553b3fa46ba6418ea9f2449609a0b8">More...</a><br /></td></tr>
<tr class="separator:ga10553b3fa46ba6418ea9f2449609a0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1d306b1e620fdff1d80ed6c66f84d3"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gaad1d306b1e620fdff1d80ed6c66f84d3">usr::mc::GetFirstInChain</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:gaad1d306b1e620fdff1d80ed6c66f84d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the First particle in the radiative correction chain.  <a href="group__MCHelper.html#gaad1d306b1e620fdff1d80ed6c66f84d3">More...</a><br /></td></tr>
<tr class="separator:gaad1d306b1e620fdff1d80ed6c66f84d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b77ce18bb391d849a098be88a76146b"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga4b77ce18bb391d849a098be88a76146b">usr::mc::GetLeastCommonAncestor</a> (const reco::Candidate *root, const std::vector&lt; const reco::Candidate * &gt; list)</td></tr>
<tr class="memdesc:ga4b77ce18bb391d849a098be88a76146b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Least Common Ancestor in the decay topology.  <a href="group__MCHelper.html#ga4b77ce18bb391d849a098be88a76146b">More...</a><br /></td></tr>
<tr class="separator:ga4b77ce18bb391d849a098be88a76146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c093c5cc44e380706d874fc6d90286"><td class="memItemLeft" align="right" valign="top"><a id="ga54c093c5cc44e380706d874fc6d90286" name="ga54c093c5cc44e380706d874fc6d90286"></a>
const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::GetDaughter</b> (const reco::Candidate *, int)</td></tr>
<tr class="separator:ga54c093c5cc44e380706d874fc6d90286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff788777292a18576c646b2e74cd924"><td class="memItemLeft" align="right" valign="top">math::XYZPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga1ff788777292a18576c646b2e74cd924">usr::mc::GetGenVertex</a> (const std::vector&lt; reco::GenParticle &gt; &amp;genlist)</td></tr>
<tr class="memdesc:ga1ff788777292a18576c646b2e74cd924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Gen-Level Vertex position from the list of gen particles.  <a href="group__MCHelper.html#ga1ff788777292a18576c646b2e74cd924">More...</a><br /></td></tr>
<tr class="separator:ga1ff788777292a18576c646b2e74cd924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242ad0417e1a423dcc5bafe63e862fa3"><td class="memItemLeft" align="right" valign="top"><a id="ga242ad0417e1a423dcc5bafe63e862fa3" name="ga242ad0417e1a423dcc5bafe63e862fa3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::IsSMQuark</b> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:ga242ad0417e1a423dcc5bafe63e862fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using PDGID to check if the particle is a SM particle of a certain type. <br /></td></tr>
<tr class="separator:ga242ad0417e1a423dcc5bafe63e862fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a37d8dc775d7e19c35a6070f5b1e03e"><td class="memItemLeft" align="right" valign="top"><a id="ga0a37d8dc775d7e19c35a6070f5b1e03e" name="ga0a37d8dc775d7e19c35a6070f5b1e03e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::IsSMHadron</b> (const reco::Candidate *)</td></tr>
<tr class="memdesc:ga0a37d8dc775d7e19c35a6070f5b1e03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using PDGID to check if the particle is a SM particle of a certain type. <br /></td></tr>
<tr class="separator:ga0a37d8dc775d7e19c35a6070f5b1e03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad61932b3a7c222a1722e8b202cc3fc90"><td class="memItemLeft" align="right" valign="top"><a id="gad61932b3a7c222a1722e8b202cc3fc90" name="gad61932b3a7c222a1722e8b202cc3fc90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::IsSMHiggs</b> (const reco::Candidate *)</td></tr>
<tr class="memdesc:gad61932b3a7c222a1722e8b202cc3fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using PDGID to check if the particle is a SM particle of a certain type. <br /></td></tr>
<tr class="separator:gad61932b3a7c222a1722e8b202cc3fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ffbf1b9aba4bf28b68aa7aa245f94f"><td class="memItemLeft" align="right" valign="top"><a id="gae3ffbf1b9aba4bf28b68aa7aa245f94f" name="gae3ffbf1b9aba4bf28b68aa7aa245f94f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::mc::IsSMGluon</b> (const reco::Candidate *)</td></tr>
<tr class="memdesc:gae3ffbf1b9aba4bf28b68aa7aa245f94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using PDGID to check if the particle is a SM particle of a certain type. <br /></td></tr>
<tr class="separator:gae3ffbf1b9aba4bf28b68aa7aa245f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga60c121cab7773e2a31f1aaf54d6e99ed" name="ga60c121cab7773e2a31f1aaf54d6e99ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60c121cab7773e2a31f1aaf54d6e99ed">&#9670;&nbsp;</a></span>FindAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const reco::Candidate * &gt; usr::mc::FindAll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; reco::GenParticle &gt; &amp;&#160;</td>
          <td class="paramname"><em>genlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function simply loops over all the particles in the given gen particle list and pass all objects the the calculation function. The ordering of the return list would be according to when they appear in the master list. </p>

</div>
</div>
<a id="ga31b0defc2f6f1b3c3c479c40b3cd4f60" name="ga31b0defc2f6f1b3c3c479c40b3cd4f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b0defc2f6f1b3c3c479c40b3cd4f60">&#9670;&nbsp;</a></span>FindAncestors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const reco::Candidate * &gt; usr::mc::FindAncestors </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_terminate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The user is responsible to passing the function uses to processes a candidate particle in the decay topology. Currently the function must be self-contained (the function argument is only the decandent candidate). The return results will be ordered in terms of the BFS search sequence, so objects that are "closer" to the given particle will always be added.</p>
<p >Notice that since the decay toplogy is not a strict tree structure (example for hadronizations, two quarks can both be the parent of the resulting tow hadrons), the return result will only contain the first instance at which a particle if found in the decay chain.</p>
<p >To save on time, the user can also provide a function to indicate that the BFS termination criteria. If the particle visited by the BFS algorithm matches the critera, then the particles mothers will not be added to BFS queue. In case non is provided, the termination function will be the same as the target function. so that as soon a particle if found as the target, the BFS search will be terminated. </p>

</div>
</div>
<a id="ga3b29dca6e83fa81781fff5b00e4711c3" name="ga3b29dca6e83fa81781fff5b00e4711c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b29dca6e83fa81781fff5b00e4711c3">&#9670;&nbsp;</a></span>FindDecendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const reco::Candidate * &gt; usr::mc::FindDecendants </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_terminate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The user is responsible to passing the function uses to processes a candidate particle in the decay topology. Currently the function must be self-contained (the function argument is only the decandent candidate as the first candidate and the input particle as the center particle). The return results will be ordered in terms of the BFS search sequence, so objects that are "closer" to the given particle will always be added.</p>
<p >Notice that since the decay toplogy is not a strict tree structure (example for hadronizations, two quarks can both be the parent of the resulting tow hadrons), the return result will only contain the first instance at which a particle if found in the decay chain.</p>
<p >To save on time, the user can also provide a function to indicate that the BFS termination criteria. If the particle visited by the BFS algorithm matches the critera, then the particles daughters will not be added to BFS queue. In case non is provided, the termination function will be the same as the target function. so that as soon a particle if found as the target, the BFS search will be terminated. </p>

</div>
</div>
<a id="gaad1d306b1e620fdff1d80ed6c66f84d3" name="gaad1d306b1e620fdff1d80ed6c66f84d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad1d306b1e620fdff1d80ed6c66f84d3">&#9670;&nbsp;</a></span>GetFirstInChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::mc::GetFirstInChain </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tracing the parent until it doesn't have a parent having the same particle ID. </p>

</div>
</div>
<a id="ga1ff788777292a18576c646b2e74cd924" name="ga1ff788777292a18576c646b2e74cd924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff788777292a18576c646b2e74cd924">&#9670;&nbsp;</a></span>GetGenVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">math::XYZPoint usr::mc::GetGenVertex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; reco::GenParticle &gt; &amp;&#160;</td>
          <td class="paramname"><em>genlist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Notice that the particle assuming the incoming protons are always the first in the list. In the case that these assertions fail, the point return will have all three coordinates set to -100 </p>

</div>
</div>
<a id="ga10553b3fa46ba6418ea9f2449609a0b8" name="ga10553b3fa46ba6418ea9f2449609a0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10553b3fa46ba6418ea9f2449609a0b8">&#9670;&nbsp;</a></span>GetLastInChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::mc::GetLastInChain </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The particle in the radiative correction chain should only have two daughter particles : The corrected particle and the radiated particle if exited. If more daughter particles exists, then it is doing something non-trivial, and we will not consider this part of the chain. </p>

</div>
</div>
<a id="ga4b77ce18bb391d849a098be88a76146b" name="ga4b77ce18bb391d849a098be88a76146b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b77ce18bb391d849a098be88a76146b">&#9670;&nbsp;</a></span>GetLeastCommonAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::mc::GetLeastCommonAncestor </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const reco::Candidate * &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Useful for finding the particle resposible for creating the particle shower vertex. The root indicates a guaranteed ancestor for all the particles in the list.</p>
<p >Note that the decay topology in the hadronization phase isn't guaranteed to be a tree topology. There are topologies like: \(x\rightarrow ddgg\rightarrow pp\pi\pi\), where the all \(ddgg\) are technically the parents of the \(pp\pi\pi\) particles in the final state from the hadronization process, but neither is a physically significant common ancestor. In this case, the function should try and return the particle \(x\) when given the \(pp\pi\pi\) as the input, instead of any of the \(ddgg\) particles.</p>
<p >Since non-single parents only occurs in the decay topology (TO FACT CHECK), what this function will do is that the function will first check for the non-single parent particles if the exists, the function will rerun the function with the parent particles replacing the non-single parent particle as the input.</p>
<p >The Least Common Ancestor Algorithm for the tree-like topology uses the hash table method since parent pointers area available: for each member in the list, trace the ancestry to the root node and track the number of times a parent particles has been traversed. The particle return will be the one with the maximum number of traverse count (not returning an exact results, since the there will be accidental merging in the verticies) </p>

</div>
</div>
<a id="ga00f4e68beba9d7485bea62b404000ef8" name="ga00f4e68beba9d7485bea62b404000ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00f4e68beba9d7485bea62b404000ef8">&#9670;&nbsp;</a></span>HasCorrectiveParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::mc::HasCorrectiveParent </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Radiative corrections is current defined as:</p><ul>
<li>The neighbor only a single particle with the same PDGID.</li>
<li>That child has pt within 10% of the parent pt.</li>
</ul>
<p >If both are satisfied, the function returns true, false otherwise. </p>

</div>
</div>
<a id="ga051512096ed15956c1da8707844b7d41" name="ga051512096ed15956c1da8707844b7d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga051512096ed15956c1da8707844b7d41">&#9670;&nbsp;</a></span>HasDaughter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::mc::HasDaughter </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The input <a class="el" href="classusr_1_1mc_1_1ParticleParser.html" title="Simple interface for wrapping a two particle function and thw 1 particle function in the same interfa...">ParticleParser</a> object can take up to two inputs. The first being the daughter particle, the second being the main reference particle. </p>

</div>
</div>
<a id="ga75d2c3956672bc0a4afdd96b71776499" name="ga75d2c3956672bc0a4afdd96b71776499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75d2c3956672bc0a4afdd96b71776499">&#9670;&nbsp;</a></span>HasMother()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::mc::HasMother </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1mc_1_1ParticleParser.html">ParticleParser</a> &amp;&#160;</td>
          <td class="paramname"><em>is_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The input <a class="el" href="classusr_1_1mc_1_1ParticleParser.html" title="Simple interface for wrapping a two particle function and thw 1 particle function in the same interfa...">ParticleParser</a> object can take up to two inputs. The first being the mother particle, the second being the main reference particle. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.2
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
