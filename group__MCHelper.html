<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: MC Truth Helpers</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MC Truth Helpers<div class="ingroups"><a class="el" href="group__PhysUtils.html">PhysUtils</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad297c82dd97672140ee90b11314f0306"><td class="memItemLeft" align="right" valign="top"><a id="gad297c82dd97672140ee90b11314f0306"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gad297c82dd97672140ee90b11314f0306">usr::PID</a> { <br />
&#160;&#160;<b>DOWN_QUARK_ID</b> = 1
, <b>UP_QUARK_ID</b> = 2
, <b>STRANGE_QUARK_ID</b> = 3
, <b>CHARM_QUARK_ID</b> = 4
, <br />
&#160;&#160;<b>BOTTOM_QUARK_ID</b> = 5
, <b>TOP_QUARK_ID</b> = 6
, <b>ELEC_ID</b> = 11
, <b>ELECNU_ID</b> = 12
, <br />
&#160;&#160;<b>MUON_ID</b> = 13
, <b>MUONNU_ID</b> = 14
, <b>TAU_ID</b> = 15
, <b>TAUNU_ID</b> = 16
, <br />
&#160;&#160;<b>GLUON_ID</b> = 21
, <b>GAMMA_ID</b> = 22
, <b>Z_BOSON_ID</b> = 23
, <b>W_BOSON_ID</b> = 24
, <br />
&#160;&#160;<b>HIGGS_BOSON_ID</b> = 25
<br />
 }</td></tr>
<tr class="memdesc:gad297c82dd97672140ee90b11314f0306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard model particle ids in enum format (add negative sign for anti-particle) <br /></td></tr>
<tr class="separator:gad297c82dd97672140ee90b11314f0306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aad8563c91d5f86ae80293a6d1fe450"><td class="memItemLeft" align="right" valign="top"><a id="ga1aad8563c91d5f86ae80293a6d1fe450"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>GET_FLAG</b> { <b>GET_ALL</b> = 0
, <b>GET_IMMEDIATE</b> = 1
 }</td></tr>
<tr class="separator:ga1aad8563c91d5f86ae80293a6d1fe450"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabd27ddeb20defa504e7d57bff52dc212"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gabd27ddeb20defa504e7d57bff52dc212">usr::GetDirectMother</a> (const reco::Candidate *x, int target_ID)</td></tr>
<tr class="memdesc:gabd27ddeb20defa504e7d57bff52dc212"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning pointer to the particle in the parent topology with a specified flavour.  <a href="group__MCHelper.html#gabd27ddeb20defa504e7d57bff52dc212">More...</a><br /></td></tr>
<tr class="separator:gabd27ddeb20defa504e7d57bff52dc212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27548e8aaf531a36cc74bff66260bb7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga27548e8aaf531a36cc74bff66260bb7a">usr::IsIntermediate</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:ga27548e8aaf531a36cc74bff66260bb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if particles is intermediate part in the decay chain (i.e it has radiative corrections to the particle momentum)  <a href="group__MCHelper.html#ga27548e8aaf531a36cc74bff66260bb7a">More...</a><br /></td></tr>
<tr class="separator:ga27548e8aaf531a36cc74bff66260bb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac817488c2bb6686d4249493512ad51ff"><td class="memItemLeft" align="right" valign="top"><a id="gac817488c2bb6686d4249493512ad51ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usr::IsIntermediate</b> (const reco::Candidate &amp;x)</td></tr>
<tr class="separator:gac817488c2bb6686d4249493512ad51ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38be8b38b90101cd7b7f9ee216df37f0"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga38be8b38b90101cd7b7f9ee216df37f0">usr::GetLeastCommonAncestor</a> (const reco::Candidate *root, const std::vector&lt; const reco::Candidate * &gt; list)</td></tr>
<tr class="memdesc:ga38be8b38b90101cd7b7f9ee216df37f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Least Common Ancestor in the decay topology.  <a href="group__MCHelper.html#ga38be8b38b90101cd7b7f9ee216df37f0">More...</a><br /></td></tr>
<tr class="separator:ga38be8b38b90101cd7b7f9ee216df37f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebdc7e73bccfe1c4c3ec90ddee872b8c"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gaebdc7e73bccfe1c4c3ec90ddee872b8c">usr::GetLastInChain</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:gaebdc7e73bccfe1c4c3ec90ddee872b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last particle in a radiative correction chain.  <a href="group__MCHelper.html#gaebdc7e73bccfe1c4c3ec90ddee872b8c">More...</a><br /></td></tr>
<tr class="separator:gaebdc7e73bccfe1c4c3ec90ddee872b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad123fe9c87d3087cfcd53502ef5ef2df"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gad123fe9c87d3087cfcd53502ef5ef2df">usr::GetFirstInChain</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:gad123fe9c87d3087cfcd53502ef5ef2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the First particle in the radiative correction chain.  <a href="group__MCHelper.html#gad123fe9c87d3087cfcd53502ef5ef2df">More...</a><br /></td></tr>
<tr class="separator:gad123fe9c87d3087cfcd53502ef5ef2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963664419c35e79e2bc4e1d52a0d7836"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga963664419c35e79e2bc4e1d52a0d7836">usr::GetDaughter</a> (const reco::Candidate *x, int target_ID)</td></tr>
<tr class="memdesc:ga963664419c35e79e2bc4e1d52a0d7836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essentially the same as the GetDirectMother functions, except this time the traversal directions is towards the children side.  <a href="group__MCHelper.html#ga963664419c35e79e2bc4e1d52a0d7836">More...</a><br /></td></tr>
<tr class="separator:ga963664419c35e79e2bc4e1d52a0d7836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab660f2919d9b27417f3a890de2f13103"><td class="memItemLeft" align="right" valign="top">const reco::Candidate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gab660f2919d9b27417f3a890de2f13103">usr::FindAncestor</a> (const reco::Candidate *x, int pdgid)</td></tr>
<tr class="memdesc:gab660f2919d9b27417f3a890de2f13103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the closest ancestor that matches the given PDG id.  <a href="group__MCHelper.html#gab660f2919d9b27417f3a890de2f13103">More...</a><br /></td></tr>
<tr class="separator:gab660f2919d9b27417f3a890de2f13103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a92107aa5e300874e17452fa11b3d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga12a92107aa5e300874e17452fa11b3d8">usr::IsSMHadron</a> (const reco::Candidate *x)</td></tr>
<tr class="memdesc:ga12a92107aa5e300874e17452fa11b3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to check if particle is a hadron.  <a href="group__MCHelper.html#ga12a92107aa5e300874e17452fa11b3d8">More...</a><br /></td></tr>
<tr class="separator:ga12a92107aa5e300874e17452fa11b3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda7a17d1533ef00422cfe518f53c080"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const reco::Candidate * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#gadda7a17d1533ef00422cfe518f53c080">usr::GetDecendants</a> (const reco::Candidate *x, bool(* func)(const reco::Candidate *), const int flag)</td></tr>
<tr class="memdesc:gadda7a17d1533ef00422cfe518f53c080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the decendants of a particle in the decay topology that matches a certain criteria.  <a href="group__MCHelper.html#gadda7a17d1533ef00422cfe518f53c080">More...</a><br /></td></tr>
<tr class="separator:gadda7a17d1533ef00422cfe518f53c080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0a28d77e7427428e968ca8dab61b53"><td class="memItemLeft" align="right" valign="top"><a id="gacd0a28d77e7427428e968ca8dab61b53"></a>
std::vector&lt; const reco::Candidate * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>usr::GetSMHadrons</b> (const reco::Candidate *)</td></tr>
<tr class="separator:gacd0a28d77e7427428e968ca8dab61b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f04d4b818ec455edecf08376a364fb"><td class="memItemLeft" align="right" valign="top">math::XYZPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MCHelper.html#ga90f04d4b818ec455edecf08376a364fb">usr::GetGenVertex</a> (const std::vector&lt; reco::GenParticle &gt; &amp;genlist)</td></tr>
<tr class="memdesc:ga90f04d4b818ec455edecf08376a364fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Gen-Level Vertex position from the list of gen particles.  <a href="group__MCHelper.html#ga90f04d4b818ec455edecf08376a364fb">More...</a><br /></td></tr>
<tr class="separator:ga90f04d4b818ec455edecf08376a364fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab660f2919d9b27417f3a890de2f13103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab660f2919d9b27417f3a890de2f13103">&#9670;&nbsp;</a></span>FindAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::FindAncestor </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pdgid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using a BFS algorithm to find the closest ancestor </p>

</div>
</div>
<a id="ga963664419c35e79e2bc4e1d52a0d7836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga963664419c35e79e2bc4e1d52a0d7836">&#9670;&nbsp;</a></span>GetDaughter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::GetDaughter </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It will follow the same flavour decaying chain until there is a flavour change. A major caveat of this functions would be if the decay topology you are interested in is on the otherside of the hard radiation photon, gluon or Z boson. In these cases, the user should be careful that this function is returning what is desired. </p>

</div>
</div>
<a id="gadda7a17d1533ef00422cfe518f53c080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda7a17d1533ef00422cfe518f53c080">&#9670;&nbsp;</a></span>GetDecendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const reco::Candidate * &gt; usr::GetDecendants </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const reco::Candidate *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user is responsible to passing the function uses to processes a candidate particle in the decay topology. Currently the function must be self-contained (the function argument is only the decandent candidate).</p>
<p>The user can also add a flag that tells the function how deep into the topology to fetch the decendants. As the decay topology is difficult to define in terms of decay 'depth', with radiative correction sharing the same topology as regular decays, the only two options are for immedidate and all. </p>

</div>
</div>
<a id="gabd27ddeb20defa504e7d57bff52dc212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd27ddeb20defa504e7d57bff52dc212">&#9670;&nbsp;</a></span>GetDirectMother()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::GetDirectMother </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For an input particle x, it will traverse the topology towards the parent side, until</p><ol type="1">
<li>the parent particle has the target flavour F, in which case it returns the pointer to the parent particle. Note that the absolute value will be taken for the for the flavour.</li>
<li>The parent particle has a flavour different to x, in which case a null pointer is return.</li>
</ol>
<p>This function help find direct parent of a particle while avoid the possibility of final state radiations affecting the topology parsing. For example, the following topology is actually rather common in CMSSW truth topologies:</p>
<p class="formulaDsp">
\[F\rightarrow(x+g)\rightarrow(x&#39;+gg)\rightarrow(x&#39;&#39;+ggg) \]
</p>
<p>The three function calls GetDirectMother( x, F ), GetDirectMother( x', F ), and GetDirectMother( x'', F ) should all return the same pointer F.</p>
<p>Topologies in MiniAOD also have some times have the topologies like: \(x \rightarrow x&#39; \rightarrow x&#39;&#39;\), where the radiation particles are dropped to save space. This function will also avoid cases like this. </p>

</div>
</div>
<a id="gad123fe9c87d3087cfcd53502ef5ef2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad123fe9c87d3087cfcd53502ef5ef2df">&#9670;&nbsp;</a></span>GetFirstInChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::GetFirstInChain </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tracing the parent until it doesn't have a parent having the same particle ID. </p>

</div>
</div>
<a id="ga90f04d4b818ec455edecf08376a364fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f04d4b818ec455edecf08376a364fb">&#9670;&nbsp;</a></span>GetGenVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">math::XYZPoint usr::GetGenVertex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; reco::GenParticle &gt; &amp;&#160;</td>
          <td class="paramname"><em>genlist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notice that the particle assuming the incoming protons are always the first in the list. In the case that these assertions fail, the point return will have all three coordinates set to -100 </p>

</div>
</div>
<a id="gaebdc7e73bccfe1c4c3ec90ddee872b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebdc7e73bccfe1c4c3ec90ddee872b8c">&#9670;&nbsp;</a></span>GetLastInChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::GetLastInChain </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The particle in the radiative correction chain should only have two daughter particles : The corrected particle and the radiated particle if exited. If more daughter particles exists, then it is doing something non-trivial, and we will not consider this part of the chain. </p>

</div>
</div>
<a id="ga38be8b38b90101cd7b7f9ee216df37f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38be8b38b90101cd7b7f9ee216df37f0">&#9670;&nbsp;</a></span>GetLeastCommonAncestor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const reco::Candidate * usr::GetLeastCommonAncestor </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const reco::Candidate * &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Useful for finding the particle resposible for creating the particle shower vertex. The root indicates a guaranteed ancestor for all the particles in the list.</p>
<p>Note that the decay topology in the hadronization phase isn't guaranteed to be a tree topology. There are topologies like: \(x\rightarrow ddgg\rightarrow pp\pi\pi\), where the all \(ddgg\) are technically the parents of the \(pp\pi\pi\) particles in the final state from the hadronization process, but neither is a physically significant common ancestor. In this case, the function should try and return the particle \(x\) when given the \(pp\pi\pi\) as the input, instead of any of the \(ddgg\) particles.</p>
<p>Since non-single parents only occurs in the decay topology (TO FACT CHECK), what this function will do is that the function will first check for the non-single parent particles if the exists, the function will rerun the function with the parent particles replacing the non-single parent particle as the input.</p>
<p>The Least Common Ancestor Algorithm for the tree-like topology uses the hash table method since parent pointers area available: for each member in the list, trace the ancestry to the root node and track the number of times a parent particles has been traversed. The particle return will be the one with the maximum number of traverse count (not returning an exact results, since the there will be accidental merging in the verticies) </p>

</div>
</div>
<a id="ga27548e8aaf531a36cc74bff66260bb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27548e8aaf531a36cc74bff66260bb7a">&#9670;&nbsp;</a></span>IsIntermediate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::IsIntermediate </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks to see if the input particle has any daughter particle has the same partice id as the input particle. If such a daughter particle exists, then the particle is considered intermediate. </p>

</div>
</div>
<a id="ga12a92107aa5e300874e17452fa11b3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12a92107aa5e300874e17452fa11b3d8">&#9670;&nbsp;</a></span>IsSMHadron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::IsSMHadron </td>
          <td>(</td>
          <td class="paramtype">const reco::Candidate *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PDGID paring flag. Not accurate but close enough for 99.9% of use cases </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
