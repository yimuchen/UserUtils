<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: GSLUtils</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">GSLUtils<div class="ingroups"><a class="el" href="group__MathUtils.html">MathUtils</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Simplifying commonly used GSL routines used in various calculation routines to single functions that should converge in for most of the use cases. Extreme cases would always need specific processing, but this collections of functions is still useful for development. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf126ce74fb055b4b40e2283da0fdee3c"><td class="memItemLeft" align="right" valign="top">typedef gsl_multimin_function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">usr::gsl::gsl_multifunc</a></td></tr>
<tr class="memdesc:gaf126ce74fb055b4b40e2283da0fdee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">defining a new name for the \(R^{n}\rightarrow R\) function.  <a href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">More...</a><br /></td></tr>
<tr class="separator:gaf126ce74fb055b4b40e2283da0fdee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1fdc2447d240ba4f0cd3112981d9a366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga1fdc2447d240ba4f0cd3112981d9a366">usr::gsl::IterateSolver</a> (gsl_multiroot_fsolver *solver)</td></tr>
<tr class="memdesc:ga1fdc2447d240ba4f0cd3112981d9a366"><td class="mdescLeft">&#160;</td><td class="mdescRight">automatically handling the gsl solver for a multiroot setups  <a href="group__GSLUtils.html#ga1fdc2447d240ba4f0cd3112981d9a366">More...</a><br /></td></tr>
<tr class="separator:ga1fdc2447d240ba4f0cd3112981d9a366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2743c5be7e57b91842a1b0f55b7e7960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga2743c5be7e57b91842a1b0f55b7e7960">usr::gsl::IterateSolver</a> (gsl_root_fsolver *solver)</td></tr>
<tr class="memdesc:ga2743c5be7e57b91842a1b0f55b7e7960"><td class="mdescLeft">&#160;</td><td class="mdescRight">automaticaly iterating the gsl single root solver.  <a href="group__GSLUtils.html#ga2743c5be7e57b91842a1b0f55b7e7960">More...</a><br /></td></tr>
<tr class="separator:ga2743c5be7e57b91842a1b0f55b7e7960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a4cf657ca1e9142c5e9d7cc127b22d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gaf7a4cf657ca1e9142c5e9d7cc127b22d">usr::gsl::IterateSolver</a> (gsl_min_fminimizer *solver)</td></tr>
<tr class="memdesc:gaf7a4cf657ca1e9142c5e9d7cc127b22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">automatically iterating the gsl single variable minimizer.  <a href="group__GSLUtils.html#gaf7a4cf657ca1e9142c5e9d7cc127b22d">More...</a><br /></td></tr>
<tr class="separator:gaf7a4cf657ca1e9142c5e9d7cc127b22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81c41618e90cc92bbecd6c3a0f1d9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gac81c41618e90cc92bbecd6c3a0f1d9e5">usr::gsl::IterateSolver</a> (gsl_multimin_fminimizer *solver)</td></tr>
<tr class="memdesc:gac81c41618e90cc92bbecd6c3a0f1d9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">automatically iterating a gsl multi-dimension minimizer.  <a href="group__GSLUtils.html#gac81c41618e90cc92bbecd6c3a0f1d9e5">More...</a><br /></td></tr>
<tr class="separator:gac81c41618e90cc92bbecd6c3a0f1d9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e5a6a930fe77ebc90ca75d5440cef5"><td class="memItemLeft" align="right" valign="top"><a id="gaf9e5a6a930fe77ebc90ca75d5440cef5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gaf9e5a6a930fe77ebc90ca75d5440cef5">usr::gsl::Solve1D</a> (gsl_function *func, double yval, double xmin, double xmax)</td></tr>
<tr class="memdesc:gaf9e5a6a930fe77ebc90ca75d5440cef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">solving a 1 dimension function \(f(x)=y\), user must provide bracket <br /></td></tr>
<tr class="separator:gaf9e5a6a930fe77ebc90ca75d5440cef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4b710a9e8f8020b6e3600e379a0cbb"><td class="memItemLeft" align="right" valign="top"><a id="ga7c4b710a9e8f8020b6e3600e379a0cbb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga7c4b710a9e8f8020b6e3600e379a0cbb">usr::gsl::sum</a> (const gsl_vector *x, void *)</td></tr>
<tr class="memdesc:ga7c4b710a9e8f8020b6e3600e379a0cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">handy parameter-less function for <a class="el" href="group__StatUtils.html#gaaf5fe33db693d842779d0bd22932b182">later uses</a> <br /></td></tr>
<tr class="separator:ga7c4b710a9e8f8020b6e3600e379a0cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce5bd2b1ff517c75c153000cc9c35b6"><td class="memItemLeft" align="right" valign="top"><a id="gabce5bd2b1ff517c75c153000cc9c35b6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gabce5bd2b1ff517c75c153000cc9c35b6">usr::gsl::product</a> (const gsl_vector *x, void *)</td></tr>
<tr class="memdesc:gabce5bd2b1ff517c75c153000cc9c35b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">handy parameter-less function for <a class="el" href="group__StatUtils.html#ga2b3f105de2d7fab92768b364bf3acd20">later use</a> <br /></td></tr>
<tr class="separator:gabce5bd2b1ff517c75c153000cc9c35b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8f0f506ee078a65d09f4cf7f233bc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga7d8f0f506ee078a65d09f4cf7f233bc6">usr::gsl::partial_deriv</a> (<a class="el" href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">gsl_multifunc</a> *function, gsl_vector *x, size_t varidx, double h, double &amp;result, double &amp;error)</td></tr>
<tr class="memdesc:ga7d8f0f506ee078a65d09f4cf7f233bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial derivative function for a multi-variable function  <a href="group__GSLUtils.html#ga7d8f0f506ee078a65d09f4cf7f233bc6">More...</a><br /></td></tr>
<tr class="separator:ga7d8f0f506ee078a65d09f4cf7f233bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab58d5c5407f66a5a31bf78f4d68371b1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gab58d5c5407f66a5a31bf78f4d68371b1">usr::gsl::deriv</a> (gsl_function *F, double x)</td></tr>
<tr class="memdesc:gab58d5c5407f66a5a31bf78f4d68371b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">simpler interface for calculating a derivative at a given point.  <a href="group__GSLUtils.html#gab58d5c5407f66a5a31bf78f4d68371b1">More...</a><br /></td></tr>
<tr class="separator:gab58d5c5407f66a5a31bf78f4d68371b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24aa540d743691d6162bb07010fcc1e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga24aa540d743691d6162bb07010fcc1e5">usr::gsl::partial_deriv</a> (<a class="el" href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">gsl_multifunc</a> *function, gsl_vector *x, size_t varidx)</td></tr>
<tr class="memdesc:ga24aa540d743691d6162bb07010fcc1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">simpler interface for partial derivatives.  <a href="group__GSLUtils.html#ga24aa540d743691d6162bb07010fcc1e5">More...</a><br /></td></tr>
<tr class="separator:ga24aa540d743691d6162bb07010fcc1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac1d5748cde8eeef5ca7dccded4b28bc1"><td class="memItemLeft" align="right" valign="top"><a id="gac1d5748cde8eeef5ca7dccded4b28bc1"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gac1d5748cde8eeef5ca7dccded4b28bc1">usr::gsl::abs_epsilon</a> = 1e-8</td></tr>
<tr class="memdesc:gac1d5748cde8eeef5ca7dccded4b28bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute value difference to terminate iterations. <br /></td></tr>
<tr class="separator:gac1d5748cde8eeef5ca7dccded4b28bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73664b1843fd7f5ae9969284bae04086"><td class="memItemLeft" align="right" valign="top"><a id="ga73664b1843fd7f5ae9969284bae04086"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga73664b1843fd7f5ae9969284bae04086">usr::gsl::rel_epsilon</a> = 1e-6</td></tr>
<tr class="memdesc:ga73664b1843fd7f5ae9969284bae04086"><td class="mdescLeft">&#160;</td><td class="mdescRight">relative value difference to terminate iterations. <br /></td></tr>
<tr class="separator:ga73664b1843fd7f5ae9969284bae04086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6b3d597e6117d52b7db7b2addf2d5f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#gaac6b3d597e6117d52b7db7b2addf2d5f">usr::gsl::mch_epsilon</a> = 1-std::nexttoward( 1, 0 )</td></tr>
<tr class="memdesc:gaac6b3d597e6117d52b7db7b2addf2d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo machine epsilon to initialize iterations for next to boundary situations.  <a href="group__GSLUtils.html#gaac6b3d597e6117d52b7db7b2addf2d5f">More...</a><br /></td></tr>
<tr class="separator:gaac6b3d597e6117d52b7db7b2addf2d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2f00b10083ab37e057fd8c00dda930"><td class="memItemLeft" align="right" valign="top">const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GSLUtils.html#ga8c2f00b10083ab37e057fd8c00dda930">usr::gsl::max_iteration</a> = 1e+4</td></tr>
<tr class="memdesc:ga8c2f00b10083ab37e057fd8c00dda930"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum iterations to run the various GSL solvers.  <a href="group__GSLUtils.html#ga8c2f00b10083ab37e057fd8c00dda930">More...</a><br /></td></tr>
<tr class="separator:ga8c2f00b10083ab37e057fd8c00dda930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf126ce74fb055b4b40e2283da0fdee3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf126ce74fb055b4b40e2283da0fdee3c">&#9670;&nbsp;</a></span>gsl_multifunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gsl_multimin_function <a class="el" href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">usr::gsl::gsl_multifunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>basically the function used for the gsl minimizers:</p><ul>
<li>double (* f)( const gsl_vector* x, void* params)</li>
<li>size_t n</li>
<li>void* params </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab58d5c5407f66a5a31bf78f4d68371b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab58d5c5407f66a5a31bf78f4d68371b1">&#9670;&nbsp;</a></span>deriv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::gsl::deriv </td>
          <td>(</td>
          <td class="paramtype">gsl_function *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The stepsize is automatically determined such that the the error is smaller than the abs_epsilon and rel_epsilon values. The step size starts at \(10^{-4}\) and reduces by a factor of 2 with a minimum cap at \(10^{-8}\) </p>

</div>
</div>
<a id="ga1fdc2447d240ba4f0cd3112981d9a366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fdc2447d240ba4f0cd3112981d9a366">&#9670;&nbsp;</a></span>IterateSolver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::gsl::IterateSolver </td>
          <td>(</td>
          <td class="paramtype">gsl_multiroot_fsolver *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of iterations is not just gsl::max_iteration, but timed by the dimension of the problem given in the solver. As the residual test only provided by GSL only contains distance tests, the absolute distance epsilon is used for termination determination. </p>

</div>
</div>
<a id="ga2743c5be7e57b91842a1b0f55b7e7960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2743c5be7e57b91842a1b0f55b7e7960">&#9670;&nbsp;</a></span>IterateSolver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::gsl::IterateSolver </td>
          <td>(</td>
          <td class="paramtype">gsl_root_fsolver *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notice that this iteration would terminate if the absolute uncertainty is smaller than the gsl::abs_epsilon. So this function might not be suitable is the solution is known to be extremely small. </p>

</div>
</div>
<a id="gaf7a4cf657ca1e9142c5e9d7cc127b22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a4cf657ca1e9142c5e9d7cc127b22d">&#9670;&nbsp;</a></span>IterateSolver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::gsl::IterateSolver </td>
          <td>(</td>
          <td class="paramtype">gsl_min_fminimizer *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notice that this iteration would terminate if the absolute uncertainty is smaller than the gsl::abs_epsilon. So this function might not be suitable is the solution is known to be extremely small. </p>

</div>
</div>
<a id="gac81c41618e90cc92bbecd6c3a0f1d9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81c41618e90cc92bbecd6c3a0f1d9e5">&#9670;&nbsp;</a></span>IterateSolver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::gsl::IterateSolver </td>
          <td>(</td>
          <td class="paramtype">gsl_multimin_fminimizer *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of iterations is not just gsl::max_iteration, but timed by the dimension of the problem given in the solver. As the residual test only provided by GSL only contains distance tests, the absolute distance epsilon is used for termination determination. </p>

</div>
</div>
<a id="ga7d8f0f506ee078a65d09f4cf7f233bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8f0f506ee078a65d09f4cf7f233bc6">&#9670;&nbsp;</a></span>partial_deriv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usr::gsl::partial_deriv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">gsl_multifunc</a> *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>varidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the function \(f(\vec{x})\), a input point \(\vec{x}_0\), and a variable index $i$, this function calculates the results \(\frac{\partial f(\vec{x}_0)}{\partial x_i}\). This is using the vanilla GSL interface where the user must provide a stepsize and references to store the results. </p>

</div>
</div>
<a id="ga24aa540d743691d6162bb07010fcc1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24aa540d743691d6162bb07010fcc1e5">&#9670;&nbsp;</a></span>partial_deriv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::gsl::partial_deriv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__GSLUtils.html#gaf126ce74fb055b4b40e2283da0fdee3c">gsl_multifunc</a> *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>varidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same scheme as that used in <a class="el" href="group__GSLUtils.html#gab58d5c5407f66a5a31bf78f4d68371b1" title="simpler interface for calculating a derivative at a given point. ">deriv()</a> </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga8c2f00b10083ab37e057fd8c00dda930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c2f00b10083ab37e057fd8c00dda930">&#9670;&nbsp;</a></span>max_iteration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned usr::gsl::max_iteration = 1e+4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>should be enough to get decent values for typical use cases. </p>

</div>
</div>
<a id="gaac6b3d597e6117d52b7db7b2addf2d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac6b3d597e6117d52b7db7b2addf2d5f">&#9670;&nbsp;</a></span>mch_epsilon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double usr::gsl::mch_epsilon = 1-std::nexttoward( 1, 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this is the difference between 1 and the next largest double smaller than 1 ( \(\sim10^{-50}\)). Enough for most test cases to converge properly. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.14
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
