@defgroup PlotUtilsCore PlotUtilsCore
@ingroup PlotUtils
@brief Core mechanisms to enhance the plotting mechanics on @ROOT

The construction of @ROOT plotting objects, both the canvases and pads used to
contain and index the plotting instructions and the data containers used for
instructing the plotting process relies heavily on ROOT's internal memory
manager to keep track of what is plotting one where and how. While this setup
does allow for arbitrarily complicated layouts and "simple" plotting across
difference platforms with the string based object identification, these are not
desireable features for analysis, where layouts are relatively simple, yet one
needs a more rigorous interface to ensure plotting clarity, especially where
data containers might required intensive and complicated calculation routines
before actually being plotted.

This library defines the core mechanisms to concrete the plotting process for
analysts using ROOT for data processing via our own wrapper classes:

# Rigid pad--canvas hierarchy

@ROOT defines how a pad by when the pad is spawn, and which working
pad-or-canvas is being used at the time. While this might be important for
use cases where pads might need to be sporadically spawn depending on user/data
input, this is usually not the case for analysis plots, where the layout is
relatively fixed depending on how the author wants to present the data.

The Canvas and PadBase classes defines a rigorous single-layer pad--canvas
structure: canvases defines how the the final plots dimensions, and is
responsible for saving and exporting the plot in general; pads are owned by
the canvas, responsible for storing which data and image elements are used to
produce the plot. While Canvas and PadBase are inherited from the @ROOT{TCanvas}
and @ROOT{TPad} respectively, the inheritance is intentionally hidden so that
the user will not accidentally spawn pad object accidentally; in face even
the construction of the PadBase object is only accessible from the Canvas class.

# Plotting data on specified pads

In ROOT plotting, and object is plotted simply by calling `TObject::Draw()`.
Where this plotting would end up is solely dependent on the working pad in the
ROOT framework, and is not immediately obvious for the user. While this is
simple for when you want to quickly check the output of a single histogram
object in the ROOT CINT interface. This is not very useful for analysis plots,
where complicated data relation need to be presented.

The most baseline improvement made in this program is in the PadBase object,
where the user is encouraged to use the new `PadBase::PlotObj()` interface to
ensure that the object is being plotted on a specific pad. While more
improvements would be given in the the children classes to provide...

# Proper indexing of plotting styles

The magic strings used the original `TObject::Draw()` functions are incredibly
infuriating to use. The string used for the same plot style on different objects
are just different and not intuitive to read; objects without special strings
may or may not wipe the pad of plotting objects. The specialization of the
original PadBase class futher helps with the providing a more comprehensive
indication of how to properly present a data (currently only Pad1D for 1
dimensional data presentation for now).

@class usr::plt::Canvas
@ingroup PlotUtilsCore
@brief Extending the @ROOT{TCanvas} class for better saving and pad--canvas
       hierarchy relations.

The Canvas class is designed as an extension to the @ROOT{TCanvas} object to
increase the functionality on two fronts:

- **Better saving functions**:
  The image files generated by the @ROOT engine is mediocre at best: the PDF
  files generated by the routines in root is not compatible with with some latex
  engines (xelatex); due the a fixed PDI in the root engine, the raster images
  generated by the in-built save functions are notoriously bad.
  The new `SaveAs()` functions call on common Linux image processing tools that
  are available in Scientific Linux to fix PDF issues, as well as using the PDF
  to properly produce high quality raster images to be used in presentation.
  Additional helper functions are available for saving the object as ROOT style
  files (C++ macros and @ROOT objects in a .root file). For additional
  information, please consult the functions:
  - Canvas::SaveAsPDF()
  - Canvas::SaveAsPNG()
  - Canvas::SaveAsCPP()
  - Canvas::SaveToROOT()

- **Ensuring a proper Pad-Canvas ownership relation ships**:
  While arbitrary @ROOT{TPad} spawning in @ROOT allows for arbitrary complex
  layouts, for publication papers where the layout is relatively simple, such
  freedom makes it difficult to keep track on which pad is contained in which
  parent canvas, and which pad an object will be plotted on when the Draw
  function of the @ROOT object is called.
  The new interface ensure a strict two level hierarchy: a Canvas which is used
  for plot size determination, and the pad which lists the objects that will be
  plotted. While the Draw function is still available, the user is encouraged to
  use the call the `Plot` functions in the Pad implementations for a more
  comprehensive expression of where objects are being plotted. (For more
  information on the `Plot` functions, please consult the documentation of the
  PadBase class, and it's children).

- **Direct layout setting functions**: When used along side the helper function
  listed in the Constants.hpp file,

@class   usr::plt::PadBase
@ingroup PlotUtilsCore
@brief Baseline enhancement to the @ROOT{TPad} object and pad--canvas hierarchy
       implementation.

This class and it's children are to be directly owned by the Canvas class,
enforcing a single layer pad--canvas hierarchy, while also providing the
function `PlotObj` to ensure that a certain object is plotted onto a specified
pad.

There are an embedded @ROOT{TLatex} object to assist with writing on the Pad in
a uniform font setting to the parent canvas. As well has function to help with
calculating the effective size of the Pad.

Note that this functions would have its constructor protected, so all creation
of this class would only be possible through a parent canvas object.
