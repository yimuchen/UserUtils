<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: Standardized Plotting routine</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Standardized Plotting routine<div class="ingroups"><a class="el" href="group__PlotUtils.html">PlotUtils</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>In high energy physics, we will have some form of standardized plotting used throughout the analysis. A set of common variable histograms are created for each simulated and data samples, weighted according to cross sections and various correction factors, the background will typically be a stacked histogram with uncertainties, the data is plotted as scatter plots.</p>
<p>This part of the library aims to allow the user the list the processes as in a JSON file, and allow the generation of the standardized plots with each MC sample properly weighted according to their cross section and have their common uncertainties properly tallied. This allows for consistencies between the various plots that are displayed in the analysis, as well as attempting to segregate the code needed for calculating analysis specific processes, and the common aesthetic and simple error propagation routines.</p>
<h2>The construction of standardized plot request</h2>
<p>The idea of the standardized plotting procedure is as such: for each hard-scattering “process” used in the analysis, whether background, signal or data, will generate a bunch of histograms based on some common analysis algorithm, saved in similar formats with in different files. A plotting routine then simply looks into a configuration file, retrieves the required histograms required a certain plot, run some basic calculations such as rescaling, and plot the background, signal and data together in a plot. A “process” to this routine is then just a file containing the relevant histogram objects, and a bunch of variables adjusting how the histogram should be scaled and how to present the data (in the legend). The user will also need to define which histograms should be used in which processes.</p>
<p>Having this picture in mind, the construction of a standardized plot request in the form of a <code><a class="el" href="classusr_1_1plt_1_1fmt_1_1BatchRequest.html" title="Class defining a request to run some standardized plotting routine.">usr::plt::fmt::BatchRequest</a></code> class includes the following ingredients:</p>
<ul>
<li>A list of histogram requests</li>
<li>A set of processes as backgrounds sorted into groups</li>
<li>A list of processes as data (can be omitted)</li>
<li>A list of processes as signal to be displayed (can be omitted)</li>
<li>A list of uncertainties to use for plotting uncertainties.</li>
<li>A set of IO options, such as where the read the files, where to place the output file (can be omitted).</li>
</ul>
<p>This is defined using an input JSON file, using the following format:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;Plot List&quot;: [ {HistRequest:1}, {HistRequest:2} ],</div>
<div class="line">  &quot;Uncertainties&quot;: [ {Uncertainty:1}, {Uncertainty:2} ],</div>
<div class="line">  &quot;Data sets&quot; : {</div>
<div class="line">    &quot;Display&quot;: &quot;Data&quot;,</div>
<div class="line">    &quot;processes&quot;:[{process: data1},{ process: data2}]</div>
<div class="line">  },</div>
<div class="line">  &quot;Signal Processes&quot;: [ {process:signal1} ,{process:signal2} ],</div>
<div class="line">  &quot;Background Processes&quot;: [</div>
<div class="line">    {group:background_group1},</div>
<div class="line">    {group:background_group2}</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each of the object describe in a parenthesis matches an object in the C++ class:</p>
<h3>Defining a process (<code><a class="el" href="classusr_1_1plt_1_1fmt_1_1Process.html" title="Constainer of a single process information.">usr::plt::fmt::Process</a></code>)</h3>
<p>A stated to before, the process class defines the file in which to retrieve histogram files, some flags to define how the additional calculation is being processes (think the cross section of the process and additional scale factors), and how the data should be presented on the graph (labels, color and such).</p>
<p>And example of the constructing a simulated process in a JSON format is as followed:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;display&quot;: &quot;t*#bar{t}* (M_{t*}=100TeV)&quot;,</div>
<div class="line">  &quot;latex&quot;: &quot;\tstarpair (M_\tstar = 100\TeV)&quot;,</div>
<div class="line">  &quot;cross section&quot;: [ 10, 0.072, 0.072 ],</div>
<div class="line">  &quot;scaling&quot;: 1.0,</div>
<div class="line">  &quot;generator&quot;: &quot;\\POWHEG&quot;,</div>
<div class="line">  &quot;cross section source&quot;: &quot;NNLO&quot;,</div>
<div class="line">  &quot;luminosity&quot; : 1000,</div>
<div class="line">  &quot;key prefix&quot;: &quot;signal_&quot;,</div>
<div class="line">  &quot;File&quot;: &quot;sig.root&quot;,</div>
<div class="line">  &quot;Color&quot;: &quot;navy&quot;,</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>display</code> string is the ROOT-flavored Latex string that is used to display in the legend, of the plot, while the <code>latex</code> string is simply latex commands that want in a standard latex table generation. The cross section are in units of picobarns, the usual standard in CMS analysis. It is worth noting that the luminosity here refers to the <b>effective luminosity</b> of the sample used to produce these histograms (i.e. the luminosity needed to reach to total (unfiltered) number of events used to generate the histogram). Apart from explicitly specifying the effective luminosity here, the program also looks for a <a href="https://root.cern.ch/doc/master/classTTree.html">TTree</a> of the name <code>Count</code> in the same file, and looks for a leaf entry called <code>OriginalEvents</code> to calculate the effective luminosity. To use this functionality, omit the <code>luminosity</code> entry in the JSON file. For more detail which entries can be omitted from the declaration, see the constructor for the class <code><a class="el" href="classusr_1_1plt_1_1fmt_1_1Process.html" title="Constainer of a single process information.">usr::plt::fmt::Process</a></code>.</p>
<p>Another example of defining a process is that for a data process, which will look something like:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;display&quot;: &quot;Run2077M&quot;,</div>
<div class="line">  &quot;latex&quot;: &quot;/SingleHiggs/Run2077D/03Feb2017-v1&quot;,</div>
<div class="line">  &quot;luminosity&quot;: 12.34,</div>
<div class="line">  &quot;run range&quot; : [100000,120000],</div>
<div class="line">  &quot;file&quot;: &quot;data1.root&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this use case, the luminosity is the actual luminosity corresponding to the data process of interest.</p>
<h3>Defining a group of processes (<code><a class="el" href="classusr_1_1plt_1_1fmt_1_1ProcessGroup.html" title="Container for a group of processes that will share a common display information.">usr::plt::fmt::ProcessGroup</a></code>)</h3>
<p>When defining background processes, it is usually too verbose to display all processes individually (think a single background process split up into multiple HT binned samples to increase the number of events in the analysis). The same goes for data: data for different eras might need to be processed slightly differently, so it makes sense to split them into different files, yet typically we want to display the data as a single entry of in the plot. For this, we define the <code><a class="el" href="classusr_1_1plt_1_1fmt_1_1ProcessGroup.html" title="Container for a group of processes that will share a common display information.">usr::plt::fmt::ProcessGroup</a></code> class, which essentially a group of processes is tallied up essentially as a single entity, sharing the same plotting style and group and entry name. To define a process group would look something like:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;display&quot;: &quot;Y+Jets&quot;,</div>
<div class="line">  &quot;latex&quot;: &quot;Y+Jets&quot;,</div>
<div class="line">  &quot;color&quot;: &quot;#FF0000&quot;,</div>
<div class="line">  &quot;processes&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;display&quot;: &quot;Y+Jets (H_{T} &lt; 10TeV)&quot;,</div>
<div class="line">      &quot;latex&quot;: &quot;Y+Jets, \\HT$\\in$ [0,10)\\TeV&quot;,</div>
<div class="line">      &quot;cross section&quot;: [ 200,   2.2, 2.3],</div>
<div class="line">      &quot;scaling&quot;: 1.21,</div>
<div class="line">      &quot;generator&quot;: &quot;\\MADGRAPH&quot;,</div>
<div class="line">      &quot;cross section source&quot;: &quot;LO&quot;,</div>
<div class="line">      &quot;file&quot;: &quot;YJets_10HT.root&quot;</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;display&quot;: &quot;Y+jets (10 #leq H_{T} #leq 20 TeV)&quot;,</div>
<div class="line">      &quot;latex&quot;: &quot;\\Y+Jets, \\HT$\\in$ [10,20)\\TeV&quot;,</div>
<div class="line">      &quot;cross section&quot;: [ 120, 5.5, 6.0],</div>
<div class="line">      &quot;scaling&quot;: 1.0,</div>
<div class="line">      &quot;generator&quot;: &quot;\\MADGRAPH&quot;,</div>
<div class="line">      &quot;cross section source&quot;: &quot;LO&quot;,</div>
<div class="line">      &quot;file&quot;: &quot;YJets_20HT.root&quot;</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice that the color defined here will proceed any color defined in an individual process within a process group. If you look closely the in the first JSON fragment, you will see the declaration of the data processes in the master <code><a class="el" href="classusr_1_1plt_1_1fmt_1_1BatchRequest.html" title="Class defining a request to run some standardized plotting routine.">BatchRequest</a></code> construction is in fact the declaration of a <code><a class="el" href="classusr_1_1plt_1_1fmt_1_1ProcessGroup.html" title="Container for a group of processes that will share a common display information.">ProcessGroup</a></code>.</p>
<h3>Defining the Histograms to be plotted (<code><a class="el" href="classusr_1_1plt_1_1fmt_1_1HistRequest.html" title="Container for a histogram request.">usr::plt::fmt::HistRequest</a></code>)</h3>
<p>The definition of the histogram to plot is simply:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;JetPt&quot;,</div>
<div class="line">  &quot;xaxis&quot;: &quot;Jet p_{T}&quot;,</div>
<div class="line">  &quot;units&quot;: &quot;GeV&quot;,</div>
<div class="line">  &quot;yaxis&quot;: &quot;Number of Jets&quot;,</div>
<div class="line">  &quot;filekey&quot;: &quot;JetPt&quot;,</div>
<div class="line">  &quot;logy&quot; : false</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we can see the have the ability to reformat the plot entries such as the x and y-axis names into something more human-readable. We also have the option to generate a semi-log plot. Unfortunately, the binning cannot be changed at this stage. Notice that the corresponding output file will be saved to <code>name</code> entry for a histogram request, by default the histogram extracted from each root file will have the corresponding <code>filekey</code> entry, which will match the <code>name</code> entry if not specified.</p>
<hr  />
<p>As this point we can get a simple overview of the what a typical standard plotting process will do, First for a single histogram entry (let say, name=<code>JetPt</code>) a bunch of histograms is defined:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">signal_hist = signal_file-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...);</div>
<div class="line"> </div>
<div class="line">background_1   = background_group1_process1-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...);</div>
<div class="line">background_1-&gt;Add( background_group1_process2-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...) );</div>
<div class="line">background_1-&gt;Add( background_group1_process3-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...) );</div>
<div class="line">background_1-&gt;Add( background_group1_process4-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...) );</div>
<div class="line">...</div>
<div class="line">background_2   = background_group1_process1-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...);</div>
<div class="line">background_2-&gt;Add( background_group1_process2-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...) );</div>
<div class="line">background_2-&gt;Add( background_group1_process3-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...) );</div>
<div class="line">background_2-&gt;Add( background_group1_process4-&gt;Get(&quot;JetPt&quot;)-&gt;Scale(...) );</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">data = data_1-&gt;Get(&quot;JetPt&quot;);</div>
<div class="line">data-&gt;Add( data_2-&gt;Get(&quot;JetPt&quot;) );</div>
</div><!-- fragment --><p>For the plotting the various background histograms are plotted as a stacked histogram <em>in reverse order</em>, as the background processes are expected to be listing in most-to-least-significant ordering. Then the signal histogram is plotted as a simple histogram super imposed over the data. The data histogram is finally plotted as a standard scatter plot. After plotting this sequence, the data/background ratio plot is also plotted on a separate pad. In terms of the objects in our custom plotting library, the plotting procedure would be something like:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">usr::plt::Ratio1DCanvas c;</div>
<div class="line">c.PlotHist( background_4,</div>
<div class="line">            usr::plt::PlotType( usr::plt::stack ),</div>
<div class="line">            usr::plt::FillColor( background_group4.color ),</div>
<div class="line">            usr::plt::EntryText( background_group4.display ) ) ;</div>
<div class="line">c.PlotHist( background_3,</div>
<div class="line">            usr::plt::PlotType( usr::plt::stack ),</div>
<div class="line">            usr::plt::FillColor( background_group3.color ),</div>
<div class="line">            usr::plt::EntryText( background_group3.display ) ) ;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">c.PlotHist( signal_hist,</div>
<div class="line">            usr::plt::PlotType( usr::plt::hist ),</div>
<div class="line">            usr::plt::LineColor( signal.color ),</div>
<div class="line">            usr::plt::EntryText( signal.display ) ) ;</div>
<div class="line">c.PlotHist( data,</div>
<div class="line">            usr::plt::PlotType( usr::plt::scatter ),</div>
<div class="line">            usr::plt::EntryText( data.display ) ) ;</div>
<div class="line"> </div>
<div class="line">c.PlotRatio( data, background_total );</div>
</div><!-- fragment --><p>The program is designed to automatically handle the scaling of the various histograms given the user input in the JSON file, as well as ensuring uniform data styling according to typical publication recommendation. One thing not yet address the inclusion of uncertainty which we will introduce now:</p>
<h2>Defining uncertainties for background plotting</h2>
<p>Typically, uncertainties are split into two types: shaped and normalization. Here we are unifying them into simply 1 type: shaped uncertainties. Essentially what we do here is for each source of uncertainty, we generate a different background template and use this to calculate help calculate the total uncertainty. Declarations of uncertainty sources will look something like:</p>
<div class="fragment"><div class="line">&quot;Uncertainties&quot;: [</div>
<div class="line">  {</div>
<div class="line">    &quot;name&quot;: &quot;Lepton Weighting&quot;,</div>
<div class="line">    &quot;Key name&quot;: &quot;Lep&quot;</div>
<div class="line">  },</div>
<div class="line">  {</div>
<div class="line">    &quot;name&quot; : &quot;Luminosity&quot;,</div>
<div class="line">    &quot;Norm uncertainty&quot; : [0.025,0.026]</div>
<div class="line">  }</div>
<div class="line">]</div>
</div><!-- fragment --><p>In the case where a <code>key name</code> is provided for an uncertainty source, like with the lepton weighting uncertainty above, the plotting algorithm will look for histograms with the names <code>histogram_name + uncertainty_key + "Up"</code> and <code>histogram_name + uncertainty_key + "Down"</code>, and use the histograms to estimate the uncertainty of bin contents. If only the <code>norm uncertainty</code> is tag provided, then alternative histogram templates are generated simply by scaling the central histogram by the normalization uncertainties given. The calculation of the uncertainties displayed are calculated bin-by-bin. Uncertainties of the same source across different processes are assumed to have 100% correlation. Uncertainties from different sources are assumed to have no correlation, and for asymmetric uncertainty numbers are calculated using the function provided in the <code>MathUtils</code> package.</p>
<h2>Standard binary</h2>
<p>If you are not going to customize the plotting procedure yourself, a standard binary is provided in the form of <code>usr_PlotStandard</code> by the package. Additional plotting routines are also possible and see the documentation of the binary file and the <code><a class="el" href="classusr_1_1plt_1_1fmt_1_1BatchRequest.html" title="Class defining a request to run some standardized plotting routine.">BatchRequest</a></code> class for more documentation. An example of dummy files generate for plotting tests can be found in the testing binaries. And below is an example plot generated using the standard binary:</p>
<div class="plot_example"> <img src="image/std_plot.png" alt="" class="inline"/></div><div class="plot_example"><ul>
<li>
<a href="image/std_plot.png">72dpi output</a> </li>
<li>
<a href="image/std_plot_highres.png">300dpi output</a> </li>
<li>
<a href="image/std_plot.pdf">PDF output</a> </li>
</ul>
</div><hr  />
<h2>DISCLAIMER</h2>
<p>This package is currently very much in flux. If you are using this function and something changes that you don't like, please let me know. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1fmt_1_1Process.html">usr::plt::fmt::Process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constainer of a single process information.  <a href="classusr_1_1plt_1_1fmt_1_1Process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1fmt_1_1ProcessGroup.html">usr::plt::fmt::ProcessGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a group of processes that will share a common display information.  <a href="classusr_1_1plt_1_1fmt_1_1ProcessGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1fmt_1_1HistRequest.html">usr::plt::fmt::HistRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a histogram request.  <a href="classusr_1_1plt_1_1fmt_1_1HistRequest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1fmt_1_1Uncertainty.html">usr::plt::fmt::Uncertainty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for an uncertainty.  <a href="classusr_1_1plt_1_1fmt_1_1Uncertainty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1fmt_1_1IOSetting.html">usr::plt::fmt::IOSetting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a custom io settings.  <a href="classusr_1_1plt_1_1fmt_1_1IOSetting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1fmt_1_1BatchRequest.html">usr::plt::fmt::BatchRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class defining a request to run some standardized plotting routine.  <a href="classusr_1_1plt_1_1fmt_1_1BatchRequest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.18
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
