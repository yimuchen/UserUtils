<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: usr::ArgumentExtender Class Reference</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usr</b></li><li class="navelem"><a class="el" href="classusr_1_1ArgumentExtender.html">ArgumentExtender</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classusr_1_1ArgumentExtender-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usr::ArgumentExtender Class Reference<div class="ingroups"><a class="el" href="group__Common.html">Common</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Often in analysis programs, we need a short string for process indentification, but a longer string for the publication/presentation outputs or change a parameter in calculations calculations. An example of this case would be when an analysis is split into muon/electron channels, where the calculations are nearly entirely the same, but require the plotting to put in unique labels for the two channel, while also potentially using slightly different numbers in calculation (scale factors, integrated luminosity... etc). Such behaviour could be listed in a json file as something like: something like:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  channel:{</div>
<div class="line">    mu:{</div>
<div class="line">      fullname:&quot;#mu channel&quot;</div>
<div class="line">      plotname:&quot;#mu+jets&quot;</div>
<div class="line">      lumi: 1050</div>
<div class="line">    },</div>
<div class="line">    el: {</div>
<div class="line">      fullname:&quot;#it{e} channel&quot;</div>
<div class="line">      plotname: &quot;#it{e}+jets&quot;</div>
<div class="line">      lumi: 1000</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our class would need to first read the input arguments, and be able to get the extended processes in a simple method. In the example above, we would be able to call the program with the options "Options1":</p>
<div class="fragment"><div class="line">./my_analysis_program --channel mu</div>
</div><!-- fragment --><p>And in the analysis code, the extended values could be obtained as:</p>
<div class="fragment"><div class="line">lumi     = args.ArgExt&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;channel&quot;</span>, <span class="stringliteral">&quot;lumi&quot;</span>); <span class="comment">// 1050</span></div>
<div class="line">plotname = args.ArgExt&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;channel&quot;</span>,<span class="stringliteral">&quot;plotname&quot;</span>); <span class="comment">// &quot;@mu+jets&quot;</span></div>
<div class="line">arg     = args.Arg&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;channel&quot;</span>); <span class="comment">// &quot;mu&quot;</span></div>
</div><!-- fragment --><hr  />
<p>The <a class="el" href="classusr_1_1ArgumentExtender.html">ArgumentExtender</a> class is a wrapper for:</p>
<ul>
<li><code>boost::property_tree</code> to store the json file structure described above file.</li>
<li><code>boost::program_options::options_description</code> instance for defining the the the options to be parsed.</li>
<li><code>boost::program_options::variables_map</code> instance for storing the results of the program input options.</li>
</ul>
<p>Functions are added to simplify the argument parsing process, as well as getting the extended argument values. Additional parsing rules will be added to help ensure that the json file formats between options are in sync.</p>
<p>In general, the typical usage of the class should be something like this:</p>
<ol type="1">
<li>Defining the class instance with json file(s). During this step, the parser also checks to see that the json file structure is consistent for each of the potential options (i.e. they have the same extended variables defined in the file.)</li>
<li>Defining the options_description for defining the options.</li>
<li>Take in the program inputs. During this step, the class will also check to see if the option is consistent with the json file (i.e. if the user input has its entry corresponding entry in the json file). The options defined in the json file will be assumed to be madatory argument.</li>
<li>Throughout the program, call the class to get the program inputs and extended variables.</li>
</ol>
<p>For the use-case above. It would look something like:</p>
<div class="fragment"><div class="line">usr::po::options_description desc(<span class="stringliteral">&quot;test options&quot;</span>);</div>
<div class="line">desc.add_options()</div>
<div class="line">  (<span class="stringliteral">&quot;channel,c&quot;</span>,usr::po::value&lt;std::string&gt;())</div>
<div class="line">;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classusr_1_1ArgumentExtender.html">usr::ArgumentExtender</a> myargs(<span class="stringliteral">&quot;name1.json&quot;</span>,<span class="stringliteral">&quot;name2.json&quot;</span>);</div>
<div class="line">myargs.AddOptions(desc);</div>
<div class="line">myargs.ParseOptions(argc,argv);</div>
<div class="line"> </div>
<div class="line">myargs.ArgExt&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;channel&quot;</span>,<span class="stringliteral">&quot;lumi&quot;</span>);</div>
</div><!-- fragment --><hr  />
<h2>File path generation by options</h2>
<p>In the typical case that a user running a command with various options:</p>
<div class="fragment"><div class="line">my_analysis  --method Random --inputtype electron --fittype unbinned --minrange 0.02</div>
</div><!-- fragment --><p>Typically an analysis will want to generate files based on a myriad of input type. So the target filename might look something like:</p>
<div class="fragment"><div class="line">results/electron/MyPlot_MethodRandom_unbinned_min0p02.pdf</div>
</div><!-- fragment --><p>This class allows one to do this sort of file name specification via the embedded <code><a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html" title="Simple wrapper for Argument naming scheme for filename generation.">ArgPathScheme</a></code> class. To use this functionally one will typically need to specify:</p>
<ol type="1">
<li>The prefix path of the generated file name</li>
<li>A list of options that will be used in the director of the file path</li>
<li>A list of options that will be used in the basename of the file path</li>
<li>The prefix of the basename.</li>
<li>The extension of the file</li>
</ol>
<p>Using the above command as an example, the options description will be something like:</p>
<div class="fragment"><div class="line">desc.add_options()</div>
<div class="line">  (<span class="stringliteral">&quot;method&quot;</span>,value&lt;std::string&gt;() )</div>
<div class="line">  (<span class="stringliteral">&quot;inputtype&quot;</span>, value&lt;std::string&gt;() )</div>
<div class="line">  (<span class="stringliteral">&quot;fittype&quot;</span>, value&lt;std::string&gt;() )</div>
<div class="line">  (<span class="stringliteral">&quot;minrange&quot;</span>, value&lt;double&gt;() )</div>
<div class="line">;</div>
</div><!-- fragment --><p>The generation of the file name will need to be set up as something like:</p>
<div class="fragment"><div class="line"><span class="comment">// Setting up a total directory range</span></div>
<div class="line">arg.SetFilePrefix( <span class="stringliteral">&quot;result/&quot;</span> )</div>
<div class="line"> </div>
<div class="line">arg.SetDirScheme( {<span class="stringliteral">&quot;inputtype&quot;</span>, <span class="stringliteral">&quot;&quot;</span>} ); <span class="comment">// Specifying input  to user for directory naming</span></div>
<div class="line">                                       <span class="comment">// The second string is left empty so just the</span></div>
<div class="line">                                       <span class="comment">// argument value will be used for path generation</span></div>
<div class="line"> </div>
<div class="line">arg.SetNameScheme( { <span class="comment">// Specifying inputs to user for basename generation</span></div>
<div class="line">  {<span class="stringliteral">&quot;method&quot;</span>, <span class="stringliteral">&quot;Method&quot;</span>}, <span class="comment">// Add prefix &quot;Method&quot; in front of argument value for path generation</span></div>
<div class="line">  {<span class="stringliteral">&quot;fittype&quot;</span>, <span class="stringliteral">&quot;&quot;</span>} ,     <span class="comment">// No prefix to be added</span></div>
<div class="line">  {<span class="stringliteral">&quot;minrange&quot;</span>, <span class="stringliteral">&quot;min&quot;</span>}   <span class="comment">// prefix &quot;min&quot; is to be added, double type will have slight differences.</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f = arg.MakeFileName(<span class="stringliteral">&quot;MyPlot&quot;</span>, <span class="stringliteral">&quot;pdf&quot;</span>); <span class="comment">// &quot;MyPlot&quot; is the prefix of the file name</span></div>
<div class="line">                                            <span class="comment">// with a pdf file extension.</span></div>
<div class="line"><span class="keyword">auto</span> f = arg.MakeFileName(<span class="stringliteral">&quot;MyOtherPlot&quot;</span>, <span class="stringliteral">&quot;pdf&quot;</span>); <span class="comment">// Can now be used multiple times.</span></div>
</div><!-- fragment --><p>The scheme is effectively a list of two strings, the first being which option to use, the second the string to be used in the final path name (can be blank). This will generate the file name based on the input arguments and the defined strings. Note that the raw, string-like input will be used, so if you input a integer argument as as 1e6, and another time like 100000, this will generate different file names, even if the setup is entirely the same. (Strictly speaking, it will not actually be a list of two string, but for most use cases, this will what it will look like.)</p>
<p>The directory scheme is to use different inputs to generated nested directory names, while the name scheme will generate the resulting base name of the file. A few things points to clean up is that decimal points will be replaced with the character 'p', and list arguments will be separated by the '-' character. The character separating the option inputs values will simply be '_'. If the argument doesn't exists, the the string is simply not generated.</p>
<p>A bunch of functions is also available for generating file paths with commonly used file extensions. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html">ArgPathScheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for Argument naming scheme for filename generation.  <a href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa8ebd0a9b8de2e3c22780c29f09ff864"><td class="memItemLeft" align="right" valign="top"><a id="aa8ebd0a9b8de2e3c22780c29f09ff864"></a>
typedef std::vector&lt; <a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html">ArgPathScheme</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PathScheme</b></td></tr>
<tr class="separator:aa8ebd0a9b8de2e3c22780c29f09ff864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aacf5ddd349e5be7655fe55cb29d634b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#aacf5ddd349e5be7655fe55cb29d634b5">ArgumentExtender</a> ()</td></tr>
<tr class="separator:aacf5ddd349e5be7655fe55cb29d634b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63701254aa23f0dc315b424977204b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a3b63701254aa23f0dc315b424977204b">ArgumentExtender</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a3b63701254aa23f0dc315b424977204b"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialization from single json file.  <a href="classusr_1_1ArgumentExtender.html#a3b63701254aa23f0dc315b424977204b">More...</a><br /></td></tr>
<tr class="separator:a3b63701254aa23f0dc315b424977204b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82abbcf67db5c70058816ad554eb127e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a82abbcf67db5c70058816ad554eb127e">ArgumentExtender</a> (const std::vector&lt; std::string &gt; &amp;list)</td></tr>
<tr class="memdesc:a82abbcf67db5c70058816ad554eb127e"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialization from multiple json files  <a href="classusr_1_1ArgumentExtender.html#a82abbcf67db5c70058816ad554eb127e">More...</a><br /></td></tr>
<tr class="separator:a82abbcf67db5c70058816ad554eb127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f74c30c18bde81dcdfe96baed9ded63"><td class="memTemplParams" colspan="2">template&lt;typename ... TS&gt; </td></tr>
<tr class="memitem:a4f74c30c18bde81dcdfe96baed9ded63"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a4f74c30c18bde81dcdfe96baed9ded63">ArgumentExtender</a> (const std::string &amp;first, TS ... others)</td></tr>
<tr class="memdesc:a4f74c30c18bde81dcdfe96baed9ded63"><td class="mdescLeft">&#160;</td><td class="mdescRight">varidaic initialization for multiple json files.  <a href="classusr_1_1ArgumentExtender.html#a4f74c30c18bde81dcdfe96baed9ded63">More...</a><br /></td></tr>
<tr class="separator:a4f74c30c18bde81dcdfe96baed9ded63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592e5003b4a3bd5b9c4d3ba372505c20"><td class="memItemLeft" align="right" valign="top"><a id="a592e5003b4a3bd5b9c4d3ba372505c20"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a592e5003b4a3bd5b9c4d3ba372505c20">~ArgumentExtender</a> ()</td></tr>
<tr class="memdesc:a592e5003b4a3bd5b9c4d3ba372505c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">default destructor (nothing, relying on member auto cleaning) <br /></td></tr>
<tr class="separator:a592e5003b4a3bd5b9c4d3ba372505c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3527a9bf8ec6156a76ddfafe3deb86f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1ArgumentExtender.html">ArgumentExtender</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#aa3527a9bf8ec6156a76ddfafe3deb86f">AddOptions</a> (const po::options_description &amp;optdesc)</td></tr>
<tr class="memdesc:aa3527a9bf8ec6156a76ddfafe3deb86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding more options definition to the class.  <a href="classusr_1_1ArgumentExtender.html#aa3527a9bf8ec6156a76ddfafe3deb86f">More...</a><br /></td></tr>
<tr class="separator:aa3527a9bf8ec6156a76ddfafe3deb86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e638edf8475fdfe95aef82d3ee74dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a9e638edf8475fdfe95aef82d3ee74dcd">ParseOptions</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a9e638edf8475fdfe95aef82d3ee74dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">parsing the program input with the standard argc, argv interface.  <a href="classusr_1_1ArgumentExtender.html#a9e638edf8475fdfe95aef82d3ee74dcd">More...</a><br /></td></tr>
<tr class="separator:a9e638edf8475fdfe95aef82d3ee74dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9cb52dabdf584c55701d15c12bc074"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a0f9cb52dabdf584c55701d15c12bc074">CheckArg</a> (const std::string &amp;opt) const</td></tr>
<tr class="memdesc:a0f9cb52dabdf584c55701d15c12bc074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking if the user input exists for an option.  <a href="classusr_1_1ArgumentExtender.html#a0f9cb52dabdf584c55701d15c12bc074">More...</a><br /></td></tr>
<tr class="separator:a0f9cb52dabdf584c55701d15c12bc074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590da0152e8a69fd06fe8f4fe84bb38e"><td class="memTemplParams" colspan="2">template&lt;typename TYPE  = std::string&gt; </td></tr>
<tr class="memitem:a590da0152e8a69fd06fe8f4fe84bb38e"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a590da0152e8a69fd06fe8f4fe84bb38e">Arg</a> (const std::string &amp;opt) const</td></tr>
<tr class="memdesc:a590da0152e8a69fd06fe8f4fe84bb38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function for getting the user input of an option.  <a href="classusr_1_1ArgumentExtender.html#a590da0152e8a69fd06fe8f4fe84bb38e">More...</a><br /></td></tr>
<tr class="separator:a590da0152e8a69fd06fe8f4fe84bb38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0ce2b2748ff69042bc40195ee2c2e"><td class="memTemplParams" colspan="2">template&lt;typename TYPE  = std::string&gt; </td></tr>
<tr class="memitem:a41f0ce2b2748ff69042bc40195ee2c2e"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a41f0ce2b2748ff69042bc40195ee2c2e">ArgOpt</a> (const std::string &amp;opt, const TYPE &amp;val) const</td></tr>
<tr class="memdesc:a41f0ce2b2748ff69042bc40195ee2c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning user input if exists, returning default value other wise.  <a href="classusr_1_1ArgumentExtender.html#a41f0ce2b2748ff69042bc40195ee2c2e">More...</a><br /></td></tr>
<tr class="separator:a41f0ce2b2748ff69042bc40195ee2c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b85c615af9f0683a4bc509a0e6dcf8"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a84b85c615af9f0683a4bc509a0e6dcf8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a84b85c615af9f0683a4bc509a0e6dcf8">ArgList</a> (const std::string &amp;opt) const</td></tr>
<tr class="memdesc:a84b85c615af9f0683a4bc509a0e6dcf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function for getting the user input list to an option.  <a href="classusr_1_1ArgumentExtender.html#a84b85c615af9f0683a4bc509a0e6dcf8">More...</a><br /></td></tr>
<tr class="separator:a84b85c615af9f0683a4bc509a0e6dcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b78660bc41f3ae2b25ea019367acb8"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a58b78660bc41f3ae2b25ea019367acb8"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a58b78660bc41f3ae2b25ea019367acb8">ArgExt</a> (const std::string &amp;opt, const std::string &amp;exttag) const</td></tr>
<tr class="memdesc:a58b78660bc41f3ae2b25ea019367acb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function for getting the extend object to an options.  <a href="classusr_1_1ArgumentExtender.html#a58b78660bc41f3ae2b25ea019367acb8">More...</a><br /></td></tr>
<tr class="separator:a58b78660bc41f3ae2b25ea019367acb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e41c2f66d8a7c376f673891135f7773"><td class="memItemLeft" align="right" valign="top"><a id="a7e41c2f66d8a7c376f673891135f7773"></a>
const pt::ptree &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a7e41c2f66d8a7c376f673891135f7773">Tree</a> () const</td></tr>
<tr class="memdesc:a7e41c2f66d8a7c376f673891135f7773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to internal property tree instance. <br /></td></tr>
<tr class="separator:a7e41c2f66d8a7c376f673891135f7773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1609e184c9216db9307bdaf943937af"><td class="memItemLeft" align="right" valign="top"><a id="ac1609e184c9216db9307bdaf943937af"></a>
const po::options_description &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#ac1609e184c9216db9307bdaf943937af">Description</a> () const</td></tr>
<tr class="memdesc:ac1609e184c9216db9307bdaf943937af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to internal options description instance. <br /></td></tr>
<tr class="separator:ac1609e184c9216db9307bdaf943937af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a8a71afeb8e462aba726ad5aa6efcf"><td class="memItemLeft" align="right" valign="top"><a id="ae7a8a71afeb8e462aba726ad5aa6efcf"></a>
const po::variables_map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#ae7a8a71afeb8e462aba726ad5aa6efcf">Args</a> () const</td></tr>
<tr class="memdesc:ae7a8a71afeb8e462aba726ad5aa6efcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to internal argument value map instance. <br /></td></tr>
<tr class="separator:ae7a8a71afeb8e462aba726ad5aa6efcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dd65c5fdc1a0ad1f3dab05868a6cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#ac5dd65c5fdc1a0ad1f3dab05868a6cb9">SetFilePrefix</a> (const fs::path)</td></tr>
<tr class="memdesc:ac5dd65c5fdc1a0ad1f3dab05868a6cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the file prefix for the file path generation.  <a href="classusr_1_1ArgumentExtender.html#ac5dd65c5fdc1a0ad1f3dab05868a6cb9">More...</a><br /></td></tr>
<tr class="separator:ac5dd65c5fdc1a0ad1f3dab05868a6cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2805d452c24d2244a48b363df9343385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a2805d452c24d2244a48b363df9343385">SetDirScheme</a> (const PathScheme &amp;)</td></tr>
<tr class="memdesc:a2805d452c24d2244a48b363df9343385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the directory naming scheme list.  <a href="classusr_1_1ArgumentExtender.html#a2805d452c24d2244a48b363df9343385">More...</a><br /></td></tr>
<tr class="separator:a2805d452c24d2244a48b363df9343385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f81101f996c04f0738f28237a37826"><td class="memItemLeft" align="right" valign="top"><a id="a81f81101f996c04f0738f28237a37826"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a81f81101f996c04f0738f28237a37826">AddDirScheme</a> (const <a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html">ArgPathScheme</a> &amp;)</td></tr>
<tr class="memdesc:a81f81101f996c04f0738f28237a37826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementally adding single directory name scheme to the final list. <br /></td></tr>
<tr class="separator:a81f81101f996c04f0738f28237a37826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b49bea2f25e31e381baa20d311ce37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a01b49bea2f25e31e381baa20d311ce37">AddDirScheme</a> (const PathScheme &amp;)</td></tr>
<tr class="memdesc:a01b49bea2f25e31e381baa20d311ce37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a list of directory naming scheme to the existing list.  <a href="classusr_1_1ArgumentExtender.html#a01b49bea2f25e31e381baa20d311ce37">More...</a><br /></td></tr>
<tr class="separator:a01b49bea2f25e31e381baa20d311ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170980c490d45422faea52412728dfc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a170980c490d45422faea52412728dfc5">SetNameScheme</a> (const PathScheme &amp;)</td></tr>
<tr class="memdesc:a170980c490d45422faea52412728dfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the basename naming scheme list.  <a href="classusr_1_1ArgumentExtender.html#a170980c490d45422faea52412728dfc5">More...</a><br /></td></tr>
<tr class="separator:a170980c490d45422faea52412728dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09635a5b1a610e1831e68ae915767906"><td class="memItemLeft" align="right" valign="top"><a id="a09635a5b1a610e1831e68ae915767906"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a09635a5b1a610e1831e68ae915767906">AddNameScheme</a> (const <a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html">ArgPathScheme</a> &amp;)</td></tr>
<tr class="memdesc:a09635a5b1a610e1831e68ae915767906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementally adding single basename name scheme to the final list. <br /></td></tr>
<tr class="separator:a09635a5b1a610e1831e68ae915767906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd68ab83d9ecae7a490540c41e9af7a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#afd68ab83d9ecae7a490540c41e9af7a5">AddNameScheme</a> (const PathScheme &amp;)</td></tr>
<tr class="memdesc:afd68ab83d9ecae7a490540c41e9af7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a list of basename naming scheme to the existing list.  <a href="classusr_1_1ArgumentExtender.html#afd68ab83d9ecae7a490540c41e9af7a5">More...</a><br /></td></tr>
<tr class="separator:afd68ab83d9ecae7a490540c41e9af7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55333a1830f5cf6a3260b83ede334cbb"><td class="memItemLeft" align="right" valign="top"><a id="a55333a1830f5cf6a3260b83ede334cbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a55333a1830f5cf6a3260b83ede334cbb">PrintHelpAndExit</a> () const</td></tr>
<tr class="memdesc:a55333a1830f5cf6a3260b83ede334cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printing help message of arguments and exit the program. <br /></td></tr>
<tr class="separator:a55333a1830f5cf6a3260b83ede334cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4b622ade148a41fa08c1563e8eb1ec"><td class="memTemplParams" colspan="2"><a id="a6c4b622ade148a41fa08c1563e8eb1ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c4b622ade148a41fa08c1563e8eb1ec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Arg</b> (const std::string &amp;opt) const</td></tr>
<tr class="separator:a6c4b622ade148a41fa08c1563e8eb1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5883fec19fd61dd06e47afc58ffe4be6"><td class="memTemplParams" colspan="2"><a id="a5883fec19fd61dd06e47afc58ffe4be6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5883fec19fd61dd06e47afc58ffe4be6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ArgOpt</b> (const std::string &amp;opt, const T &amp;val) const</td></tr>
<tr class="separator:a5883fec19fd61dd06e47afc58ffe4be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4601748c93ea7d09cc3f124a2bbdacde"><td class="memTemplParams" colspan="2"><a id="a4601748c93ea7d09cc3f124a2bbdacde"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4601748c93ea7d09cc3f124a2bbdacde"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ArgList</b> (const std::string &amp;opt) const</td></tr>
<tr class="separator:a4601748c93ea7d09cc3f124a2bbdacde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276cc2f00d9ec67e05f3727fa242154c"><td class="memTemplParams" colspan="2"><a id="a276cc2f00d9ec67e05f3727fa242154c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a276cc2f00d9ec67e05f3727fa242154c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ArgExt</b> (const std::string &amp;opt, const std::string &amp;exttag) const</td></tr>
<tr class="separator:a276cc2f00d9ec67e05f3727fa242154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acdbbf38059793c4babfc5c54f54f068c"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#acdbbf38059793c4babfc5c54f54f068c">MakeFile</a> (const std::string &amp;, const std::string &amp;) const</td></tr>
<tr class="memdesc:acdbbf38059793c4babfc5c54f54f068c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a path based of existing naming scheme in the class.  <a href="classusr_1_1ArgumentExtender.html#acdbbf38059793c4babfc5c54f54f068c">More...</a><br /></td></tr>
<tr class="separator:acdbbf38059793c4babfc5c54f54f068c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a4a2d1abc35f9c21d01bd64d0c19e0"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#ad3a4a2d1abc35f9c21d01bd64d0c19e0">MakePDFFile</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:ad3a4a2d1abc35f9c21d01bd64d0c19e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a path based of existing naming scheme in the class.  <a href="classusr_1_1ArgumentExtender.html#ad3a4a2d1abc35f9c21d01bd64d0c19e0">More...</a><br /></td></tr>
<tr class="separator:ad3a4a2d1abc35f9c21d01bd64d0c19e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71e1c6fe8f1cc2e5b210faca42f0083"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#aa71e1c6fe8f1cc2e5b210faca42f0083">MakePNGFile</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:aa71e1c6fe8f1cc2e5b210faca42f0083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a path based of existing naming scheme in the class.  <a href="classusr_1_1ArgumentExtender.html#aa71e1c6fe8f1cc2e5b210faca42f0083">More...</a><br /></td></tr>
<tr class="separator:aa71e1c6fe8f1cc2e5b210faca42f0083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc4dc1f8d368a8b7c9af11abf1e95f"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a42bc4dc1f8d368a8b7c9af11abf1e95f">MakeTXTFile</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:a42bc4dc1f8d368a8b7c9af11abf1e95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a path based of existing naming scheme in the class.  <a href="classusr_1_1ArgumentExtender.html#a42bc4dc1f8d368a8b7c9af11abf1e95f">More...</a><br /></td></tr>
<tr class="separator:a42bc4dc1f8d368a8b7c9af11abf1e95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b7f6cd63e25c3a2153750da6bdb8d1"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a15b7f6cd63e25c3a2153750da6bdb8d1">MakeTEXFile</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:a15b7f6cd63e25c3a2153750da6bdb8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a path based of existing naming scheme in the class.  <a href="classusr_1_1ArgumentExtender.html#a15b7f6cd63e25c3a2153750da6bdb8d1">More...</a><br /></td></tr>
<tr class="separator:a15b7f6cd63e25c3a2153750da6bdb8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a48c9675821874b66e798da233d338b2f"><td class="memItemLeft" align="right" valign="top"><a id="a48c9675821874b66e798da233d338b2f"></a>
pt::ptree &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a48c9675821874b66e798da233d338b2f">Tree</a> ()</td></tr>
<tr class="memdesc:a48c9675821874b66e798da233d338b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to internal property tree instance. <br /></td></tr>
<tr class="separator:a48c9675821874b66e798da233d338b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f9fa978d706a1f75859a0813c0787e"><td class="memItemLeft" align="right" valign="top"><a id="a65f9fa978d706a1f75859a0813c0787e"></a>
po::options_description &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a65f9fa978d706a1f75859a0813c0787e">Description</a> ()</td></tr>
<tr class="memdesc:a65f9fa978d706a1f75859a0813c0787e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to internal options description instance. <br /></td></tr>
<tr class="separator:a65f9fa978d706a1f75859a0813c0787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3e655f39835aa721d329d5196e7a45"><td class="memItemLeft" align="right" valign="top"><a id="aba3e655f39835aa721d329d5196e7a45"></a>
po::variables_map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#aba3e655f39835aa721d329d5196e7a45">Args</a> ()</td></tr>
<tr class="memdesc:aba3e655f39835aa721d329d5196e7a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to internal argument value map instance. <br /></td></tr>
<tr class="separator:aba3e655f39835aa721d329d5196e7a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abed801178b0bae69c5988f4d8586de96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#abed801178b0bae69c5988f4d8586de96">_init</a> (const std::vector&lt; std::string &gt; &amp;filelist)</td></tr>
<tr class="memdesc:abed801178b0bae69c5988f4d8586de96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of the class property tree with a list of files.  <a href="classusr_1_1ArgumentExtender.html#abed801178b0bae69c5988f4d8586de96">More...</a><br /></td></tr>
<tr class="separator:abed801178b0bae69c5988f4d8586de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd1d65fda0fd6c5186214847955d3ed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed">genPathString</a> (const <a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html">ArgPathScheme</a> &amp;) const</td></tr>
<tr class="memdesc:a0cd1d65fda0fd6c5186214847955d3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating the string for a single option input.  <a href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed">More...</a><br /></td></tr>
<tr class="separator:a0cd1d65fda0fd6c5186214847955d3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3e916eac6faee16b0ca9b90a60c8f5fa"><td class="memItemLeft" align="right" valign="top"><a id="a3e916eac6faee16b0ca9b90a60c8f5fa"></a>
pt::ptree&#160;</td><td class="memItemRight" valign="bottom"><b>_exttree</b></td></tr>
<tr class="separator:a3e916eac6faee16b0ca9b90a60c8f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83901dc30a3186094d63345d4c3d1925"><td class="memItemLeft" align="right" valign="top"><a id="a83901dc30a3186094d63345d4c3d1925"></a>
po::options_description&#160;</td><td class="memItemRight" valign="bottom"><b>_optdesc</b></td></tr>
<tr class="separator:a83901dc30a3186094d63345d4c3d1925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f42af312be30602b68cca17388be445"><td class="memItemLeft" align="right" valign="top"><a id="a5f42af312be30602b68cca17388be445"></a>
po::variables_map&#160;</td><td class="memItemRight" valign="bottom"><b>_argmap</b></td></tr>
<tr class="separator:a5f42af312be30602b68cca17388be445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf745d0de04bcad7a5a49a2d4d0e8b4"><td class="memItemLeft" align="right" valign="top"><a id="aedf745d0de04bcad7a5a49a2d4d0e8b4"></a>
fs::path&#160;</td><td class="memItemRight" valign="bottom"><b>_prefix</b></td></tr>
<tr class="separator:aedf745d0de04bcad7a5a49a2d4d0e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a16f89c0c1c7781f7439a9f0d1aac8d"><td class="memItemLeft" align="right" valign="top"><a id="a3a16f89c0c1c7781f7439a9f0d1aac8d"></a>
PathScheme&#160;</td><td class="memItemRight" valign="bottom"><b>_dirscheme</b></td></tr>
<tr class="separator:a3a16f89c0c1c7781f7439a9f0d1aac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea5bac92076f30fc9c5da34d6fb0e78"><td class="memItemLeft" align="right" valign="top"><a id="a6ea5bac92076f30fc9c5da34d6fb0e78"></a>
PathScheme&#160;</td><td class="memItemRight" valign="bottom"><b>_namescheme</b></td></tr>
<tr class="separator:a6ea5bac92076f30fc9c5da34d6fb0e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aacf5ddd349e5be7655fe55cb29d634b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf5ddd349e5be7655fe55cb29d634b5">&#9670;&nbsp;</a></span>ArgumentExtender() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usr::ArgumentExtender::ArgumentExtender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief Initialization without additional json file </p>

</div>
</div>
<a id="a3b63701254aa23f0dc315b424977204b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63701254aa23f0dc315b424977204b">&#9670;&nbsp;</a></span>ArgumentExtender() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usr::ArgumentExtender::ArgumentExtender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>see <a class="el" href="classusr_1_1ArgumentExtender.html#abed801178b0bae69c5988f4d8586de96" title="Construction of the class property tree with a list of files.">ArgumentExtender::_init()</a> for more details. </p>

</div>
</div>
<a id="a82abbcf67db5c70058816ad554eb127e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82abbcf67db5c70058816ad554eb127e">&#9670;&nbsp;</a></span>ArgumentExtender() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usr::ArgumentExtender::ArgumentExtender </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>see, <a class="el" href="classusr_1_1ArgumentExtender.html#abed801178b0bae69c5988f4d8586de96" title="Construction of the class property tree with a list of files.">ArgumentExtender::_init()</a> for more details. </p>

</div>
</div>
<a id="a4f74c30c18bde81dcdfe96baed9ded63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f74c30c18bde81dcdfe96baed9ded63">&#9670;&nbsp;</a></span>ArgumentExtender() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">usr::ArgumentExtender::ArgumentExtender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TS ...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>see <a class="el" href="classusr_1_1ArgumentExtender.html#abed801178b0bae69c5988f4d8586de96" title="Construction of the class property tree with a list of files.">ArgumentExtender::_init()</a> for more details. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abed801178b0bae69c5988f4d8586de96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed801178b0bae69c5988f4d8586de96">&#9670;&nbsp;</a></span>_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::_init </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filelist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor will ensure that the json structure for each entry under a given options is uniformed in the json file. Notice that the options listed in the json file will be considered a required arguments (hence the support for multiple json files).</p>
<p>An exception would be thrown if any parsing error occurs. Multiple options with the same name would also be considered an exception.</p>
<p>After successfully parsing the json file. The option <code>help/h</code> would be added to for use (if used, the class will diplay the defined options and exit). </p>

</div>
</div>
<a id="a01b49bea2f25e31e381baa20d311ce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b49bea2f25e31e381baa20d311ce37">&#9670;&nbsp;</a></span>AddDirScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::AddDirScheme </td>
          <td>(</td>
          <td class="paramtype">const PathScheme &amp;&#160;</td>
          <td class="paramname"><em>newscheme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is extend the existing list instead of straight up replacing it. </p>

</div>
</div>
<a id="afd68ab83d9ecae7a490540c41e9af7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd68ab83d9ecae7a490540c41e9af7a5">&#9670;&nbsp;</a></span>AddNameScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::AddNameScheme </td>
          <td>(</td>
          <td class="paramtype">const PathScheme &amp;&#160;</td>
          <td class="paramname"><em>newscheme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is extend the existing list instead of straight up replacing it. </p>

</div>
</div>
<a id="aa3527a9bf8ec6156a76ddfafe3deb86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3527a9bf8ec6156a76ddfafe3deb86f">&#9670;&nbsp;</a></span>AddOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1ArgumentExtender.html">ArgumentExtender</a> &amp; usr::ArgumentExtender::AddOptions </td>
          <td>(</td>
          <td class="paramtype">const po::options_description &amp;&#160;</td>
          <td class="paramname"><em>optdesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Currently the only way of adding more options is to manually define a new options_description instance, and adding that to the class. The internal options_description instance would only directly contain the options definition of "help/h". </p>

</div>
</div>
<a id="a590da0152e8a69fd06fe8f4fe84bb38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590da0152e8a69fd06fe8f4fe84bb38e">&#9670;&nbsp;</a></span>Arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE  = std::string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE usr::ArgumentExtender::Arg </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the user is responsible for casting the input to an appropriate type. </p>

</div>
</div>
<a id="a58b78660bc41f3ae2b25ea019367acb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b78660bc41f3ae2b25ea019367acb8">&#9670;&nbsp;</a></span>ArgExt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE usr::ArgumentExtender::ArgExt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exttag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user is responsible for providing the correct string tag, and providing the correct type to case the data in the json file. </p>

</div>
</div>
<a id="a84b85c615af9f0683a4bc509a0e6dcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b85c615af9f0683a4bc509a0e6dcf8">&#9670;&nbsp;</a></span>ArgList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;TYPE&gt; usr::ArgumentExtender::ArgList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notice that this must be used together with a boost::program_options' multitoken when defining the options description. Again the user is responsible for providing the appropriate casting. </p>

</div>
</div>
<a id="a41f0ce2b2748ff69042bc40195ee2c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0ce2b2748ff69042bc40195ee2c2e">&#9670;&nbsp;</a></span>ArgOpt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE  = std::string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE usr::ArgumentExtender::ArgOpt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user is responsible for casting the input to an appropriate type. </p>

</div>
</div>
<a id="a0f9cb52dabdf584c55701d15c12bc074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9cb52dabdf584c55701d15c12bc074">&#9670;&nbsp;</a></span>CheckArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::ArgumentExtender::CheckArg </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should be called after the <a class="el" href="classusr_1_1ArgumentExtender.html#a9e638edf8475fdfe95aef82d3ee74dcd" title="parsing the program input with the standard argc, argv interface.">ParseOptions()</a> method has been called. </p>

</div>
</div>
<a id="a0cd1d65fda0fd6c5186214847955d3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd1d65fda0fd6c5186214847955d3ed">&#9670;&nbsp;</a></span>genPathString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string usr::ArgumentExtender::genPathString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structusr_1_1ArgumentExtender_1_1ArgPathScheme.html">ArgPathScheme</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the given scheme of { option, prefixstring }, the function will return the string. prefixstring + option_input_as_string. Some substitutions will be name to make the output more friendly to command lines:</p>
<ol type="1">
<li>Decimal points will be replaced with 'p'</li>
<li>Spaces (for list multitoken arguments) will be replaced with '-'</li>
<li>If the option doesn't have a input (a.k.a. The option is just a boolean flag), the the option_input_as_string is simply "". </li>
</ol>

</div>
</div>
<a id="acdbbf38059793c4babfc5c54f54f068c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbbf38059793c4babfc5c54f54f068c">&#9670;&nbsp;</a></span>MakeFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fs::path usr::ArgumentExtender::MakeFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nameprefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The directory scheme is to use different inputs to generated nested directory names, while the name scheme will generate the resulting base name of the file. The character separating the option inputs values will simply be '_'.</p>
<p>For details on the generation of individual options string, see the private method <code><a class="el" href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed" title="Generating the string for a single option input.">genPathString()</a></code>. </p>

</div>
</div>
<a id="ad3a4a2d1abc35f9c21d01bd64d0c19e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a4a2d1abc35f9c21d01bd64d0c19e0">&#9670;&nbsp;</a></span>MakePDFFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fs::path usr::ArgumentExtender::MakePDFFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The directory scheme is to use different inputs to generated nested directory names, while the name scheme will generate the resulting base name of the file. The character separating the option inputs values will simply be '_'.</p>
<p>For details on the generation of individual options string, see the private method <code><a class="el" href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed" title="Generating the string for a single option input.">genPathString()</a></code>. </p>

</div>
</div>
<a id="aa71e1c6fe8f1cc2e5b210faca42f0083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71e1c6fe8f1cc2e5b210faca42f0083">&#9670;&nbsp;</a></span>MakePNGFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fs::path usr::ArgumentExtender::MakePNGFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The directory scheme is to use different inputs to generated nested directory names, while the name scheme will generate the resulting base name of the file. The character separating the option inputs values will simply be '_'.</p>
<p>For details on the generation of individual options string, see the private method <code><a class="el" href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed" title="Generating the string for a single option input.">genPathString()</a></code>. </p>

</div>
</div>
<a id="a15b7f6cd63e25c3a2153750da6bdb8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b7f6cd63e25c3a2153750da6bdb8d1">&#9670;&nbsp;</a></span>MakeTEXFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fs::path usr::ArgumentExtender::MakeTEXFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The directory scheme is to use different inputs to generated nested directory names, while the name scheme will generate the resulting base name of the file. The character separating the option inputs values will simply be '_'.</p>
<p>For details on the generation of individual options string, see the private method <code><a class="el" href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed" title="Generating the string for a single option input.">genPathString()</a></code>. </p>

</div>
</div>
<a id="a42bc4dc1f8d368a8b7c9af11abf1e95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc4dc1f8d368a8b7c9af11abf1e95f">&#9670;&nbsp;</a></span>MakeTXTFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fs::path usr::ArgumentExtender::MakeTXTFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The directory scheme is to use different inputs to generated nested directory names, while the name scheme will generate the resulting base name of the file. The character separating the option inputs values will simply be '_'.</p>
<p>For details on the generation of individual options string, see the private method <code><a class="el" href="classusr_1_1ArgumentExtender.html#a0cd1d65fda0fd6c5186214847955d3ed" title="Generating the string for a single option input.">genPathString()</a></code>. </p>

</div>
</div>
<a id="a9e638edf8475fdfe95aef82d3ee74dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e638edf8475fdfe95aef82d3ee74dcd">&#9670;&nbsp;</a></span>ParseOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::ParseOptions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Raising exception if there is any error in parsing. Additional criteria that counts as an error in parsing includes:</p><ol type="1">
<li>The json file contains an options not listed in the final options_description instance.</li>
<li>A option listed in the json does not have a corresponding user input.</li>
<li>The user input for an option listed in the json file doesn't match any of inputs listed in the json file.</li>
</ol>
<p>After all parsing is complete, the function will check for the "help/h" input. If it exists, the function will print the options_description and terminate the program. </p>

</div>
</div>
<a id="a2805d452c24d2244a48b363df9343385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2805d452c24d2244a48b363df9343385">&#9670;&nbsp;</a></span>SetDirScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::SetDirScheme </td>
          <td>(</td>
          <td class="paramtype">const PathScheme &amp;&#160;</td>
          <td class="paramname"><em>newscheme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will <b>remove</b> any existing scheme for the directory naming. </p>

</div>
</div>
<a id="ac5dd65c5fdc1a0ad1f3dab05868a6cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5dd65c5fdc1a0ad1f3dab05868a6cb9">&#9670;&nbsp;</a></span>SetFilePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::SetFilePrefix </td>
          <td>(</td>
          <td class="paramtype">const fs::path&#160;</td>
          <td class="paramname"><em>pre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the directory path that will be used regardless of any input status. </p>

</div>
</div>
<a id="a170980c490d45422faea52412728dfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170980c490d45422faea52412728dfc5">&#9670;&nbsp;</a></span>SetNameScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::ArgumentExtender::SetNameScheme </td>
          <td>(</td>
          <td class="paramtype">const PathScheme &amp;&#160;</td>
          <td class="paramname"><em>newscheme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will <b>remove</b> any existing scheme for the directory naming. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/ensc/Homework/CMSSW/UserUtils/Common/interface/<a class="el" href="ArgumentExtender_8hpp_source.html">ArgumentExtender.hpp</a></li>
<li>/home/ensc/Homework/CMSSW/UserUtils/Common/src/<a class="el" href="ArgumentExtender_8cc.html">ArgumentExtender.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassusr_1_1ArgumentExtender_html"><div class="ttname"><a href="classusr_1_1ArgumentExtender.html">usr::ArgumentExtender</a></div><div class="ttdef"><b>Definition:</b> ArgumentExtender.hpp:28</div></div>
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.16
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
