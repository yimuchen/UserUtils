/**
 * @file    Maths.cc
 * @brief   Simple concrete type math functions
 * @author  [Yi-Mu "Enoch" Chen](https://github.com/yimuchen)
 */
#include <cmath>
#include <cstdint>

namespace usr {

/**
 * @brief Reducing the double x to it's mantissa component in it's scientific
 *        notation, returns the exponent.
 */
int ReduceToMant( double& x )
{
  int ans = 0;
  if( x == 0 ){ return 0; }

  while( fabs( x ) > 10 ){
    ans++;
    x /= 10;
  }

  while( fabs( x ) < 0.1 ){
    ans--;
    x *= 10;
  }

  return ans;
}

/**
 * @brief returning the exponent for the scientific notation of a double x
 */
int
GetExponent( double x )
{
  return ReduceToMant(x);
}

/**
 * @brief faster implementation of the power function with integers
 *
 * This actually has minimal uses in analysis, I just thought it was a nice
 * excercise for writting a [square-and-multiply algorithm](https://en.wikipedia.org/wiki/Exponentiation_by_squaring) :/
 */
double
IntPower( double base, int exp )
{
  if( exp < 0 ){ return IntPower( 1./base, -exp ); }
  double ans = 1;

  for( int x = 1; x; x <<= 1, base *= base ){
    if( x & exp ){ ans *= base; }
  }

  return ans;
}

/**
 * @brief Rounding up to the closest power of 2
 *
 * Using a nice algorithm by bit mashing.
 * https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
 */
unsigned RoundUpToP2( unsigned x )
{
  x--;
  x |= x >> 1;
  x |= x >> 2;
  x |= x >> 4;
  x |= x >> 8;
  x |= x >> 16;
  x++;
  return x;
}

/**
 * @brief A pseudo random number generated by a double.
 *
 * This is useful when attempting to hash parameter space to avoid excessive
 * re-calculation, or to generate random values based on the independent
 * variables to allow for unique smearing. We are basing the algorithm on the
 * [xorshift algorithm](https://en.wikipedia.org/wiki/Xorshift) for
 * randomization.
 */
uint64_t HashValue( const double in )
{
  union bitconvert
  {
    uint64_t bits;
    double   in;
  };

  bitconvert bitconv ;
  bitconv.in = in;
  uint64_t x = bitconv.bits;
  x ^= x >> 12; // a
  x ^= x << 25; // b
  x ^= x >> 27; // c
  return x * 0x2545F4914F6CDD1D;
}

} /* usr */
