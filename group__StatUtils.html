<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: StatUtils</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">StatUtils<div class="ingroups"><a class="el" href="group__MathUtils.html">MathUtils</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >One of the main routines of this these functions is the calculations of the uncertainties of estimations/measurements of physics parameters in the experiment. This is performed by some negative log-likelihood(NLL) function which takes the physical parameters( \(x_i\)) and the observed data ( \(d_i\)) as the input, and determine how variation in \(x_i\) changes the output of the NLL to decide on an estimation on the value of the physical parameter, which we are going to notate as: \(\hat{x_i}^{+\sigma_+}_{-\sigma_{-}}\). Even though ROOT uses GSL under the hood, we are going to use the ROOT::Math function for calculation, which allows user to provide functions to the calculations using classes and functions instead of just using function pointers.</p>
<h1>Mathematics</h1>
<p >While there are multiple interpretation as to how to obtain \(\hat{x}\) and co from a given negative log-likelihood (<a href="https://en.wikipedia.org/wiki/Frequentist_inference">frequentists inference</a> and <a href="https://en.wikipedia.org/wiki/Bayesian_inference">Bayesian inference</a>), the library opts to go for the Minos uncertainty, where the NLL function is minimized at \(\mathrm(NLL)(\hat{x})\), and is shifted by a certain amount by the parameter uncertainty:</p>
<p class="formulaDsp">
\[ \mathrm{NLL}(\hat{x}\pm\sigma_{\pm})-\mathrm{NLL}(x) = \frac{1}{2}C^2, \]
</p>
<p >where \(C\) is the “sigma interval” that the uncertainty is trying to represent. In the case that there are multiple parameters are taken into consideration in a common NLL function \(\mathrm{NLL}(x_i)\), the effective NLL to be used for a single parameter \(\mathrm{NLL}_\mathrm{eff}(x_0)\) to be used is would be the “profile NLL” function, where all other parameters are allowed to change value such that to minimize the total NLL function \(\mathrm{NLL}\) for a given value of \(x_0\). This scheme also extends to extended measurements of \(u=f(x_i)\), where we might be interested in the sum, product, or more complicated parameter which could be calculated based on the parameters directly obtained in an experiment. In this case, for a given value of \(u\), we would be find the effective NLL function for our extended parameter \(u\), notated as \( \mathrm{NLL}_\mathrm{eff}(u) \), by maximizing the original NLL function under the constraint of \(u = f(x_i)\). In this library, we would be carrying out such calculation using the Lagrange multiplier method.</p>
<h1>Container</h1>
<p >A container for a measurement results containing a central value, upper and lower uncertainties is implemented with the <a class="el" href="classusr_1_1Measurement.html" title="Class for containing a measurement with asymmetric uncertainties as well as performing basic arithmet...">Measurement</a> class. Aside for acting as a simple number container, it also allows for the performance of numerical operations of measurement results with a quick-and-dirty version of combined MINOS uncertainty evaluation with an estimated likelihood function (see the <a class="el" href="group__StatUtils.html#gab032f76ddbdaeb1673ba7b506ffc7dc4">LinearVarianceNLL()</a> method).</p>
<h1>Output</h1>
<p >This library also provides classes that precedes the <code>usr::base::format</code> classes to allow for latex printing of the measurement container classes in the form of:</p>
<p class="formulaDsp">
\[ \hat{x}^{+\sigma_+}_{-\sigma_-} \;;\quad \hat{x}^{+\sigma_+}_{-\sigma_-}\times 10^{E \neq 0 } \;;\quad \]
</p>
<p >In the event that the string representation of \(\sigma_+\) and \(\sigma_-\) are identical with the requested precision (<b>NOT</b> necessarily when the doubles that of identical value!), the symmetric notation of</p>
<p class="formulaDsp">
\[ \hat{x}\pm\sigma \;;\quad \left( \hat{x}\pm\sigma\right)\times 10^{E \neq 0} \]
</p>
<p> would be used.</p>
<p >The precision used for the class construction represents the number of digits to display for behind the decimal point for the central value. The precision used for generating the strings representing the uncertainties would be of equal value. For more details, see the implemented classes <code><a class="el" href="classusr_1_1fmt_1_1decimal.html" title="decimal representation of a measurement with uncertainties.">usr::fmt::decimal</a></code> and <code><a class="el" href="classusr_1_1fmt_1_1scientific.html" title="Scientific representation of a measurement with uncertainties.">usr::fmt::scientific</a></code> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1fmt_1_1decimal.html">usr::fmt::decimal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">decimal representation of a measurement with uncertainties.  <a href="classusr_1_1fmt_1_1decimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1fmt_1_1scientific.html">usr::fmt::scientific</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scientific representation of a measurement with uncertainties.  <a href="classusr_1_1fmt_1_1scientific.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1Measurement.html">usr::Measurement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for containing a measurement with asymmetric uncertainties as well as performing basic arithmetics with quick-and-dirty uncertainty propagation.  <a href="classusr_1_1Measurement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1stat_1_1GaussianNLL.html">usr::stat::GaussianNLL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1stat_1_1PoissonNLL.html">usr::stat::PoissonNLL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1stat_1_1BinomialNLL.html">usr::stat::BinomialNLL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga273a88f6f752d5a1d01d5285315376b9"><td class="memItemLeft" align="right" valign="top"><a id="ga273a88f6f752d5a1d01d5285315376b9" name="ga273a88f6f752d5a1d01d5285315376b9"></a>
<a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usr::MakeMinos</b> (const ROOT::Math::IGenFunction &amp;nll, const double min, const double max, const double confidencelevel)</td></tr>
<tr class="memdesc:ga273a88f6f752d5a1d01d5285315376b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface to the Single variable version of the <a class="el" href="group__StatUtils.html#gae480beb1f6d3d7513470dd719db8a990" title="Generic routine for calculating minos uncertainties for 1D functions.">MinosError()</a> function. <br /></td></tr>
<tr class="separator:ga273a88f6f752d5a1d01d5285315376b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae780086a5969ac9a725fb58e9befe3"><td class="memItemLeft" align="right" valign="top"><a id="ga8ae780086a5969ac9a725fb58e9befe3" name="ga8ae780086a5969ac9a725fb58e9befe3"></a>
<a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usr::MakeMinos</b> (const ROOT::Math::IMultiGenFunction &amp;nllfunction, const ROOT::Math::IMultiGenFunction &amp;varfunction, const double *initguess, const double confidencelevel, const double *upperguess, const double *lowerguess)</td></tr>
<tr class="memdesc:ga8ae780086a5969ac9a725fb58e9befe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface to the \(R^{n}\rightarrow R\) version of the <a class="el" href="group__StatUtils.html#gae480beb1f6d3d7513470dd719db8a990" title="Generic routine for calculating minos uncertainties for 1D functions.">MinosError()</a> function <br /></td></tr>
<tr class="separator:ga8ae780086a5969ac9a725fb58e9befe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab032f76ddbdaeb1673ba7b506ffc7dc4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#gab032f76ddbdaeb1673ba7b506ffc7dc4">usr::LinearVarianceNLL</a> (const double x, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;m)</td></tr>
<tr class="memdesc:gab032f76ddbdaeb1673ba7b506ffc7dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate negative log-likelihood function for a measurements of \(x^{+\sigma_+}_{-\sigma_i}\).  <a href="group__StatUtils.html#gab032f76ddbdaeb1673ba7b506ffc7dc4">More...</a><br /></td></tr>
<tr class="separator:gab032f76ddbdaeb1673ba7b506ffc7dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8a3c63a031c39e8a5be34717a69d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga6d8a3c63a031c39e8a5be34717a69d8f">usr::EvaluateUncorrelated</a> (const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;m_list, const ROOT::Math::IMultiGenFunction &amp;varfunction, const double confidencelevel, double(*nll)(double, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;))</td></tr>
<tr class="memdesc:ga6d8a3c63a031c39e8a5be34717a69d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a list of measurements with uncertainties, return the effective sum of all measurements as if all measurements are uncorrelated.  <a href="group__StatUtils.html#ga6d8a3c63a031c39e8a5be34717a69d8f">More...</a><br /></td></tr>
<tr class="separator:ga6d8a3c63a031c39e8a5be34717a69d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5fe33db693d842779d0bd22932b182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#gaaf5fe33db693d842779d0bd22932b182">usr::SumUncorrelated</a> (const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;paramlist, const double confidencelevel=usr::stat::onesigma_level, double(*nll)(double, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;)=&amp;LinearVarianceNLL)</td></tr>
<tr class="memdesc:gaaf5fe33db693d842779d0bd22932b182"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a list of measurements with uncertainties, return the effective sum of all measurements as if all measurements are uncorrelated.  <a href="group__StatUtils.html#gaaf5fe33db693d842779d0bd22932b182">More...</a><br /></td></tr>
<tr class="separator:gaaf5fe33db693d842779d0bd22932b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4fecf3dfabaf89db91d552ef8080a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#gabe4fecf3dfabaf89db91d552ef8080a3">usr::ProdUncorrelated</a> (const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;m_list, const double confidencelevel, double(*nll)(double, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;))</td></tr>
<tr class="memdesc:gabe4fecf3dfabaf89db91d552ef8080a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a list of measurements with uncertainties, return the effective sum of all measurements as if all measurements are uncorrelated.  <a href="group__StatUtils.html#gabe4fecf3dfabaf89db91d552ef8080a3">More...</a><br /></td></tr>
<tr class="separator:gabe4fecf3dfabaf89db91d552ef8080a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a44b7ce97588e80fb1ff7927d74fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga88a44b7ce97588e80fb1ff7927d74fd8">usr::LazyEvaluateUncorrelated</a> (const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;paramlist, const ROOT::Math::IMultiGenFunction &amp;varfunction)</td></tr>
<tr class="memdesc:ga88a44b7ce97588e80fb1ff7927d74fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a function of parameters, calculate the error propagation given a various a list of symmetric error functions using a lazy method. Assuming all parameters are uncorrelated.  <a href="group__StatUtils.html#ga88a44b7ce97588e80fb1ff7927d74fd8">More...</a><br /></td></tr>
<tr class="separator:ga88a44b7ce97588e80fb1ff7927d74fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07008df582f8eb02d23bf5f4650532d6"><td class="memTemplParams" colspan="2">template&lt;typename ... Ts&gt; </td></tr>
<tr class="memitem:ga07008df582f8eb02d23bf5f4650532d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga07008df582f8eb02d23bf5f4650532d6">usr::Sum</a> (const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;x, Ts ... args)</td></tr>
<tr class="memdesc:ga07008df582f8eb02d23bf5f4650532d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">variadic interface to allow for the indefinite input Sum(x,y,z,....)  <a href="group__StatUtils.html#ga07008df582f8eb02d23bf5f4650532d6">More...</a><br /></td></tr>
<tr class="separator:ga07008df582f8eb02d23bf5f4650532d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c843af28e9a55fb355aec972413a14f"><td class="memTemplParams" colspan="2">template&lt;typename ... Ts&gt; </td></tr>
<tr class="memitem:ga2c843af28e9a55fb355aec972413a14f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga2c843af28e9a55fb355aec972413a14f">usr::Prod</a> (const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;x, Ts ... args)</td></tr>
<tr class="memdesc:ga2c843af28e9a55fb355aec972413a14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">variadic interface to allow for the indefinte input Prod(x,y,z,....)  <a href="group__StatUtils.html#ga2c843af28e9a55fb355aec972413a14f">More...</a><br /></td></tr>
<tr class="separator:ga2c843af28e9a55fb355aec972413a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6037ac91f9206bae9d43cec076be8df7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga6037ac91f9206bae9d43cec076be8df7">usr::stat::NormalCDF</a> (const double x)</td></tr>
<tr class="memdesc:ga6037ac91f9206bae9d43cec076be8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDF of the normal distribution.  <a href="group__StatUtils.html#ga6037ac91f9206bae9d43cec076be8df7">More...</a><br /></td></tr>
<tr class="separator:ga6037ac91f9206bae9d43cec076be8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22b928f688fabc13df5abe776b3312c"><td class="memItemLeft" align="right" valign="top"><a id="gaf22b928f688fabc13df5abe776b3312c" name="gaf22b928f688fabc13df5abe776b3312c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>usr::stat::GetConfidenceLevel</b> (const double sigmainterval)</td></tr>
<tr class="memdesc:gaf22b928f688fabc13df5abe776b3312c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translating the informal but common phrase of "x sigmas" into actual confidence levels. <br /></td></tr>
<tr class="separator:gaf22b928f688fabc13df5abe776b3312c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac354b65cd95d87e43c3711b1a68a4499"><td class="memItemLeft" align="right" valign="top"><a id="gac354b65cd95d87e43c3711b1a68a4499" name="gac354b65cd95d87e43c3711b1a68a4499"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>usr::stat::GetSigmaInterval</b> (const double confidencelevel)</td></tr>
<tr class="memdesc:gac354b65cd95d87e43c3711b1a68a4499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translatign the more formal term of "a confidence level of x", into a more immediately understandable "x sigma interval". <br /></td></tr>
<tr class="separator:gac354b65cd95d87e43c3711b1a68a4499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f1daf3d00cef5afed8eeb994b214aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga74f1daf3d00cef5afed8eeb994b214aa">usr::stat::DeltaNLLFromSigma</a> (const double sigma)</td></tr>
<tr class="memdesc:ga74f1daf3d00cef5afed8eeb994b214aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">getting the difference in NLL required for a given sigma interval.  <a href="group__StatUtils.html#ga74f1daf3d00cef5afed8eeb994b214aa">More...</a><br /></td></tr>
<tr class="separator:ga74f1daf3d00cef5afed8eeb994b214aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984e106d29b0aae17f0937e80f025af3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga984e106d29b0aae17f0937e80f025af3">usr::stat::DeltaNLLFromConfidence</a> (const double confidence)</td></tr>
<tr class="memdesc:ga984e106d29b0aae17f0937e80f025af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">getting the difference in NLL required for a certain confidence level.  <a href="group__StatUtils.html#ga984e106d29b0aae17f0937e80f025af3">More...</a><br /></td></tr>
<tr class="separator:ga984e106d29b0aae17f0937e80f025af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae480beb1f6d3d7513470dd719db8a990"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#gae480beb1f6d3d7513470dd719db8a990">usr::stat::MinosError</a> (const ROOT::Math::IGenFunction &amp;nllfunction, double &amp;guess, double &amp;min, double &amp;max, const double confidencelevel)</td></tr>
<tr class="memdesc:gae480beb1f6d3d7513470dd719db8a990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic routine for calculating minos uncertainties for 1D functions.  <a href="group__StatUtils.html#gae480beb1f6d3d7513470dd719db8a990">More...</a><br /></td></tr>
<tr class="separator:gae480beb1f6d3d7513470dd719db8a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70697c3c1f6e01356214f2ef9b7c56c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga70697c3c1f6e01356214f2ef9b7c56c2">usr::stat::MinosError</a> (const ROOT::Math::IMultiGenFunction &amp;nllfunction, const ROOT::Math::IMultiGenFunction &amp;varfunction, const double *initguess, double &amp;central, double &amp;min, double &amp;max, const double confidencelevel, const double *upperguess, const double *lowerguess)</td></tr>
<tr class="memdesc:ga70697c3c1f6e01356214f2ef9b7c56c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic routine for calculating the minos uncertainty of a N parameter system.  <a href="group__StatUtils.html#ga70697c3c1f6e01356214f2ef9b7c56c2">More...</a><br /></td></tr>
<tr class="separator:ga70697c3c1f6e01356214f2ef9b7c56c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4297f6d91c493da8f49e2d45cd7d90ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga4297f6d91c493da8f49e2d45cd7d90ad">usr::Efficiency::Minos</a> (const double passed, const double total, const double confidencelevel)</td></tr>
<tr class="memdesc:ga4297f6d91c493da8f49e2d45cd7d90ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">simpler interface for creating Efficiency (binomial) measurements with minos uncertainties.  <a href="group__StatUtils.html#ga4297f6d91c493da8f49e2d45cd7d90ad">More...</a><br /></td></tr>
<tr class="separator:ga4297f6d91c493da8f49e2d45cd7d90ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eea06674df4a866a0d7786755d7ed85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga3eea06674df4a866a0d7786755d7ed85">usr::Efficiency::Bayesian</a> (double passed, double total, double confidencelevel, bool confidencemethod, double alpha, double beta)</td></tr>
<tr class="memdesc:ga3eea06674df4a866a0d7786755d7ed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a efficiency (binomial) measurement with Bayesian uncertainties.  <a href="group__StatUtils.html#ga3eea06674df4a866a0d7786755d7ed85">More...</a><br /></td></tr>
<tr class="separator:ga3eea06674df4a866a0d7786755d7ed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b88d1268c99b1147f5241e718e4042e"><td class="memItemLeft" align="right" valign="top"><a id="ga5b88d1268c99b1147f5241e718e4042e" name="ga5b88d1268c99b1147f5241e718e4042e"></a>
<a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usr::Efficiency::ClopperPearson</b> (const double passed, const double total, const double confidencelevel)</td></tr>
<tr class="memdesc:ga5b88d1268c99b1147f5241e718e4042e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default method used for efficiency display used in TEfficiency to avoid under coverage. <br /></td></tr>
<tr class="separator:ga5b88d1268c99b1147f5241e718e4042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac060ae17a78f343777a1b42570fc4f76"><td class="memItemLeft" align="right" valign="top"><a id="gac060ae17a78f343777a1b42570fc4f76" name="gac060ae17a78f343777a1b42570fc4f76"></a>
<a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usr::Poisson::Minos</b> (const double obs, const double confidencelevel)</td></tr>
<tr class="memdesc:gac060ae17a78f343777a1b42570fc4f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple interface for creating poisson measurements with minos uncertainties. <br /></td></tr>
<tr class="separator:gac060ae17a78f343777a1b42570fc4f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffbd9f0f47f3a7487580643edd0f2bb7"><td class="memItemLeft" align="right" valign="top"><a id="gaffbd9f0f47f3a7487580643edd0f2bb7" name="gaffbd9f0f47f3a7487580643edd0f2bb7"></a>
<a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usr::Poisson::Lazy</b> (const double obs, const double confidencelevel)</td></tr>
<tr class="memdesc:gaffbd9f0f47f3a7487580643edd0f2bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy method for a Poisson measurement: just using the square root. <br /></td></tr>
<tr class="separator:gaffbd9f0f47f3a7487580643edd0f2bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc082c893de369de543cf157fa3532a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1Measurement.html">Measurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatUtils.html#ga1cc082c893de369de543cf157fa3532a">usr::Poisson::CMSStatCom</a> (const double obs, const double confidencelevel)</td></tr>
<tr class="memdesc:ga1cc082c893de369de543cf157fa3532a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least undercoverage Interval as recommended by CMS Statistics committee.  <a href="group__StatUtils.html#ga1cc082c893de369de543cf157fa3532a">More...</a><br /></td></tr>
<tr class="separator:ga1cc082c893de369de543cf157fa3532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga82045e6b68b4877b30d5b16e8f3a7e2b"><td class="memItemLeft" align="right" valign="top"><a id="ga82045e6b68b4877b30d5b16e8f3a7e2b" name="ga82045e6b68b4877b30d5b16e8f3a7e2b"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>usr::stat::onesigma_level</b> = GetConfidenceLevel( 1 )</td></tr>
<tr class="separator:ga82045e6b68b4877b30d5b16e8f3a7e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f010267b40fb26c3211820c0116c86"><td class="memItemLeft" align="right" valign="top"><a id="ga83f010267b40fb26c3211820c0116c86" name="ga83f010267b40fb26c3211820c0116c86"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>usr::stat::twosigma_level</b> = GetConfidenceLevel( 2 )</td></tr>
<tr class="separator:ga83f010267b40fb26c3211820c0116c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3eea06674df4a866a0d7786755d7ed85" name="ga3eea06674df4a866a0d7786755d7ed85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eea06674df4a866a0d7786755d7ed85">&#9670;&nbsp;</a></span>Bayesian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::Efficiency::Bayesian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>passed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confidencemethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Using TEfficiency methods, see those for detailed documentation. </p>

</div>
</div>
<a id="ga1cc082c893de369de543cf157fa3532a" name="ga1cc082c893de369de543cf157fa3532a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc082c893de369de543cf157fa3532a">&#9670;&nbsp;</a></span>CMSStatCom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::Poisson::CMSStatCom </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The Complete algorithm can be found here: <a href="https://twiki.cern.ch/twiki/bin/view/CMS/PoissonErrorBars">https://twiki.cern.ch/twiki/bin/view/CMS/PoissonErrorBars</a></p>
<p >We are using the recipe for the older root version. </p>

</div>
</div>
<a id="ga984e106d29b0aae17f0937e80f025af3" name="ga984e106d29b0aae17f0937e80f025af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984e106d29b0aae17f0937e80f025af3">&#9670;&nbsp;</a></span>DeltaNLLFromConfidence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::stat::DeltaNLLFromConfidence </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >First convert the confidence interval into a sigma interval, then returning the answer. </p>

</div>
</div>
<a id="ga74f1daf3d00cef5afed8eeb994b214aa" name="ga74f1daf3d00cef5afed8eeb994b214aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74f1daf3d00cef5afed8eeb994b214aa">&#9670;&nbsp;</a></span>DeltaNLLFromSigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::stat::DeltaNLLFromSigma </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Essentially calculating the difference in NLL from the normal distribution: for a sigma interval of \(x\), the return value would be \(x^{2}/2\) </p>

</div>
</div>
<a id="ga6d8a3c63a031c39e8a5be34717a69d8f" name="ga6d8a3c63a031c39e8a5be34717a69d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8a3c63a031c39e8a5be34717a69d8f">&#9670;&nbsp;</a></span>EvaluateUncorrelated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::EvaluateUncorrelated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ROOT::Math::IMultiGenFunction &amp;&#160;</td>
          <td class="paramname"><em>varfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;)&#160;</td>
          <td class="paramname"><em>nll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a list of parameters, a master negative log-likelihood function is generated assuming that all variables are uncorrelated and uses the same underlying negative log-likelihood function (specifed with the <code>nll</code> argument). The MinosErrors method for multidimensional Minos uncertainty calculations is then invoked for the calculation. This function also automatically estimates the initial guesses for the Minos error calculations using the partial differentials of the variable function. For details of this initial guess estimation see the usr::LazyEvaluateUncorrelated method. </p>

</div>
</div>
<a id="ga88a44b7ce97588e80fb1ff7927d74fd8" name="ga88a44b7ce97588e80fb1ff7927d74fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a44b7ce97588e80fb1ff7927d74fd8">&#9670;&nbsp;</a></span>LazyEvaluateUncorrelated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::LazyEvaluateUncorrelated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ROOT::Math::IMultiGenFunction &amp;&#160;</td>
          <td class="paramname"><em>varfunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For a function given as: </p><p class="formulaDsp">
\[ y = f(x_1 , x_2, x_3,\ldots ) \]
</p>
<p >With a set of measurements \(\hat{x}_i{}^{+\sigma^{+}_i}_{-\sigma^{-}_i}\), The resulting measurement \(\hat{y}^{+\sigma^{+}_y}_{-\sigma^{-}_y}\) is evaluted as:</p>
<p class="formulaDsp">
\[ \hat{y} = f(\hat{x}_1, \hat{x}_2, \hat{x}_3\ldots) \]
</p>
<p >and:</p>
<p class="formulaDsp">
\[ y\pm\sigma^{\pm}_{y} = f(\hat{x}_i + \Delta x_i) \]
</p>
<p >with</p>
<p class="formulaDsp">
\[ \Delta x_i = \frac{ |\partial_i f| }{\sqrt{\sum_i (\partial_i f)^2}} \sigma^{k_i}_{i} \]
</p>
<p >where \(k_i = +\) if \(\partial_i f\) is positive or else \(k_i = - \) otherwise. </p>

</div>
</div>
<a id="gab032f76ddbdaeb1673ba7b506ffc7dc4" name="gab032f76ddbdaeb1673ba7b506ffc7dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab032f76ddbdaeb1673ba7b506ffc7dc4">&#9670;&nbsp;</a></span>LinearVarianceNLL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::LinearVarianceNLL </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The approximation for an negative log-likelihood function is a variation of the one recommended in <a href="https://arxiv.org/abs/physics/0406120">R. Barlow's "Asymmetric statistical errors"</a>, In the form of:</p>
<p class="formulaDsp">
\[\mathrm{NLL}(x) = \frac{x^{2}}{ 2V(1+Ax)} \]
</p>
<p >with \(V\) being the average variance \(\frac{\sigma_+ + \sigma_-}{2}\), and \(A\) being the variance asymmetry \(\frac{\sigma_{+} - \sigma_{-}}{V}\).</p>
<p >A few adjustments are made to ensure the stability of the calculations.</p><ul>
<li>The ratio between the two uncertainties would have a hard limit of 10. The smaller uncertainty would be inflated if extreme asymmetries are present.</li>
<li>The average variance would have an minimum value of \(10^{-16}\) which should cover most cases where uncertainty calculations are required. Test have shown that the calculation would not be affected by such limits if the there are some dominate uncertainties.</li>
<li>To avoid the singularity at \(x=-1/A\), an exponential function would be used instead for the linear function for the denominator in the negative log-likelihood function when x is past half-way from the central value to the original singular point, such that the approximation would be extended to an infinite domain. The exponential function is designed such that the denominator and its derivative is continuous. </li>
</ul>

</div>
</div>
<a id="ga4297f6d91c493da8f49e2d45cd7d90ad" name="ga4297f6d91c493da8f49e2d45cd7d90ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4297f6d91c493da8f49e2d45cd7d90ad">&#9670;&nbsp;</a></span>Minos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::Efficiency::Minos </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>passed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calls the GSL functions for generating, known to fail for the extreme case of all pass and all fail. </p>

</div>
</div>
<a id="gae480beb1f6d3d7513470dd719db8a990" name="gae480beb1f6d3d7513470dd719db8a990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae480beb1f6d3d7513470dd719db8a990">&#9670;&nbsp;</a></span>MinosError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usr::stat::MinosError </td>
          <td>(</td>
          <td class="paramtype">const ROOT::Math::IGenFunction &amp;&#160;</td>
          <td class="paramname"><em>nllfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a 1D function acting as the negative log-likelihood function for some parameter, the MinosError will use the min/max brackets to return the central value (where the negative log-likelihood function was minimized) and the upper and lower uncertainty edges, a.k.a where the negative log-likelihood function deviates from the minimum value by some number K. The number K is determined by the working "confidence level" of the function. </p>

</div>
</div>
<a id="ga70697c3c1f6e01356214f2ef9b7c56c2" name="ga70697c3c1f6e01356214f2ef9b7c56c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70697c3c1f6e01356214f2ef9b7c56c2">&#9670;&nbsp;</a></span>MinosError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usr::stat::MinosError </td>
          <td>(</td>
          <td class="paramtype">const ROOT::Math::IMultiGenFunction &amp;&#160;</td>
          <td class="paramname"><em>nllfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ROOT::Math::IMultiGenFunction &amp;&#160;</td>
          <td class="paramname"><em>varfunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>initguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>central</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>upperguess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>lowerguess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given an N dimensional parameter system governed by a negative log-likelihood function <code>nllfunction</code>, the MinosError routine will attempt to calculate the minos uncertainty of the extended parameter defined by the <code>varfunction</code>.</p>
<p >The <code>initguess</code> is mandatory for initializing the parameter guessing, while the <code>central</code>, <code>min</code>, <code>max</code> parameters are no longer used for initializing or bracketing, just for storing the return result. The use can provide an initial guess for parameter inputs that will yield the higher or lower edges if needed, otherwise the guess is simply stepping the minimum value by a value of 0.01. </p>

</div>
</div>
<a id="ga6037ac91f9206bae9d43cec076be8df7" name="ga6037ac91f9206bae9d43cec076be8df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6037ac91f9206bae9d43cec076be8df7">&#9670;&nbsp;</a></span>NormalCDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::stat::NormalCDF </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Implemented in the ROOT Math library. </p>

</div>
</div>
<a id="ga2c843af28e9a55fb355aec972413a14f" name="ga2c843af28e9a55fb355aec972413a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c843af28e9a55fb355aec972413a14f">&#9670;&nbsp;</a></span>Prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::Prod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >It is worth noting that the output of (x*y*z) might not be the same as the output of Prod(x,y,z) (operator* is a two input call to Prod(a,b)). But for all intents and purposes, the errors in uncertainties could be ignore for the most part. </p>

</div>
</div>
<a id="gabe4fecf3dfabaf89db91d552ef8080a3" name="gabe4fecf3dfabaf89db91d552ef8080a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe4fecf3dfabaf89db91d552ef8080a3">&#9670;&nbsp;</a></span>ProdUncorrelated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::ProdUncorrelated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;)&#160;</td>
          <td class="paramname"><em>nll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function also allows the user to define the working confidence level for the calculations and also the approximate negative log-likelihood function used for the individual measurements (by default using the <a class="el" href="group__StatUtils.html#gab032f76ddbdaeb1673ba7b506ffc7dc4" title="Approximate negative log-likelihood function for a measurements of .">LinearVarianceNLL()</a> function). </p>

</div>
</div>
<a id="ga07008df582f8eb02d23bf5f4650532d6" name="ga07008df582f8eb02d23bf5f4650532d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07008df582f8eb02d23bf5f4650532d6">&#9670;&nbsp;</a></span>Sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::Sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >It is worth noting that the output of (x+y+z) might not be the same as the output of Sum(x,y,z) (operator+ is a two input call to Sum(a,b)). But for all intents and purposes, the errors in uncertainties could be ignore for the most part. </p>

</div>
</div>
<a id="gaaf5fe33db693d842779d0bd22932b182" name="gaaf5fe33db693d842779d0bd22932b182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5fe33db693d842779d0bd22932b182">&#9670;&nbsp;</a></span>SumUncorrelated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusr_1_1Measurement.html">Measurement</a> usr::SumUncorrelated </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>confidencelevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double, const <a class="el" href="classusr_1_1Measurement.html">Measurement</a> &amp;)&#160;</td>
          <td class="paramname"><em>nll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function also allows the user to define the working confidence level for the calculations and also the approximate negative log-likelihood function used for the individual measurements (by default using the <a class="el" href="group__StatUtils.html#gab032f76ddbdaeb1673ba7b506ffc7dc4" title="Approximate negative log-likelihood function for a measurements of .">LinearVarianceNLL()</a> function). </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.2
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
