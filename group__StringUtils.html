<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: String utilities</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String utilities<div class="ingroups"><a class="el" href="group__Common.html">Common</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4b31f6b6665f50993acef6e116431853"><td class="memItemLeft" align="right" valign="top"><a id="ga4b31f6b6665f50993acef6e116431853"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga4b31f6b6665f50993acef6e116431853">usr::GetEnv</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:ga4b31f6b6665f50993acef6e116431853"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ string version of getting system environment variables. <br /></td></tr>
<tr class="separator:ga4b31f6b6665f50993acef6e116431853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd0565e7225f61960e22229efcc658f"><td class="memItemLeft" align="right" valign="top"><a id="gaedd0565e7225f61960e22229efcc658f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#gaedd0565e7225f61960e22229efcc658f">usr::GlobToRegex</a> (const std::string &amp;query)</td></tr>
<tr class="memdesc:gaedd0565e7225f61960e22229efcc658f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting the glob notation to regex comparaison strings. <br /></td></tr>
<tr class="separator:gaedd0565e7225f61960e22229efcc658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf63eef15a505699706cb017876eb05"><td class="memItemLeft" align="right" valign="top"><a id="ga2bf63eef15a505699706cb017876eb05"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga2bf63eef15a505699706cb017876eb05">usr::GlobLocalStr</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:ga2bf63eef15a505699706cb017876eb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globbing with the return type being a list of string rather than a the std::filesystem, useful for ROOT and CMSSW interfaces. <br /></td></tr>
<tr class="separator:ga2bf63eef15a505699706cb017876eb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81bd9ef7a6463905634f22920b281ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#gaa81bd9ef7a6463905634f22920b281ce">usr::RandomString</a> (const unsigned n)</td></tr>
<tr class="memdesc:gaa81bd9ef7a6463905634f22920b281ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">generating an random alpha-numerical string of length n .  <a href="group__StringUtils.html#gaa81bd9ef7a6463905634f22920b281ce">More...</a><br /></td></tr>
<tr class="separator:gaa81bd9ef7a6463905634f22920b281ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8439671bb0fea54ad8849dc190328b2c"><td class="memItemLeft" align="right" valign="top"><a id="ga8439671bb0fea54ad8849dc190328b2c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga8439671bb0fea54ad8849dc190328b2c">usr::ToUpper</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:ga8439671bb0fea54ad8849dc190328b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting entire string to uppercase. <br /></td></tr>
<tr class="separator:ga8439671bb0fea54ad8849dc190328b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1b2bfff4179538026e6e0d4765e0aa"><td class="memItemLeft" align="right" valign="top"><a id="ga0d1b2bfff4179538026e6e0d4765e0aa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga0d1b2bfff4179538026e6e0d4765e0aa">usr::ToLower</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:ga0d1b2bfff4179538026e6e0d4765e0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting entire string to lower case. <br /></td></tr>
<tr class="separator:ga0d1b2bfff4179538026e6e0d4765e0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25dc12404a2df498de0305675383803c"><td class="memItemLeft" align="right" valign="top"><a id="ga25dc12404a2df498de0305675383803c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga25dc12404a2df498de0305675383803c">usr::StripSubstring</a> (const std::string &amp;x, const std::string &amp;sub)</td></tr>
<tr class="memdesc:ga25dc12404a2df498de0305675383803c"><td class="mdescLeft">&#160;</td><td class="mdescRight">removing all instances of a certain substring in a given string. <br /></td></tr>
<tr class="separator:ga25dc12404a2df498de0305675383803c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28362859d372589f8ee9456db9e144a7"><td class="memItemLeft" align="right" valign="top"><a id="ga28362859d372589f8ee9456db9e144a7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga28362859d372589f8ee9456db9e144a7">usr::StripCharacters</a> (const std::string &amp;x, const std::string &amp;sub)</td></tr>
<tr class="memdesc:ga28362859d372589f8ee9456db9e144a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all characters that is in string list. <br /></td></tr>
<tr class="separator:ga28362859d372589f8ee9456db9e144a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70d8532ed78acbb82747153a1678f606"><td class="memItemLeft" align="right" valign="top"><a id="ga70d8532ed78acbb82747153a1678f606"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>usr::StripToNaming</b> (const std::string &amp;)</td></tr>
<tr class="separator:ga70d8532ed78acbb82747153a1678f606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f0d6df365265569822db34bd32ee78"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">usr::MatchBrace</a> (const std::string &amp;x, const unsigned open_brace)</td></tr>
<tr class="memdesc:ga68f0d6df365265569822db34bd32ee78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returing the position of a matching brace in a string.  <a href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">More...</a><br /></td></tr>
<tr class="separator:ga68f0d6df365265569822db34bd32ee78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga450ca72ef4fd852e3d5179aff271286a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga450ca72ef4fd852e3d5179aff271286a">usr::NextOpenBrace</a> (const std::string &amp;x, const unsigned start)</td></tr>
<tr class="memdesc:ga450ca72ef4fd852e3d5179aff271286a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finding the next opening brace character after the given position.  <a href="group__StringUtils.html#ga450ca72ef4fd852e3d5179aff271286a">More...</a><br /></td></tr>
<tr class="separator:ga450ca72ef4fd852e3d5179aff271286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847d22497d2a59fb4fd26d1aa80db723"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga847d22497d2a59fb4fd26d1aa80db723">usr::starts_with</a> (const std::string &amp;master, const std::string &amp;target)</td></tr>
<tr class="memdesc:ga847d22497d2a59fb4fd26d1aa80db723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking if master string starts with some target string.  <a href="group__StringUtils.html#ga847d22497d2a59fb4fd26d1aa80db723">More...</a><br /></td></tr>
<tr class="separator:ga847d22497d2a59fb4fd26d1aa80db723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c7a679f2dd371872e1a92fac580702f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga3c7a679f2dd371872e1a92fac580702f">usr::ends_with</a> (const std::string &amp;master, const std::string &amp;target)</td></tr>
<tr class="memdesc:ga3c7a679f2dd371872e1a92fac580702f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking if a masters string ends with some target string.  <a href="group__StringUtils.html#ga3c7a679f2dd371872e1a92fac580702f">More...</a><br /></td></tr>
<tr class="separator:ga3c7a679f2dd371872e1a92fac580702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3891b1759cf97064e44c1fbf58dcdc3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#gae3891b1759cf97064e44c1fbf58dcdc3">usr::fstr</a> (boost::format &amp;fmt)</td></tr>
<tr class="memdesc:gae3891b1759cf97064e44c1fbf58dcdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic interface for generating formmatted strings.  <a href="group__StringUtils.html#gae3891b1759cf97064e44c1fbf58dcdc3">More...</a><br /></td></tr>
<tr class="separator:gae3891b1759cf97064e44c1fbf58dcdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe44131138b1d21af46eee1155ed60e"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename ... ARGS&gt; </td></tr>
<tr class="memitem:ga3fe44131138b1d21af46eee1155ed60e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga3fe44131138b1d21af46eee1155ed60e">usr::fstr</a> (boost::format &amp;fmt, TYPE &amp;&amp;T, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga3fe44131138b1d21af46eee1155ed60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic interface for generating formmatted strings.  <a href="group__StringUtils.html#ga3fe44131138b1d21af46eee1155ed60e">More...</a><br /></td></tr>
<tr class="separator:ga3fe44131138b1d21af46eee1155ed60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2954a2dac72b959640466a4fee9c4df4"><td class="memTemplParams" colspan="2">template&lt;typename ... ARGS&gt; </td></tr>
<tr class="memitem:ga2954a2dac72b959640466a4fee9c4df4"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StringUtils.html#ga2954a2dac72b959640466a4fee9c4df4">usr::fstr</a> (const std::string &amp;fmt, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga2954a2dac72b959640466a4fee9c4df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic interface for generating formmatted strings.  <a href="group__StringUtils.html#ga2954a2dac72b959640466a4fee9c4df4">More...</a><br /></td></tr>
<tr class="separator:ga2954a2dac72b959640466a4fee9c4df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3c7a679f2dd371872e1a92fac580702f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c7a679f2dd371872e1a92fac580702f">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using std::equal with the reverse iterator to complete. </p>

</div>
</div>
<a id="gae3891b1759cf97064e44c1fbf58dcdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3891b1759cf97064e44c1fbf58dcdc3">&#9670;&nbsp;</a></span>fstr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string usr::fstr </td>
          <td>(</td>
          <td class="paramtype">boost::format &amp;&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The use of this function function would be more similar to the printf of C. With the function returning a std::string instead of printing to a stream. This is intended to simply boost::format calls were complicated formatting isn't required. For examples:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="group__StringUtils.html#gae3891b1759cf97064e44c1fbf58dcdc3">fstr</a>(<span class="stringliteral">&quot;%d %d&quot;</span>, myint, myunsigned ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3fe44131138b1d21af46eee1155ed60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe44131138b1d21af46eee1155ed60e">&#9670;&nbsp;</a></span>fstr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename ... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string usr::fstr </td>
          <td>(</td>
          <td class="paramtype">boost::format &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The use of this function function would be more similar to the printf of C. With the function returning a std::string instead of printing to a stream. This is intended to simply boost::format calls were complicated formatting isn't required. For examples:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="group__StringUtils.html#gae3891b1759cf97064e44c1fbf58dcdc3">fstr</a>(<span class="stringliteral">&quot;%d %d&quot;</span>, myint, myunsigned ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2954a2dac72b959640466a4fee9c4df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2954a2dac72b959640466a4fee9c4df4">&#9670;&nbsp;</a></span>fstr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string usr::fstr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The use of this function function would be more similar to the printf of C. With the function returning a std::string instead of printing to a stream. This is intended to simply boost::format calls were complicated formatting isn't required. For examples:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="group__StringUtils.html#gae3891b1759cf97064e44c1fbf58dcdc3">fstr</a>(<span class="stringliteral">&quot;%d %d&quot;</span>, myint, myunsigned ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga68f0d6df365265569822db34bd32ee78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f0d6df365265569822db34bd32ee78">&#9670;&nbsp;</a></span>MatchBrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t usr::MatchBrace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>open_brace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given input string, and the position to the opening brace: either '[', '(' or '{', the function returns the matching brace position of the corresponding character, taking into account nest braces. For examples the function call:</p>
<div class="fragment"><div class="line"><a class="code" href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">MatchBrace</a>( <span class="stringliteral">&quot;((()))&quot;</span>, 0 ) == 5</div>
<div class="line"><a class="code" href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">MatchBrace</a>( <span class="stringliteral">&quot;((()))&quot;</span>, 1 ) == 4</div>
<div class="line"><a class="code" href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">MatchBrace</a>( <span class="stringliteral">&quot;((()))&quot;</span>, 2 ) == 3</div>
</div><!-- fragment --><p>Note that this function assumes normal tree-like structures between braces of different flavour, while only taking into account the braces of the same flavour. So the function call: </p><div class="fragment"><div class="line"><a class="code" href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">MatchBrace</a>(<span class="stringliteral">&quot;([)]&quot;</span>, 0 ) == 2</div>
<div class="line"><a class="code" href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">MatchBrace</a>(<span class="stringliteral">&quot;([)]&quot;</span>, 1 ) == 3</div>
</div><!-- fragment --><p>"Makes sense", in that it indeed returns the expected matching brace for '(', and '[' respectively, thought the actual syntax of the full string in ambiguous. In the case that the matching brace cannot be found (for example in the string "((())"), this function will return the end of the string. </p>

</div>
</div>
<a id="ga450ca72ef4fd852e3d5179aff271286a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga450ca72ef4fd852e3d5179aff271286a">&#9670;&nbsp;</a></span>NextOpenBrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t usr::NextOpenBrace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the fist instance of '[', '(' or '{' are the given index position. </p>

</div>
</div>
<a id="gaa81bd9ef7a6463905634f22920b281ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa81bd9ef7a6463905634f22920b281ce">&#9670;&nbsp;</a></span>RandomString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string usr::RandomString </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Currently the random number generator used is that std::rand function provided in the cstdlib.h file. No way of customizing the generator, but allows for setting the random seed outside the function. </p>

</div>
</div>
<a id="ga847d22497d2a59fb4fd26d1aa80db723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga847d22497d2a59fb4fd26d1aa80db723">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using the std::equal algorithm with the forwards iterator to complete. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__StringUtils_html_ga68f0d6df365265569822db34bd32ee78"><div class="ttname"><a href="group__StringUtils.html#ga68f0d6df365265569822db34bd32ee78">usr::MatchBrace</a></div><div class="ttdeci">size_t MatchBrace(const std::string &amp;, const unsigned open_brace)</div><div class="ttdoc">Returing the position of a matching brace in a string.</div><div class="ttdef"><b>Definition:</b> STLUtils_StringUtils.cc:170</div></div>
<div class="ttc" id="agroup__StringUtils_html_gae3891b1759cf97064e44c1fbf58dcdc3"><div class="ttname"><a href="group__StringUtils.html#gae3891b1759cf97064e44c1fbf58dcdc3">usr::fstr</a></div><div class="ttdeci">std::string fstr(boost::format &amp;fmt)</div><div class="ttdoc">Variadic interface for generating formmatted strings.</div><div class="ttdef"><b>Definition:</b> StringUtils.hpp:72</div></div>
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.18
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
