<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UserUtils: usr::plt::Pad1D Class Reference</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UserUtils
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usr</b></li><li class="navelem"><b>plt</b></li><li class="navelem"><a class="el" href="classusr_1_1plt_1_1Pad1D.html">Pad1D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classusr_1_1plt_1_1Pad1D-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usr::plt::Pad1D Class Reference<div class="ingroups"><a class="el" href="group__PlotUtils.html">PlotUtils</a> &raquo; <a class="el" href="group__PlotUtilsCore.html">PlotUtilsCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for usr::plt::Pad1D:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classusr_1_1plt_1_1Pad1D.png" usemap="#usr::plt::Pad1D_map" alt=""/>
  <map id="usr::plt::Pad1D_map" name="usr::plt::Pad1D_map">
<area href="classusr_1_1plt_1_1PadBase.html" title="Baseline enhancement to the TPad object and padâ€“canvas hierarchy implementation." alt="usr::plt::PadBase" shape="rect" coords="70,0,200,24"/>
<area href="classusr_1_1plt_1_1Bottom1DPad.html" title="Specialized Pad1D for additional axis/font settings." alt="usr::plt::Bottom1DPad" shape="rect" coords="0,112,130,136"/>
<area href="classusr_1_1plt_1_1Top1DPad.html" title="Specialized Pad1D for additional axis/font settings." alt="usr::plt::Top1DPad" shape="rect" coords="140,112,270,136"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class aims for a uniform plotting interface for both <a href="https://root.cern.ch">ROOT</a> and <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> objects, assisting with plotting objects according to CMS recommended plotting style, removing the use of 'magic strings' needed for object plotting, reducing the verbosity of the code needed for generating publication ready plots, and improving the readability of the plotting related codes in general.</p>
<h1>Plotting ROOT and RooFit objects under the same interface</h1>
<p><a href="https://root.cern.ch">ROOT</a> and <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> takes two distinct style of plotting: In <a href="https://root.cern.ch">ROOT</a>, data containers and plotting objects are one-and-the-same (i.e. a <a href="https://root.cern.ch/doc/master/classTH1D.html">TH1D</a> instance is used for data interaction via <code>Fill</code> functions, and stylising the plotting output via the <code>SetLineColor()</code> and similar functions); In <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a>, the data containers (<a href="https://root.cern.ch/doc/master/classRooDataSet.html">RooDataSet</a>s, and <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>) are used to generated plotting classes (<a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a>s) via the <code>plotOn</code> functions, with the assistance of a <a href="https://root.cern.ch/doc/master/classRooPlot.html">RooPlot</a> object, where the generated objects are destroyed when the <a href="https://root.cern.ch/doc/master/classRooPlot.html">RooPlot</a> object goes out of scope.</p>
<p><a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> has a very good reason for doing such a thing: the process of generating a simple plotting object from a complicated, multi-variable entity is non-trivial, and in the case of serious numerical analysis, the same data entity might be required to be plotted multiple times with different extraction methods. Defining the plotting styles in the objects could very likely cause unwanted behaviors in the resulting plots. However, <a href="https://root.cern.ch">ROOT</a> objects are relatively simple, with very few ways of presenting the stored data, so not using an additional generated object to plot and object 'makes sense'. The final design decision was to keep the plotting of <a href="https://root.cern.ch">ROOT</a> objects "ROOT"-like; and <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> objects "RooFit"-like:</p>
<ul>
<li><a href="https://root.cern.ch">ROOT</a> objects are drawn on the Pad instance, with the objects ownership untouched. A wrapper for the <code><a class="el" href="classusr_1_1plt_1_1PadBase.html#ada457a73a1a38327303a6ffc9f19a6a2" title="Interface to superseed the TObject::Draw() for generating plots.">PadBase::PlotObj()</a></code> functions would be used for additional style handling.</li>
<li><a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> object would have their representative <a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a> objects generated by an internal <a href="https://root.cern.ch/doc/master/classRooPlot.html">RooPlot</a> object, then the <a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a> will have their plotting options passed onto as to the ROOT object plotting functions. This is to avoid repeated calls to the <code>RooPlot::Draw()</code> functions, as this function basically loops overall the internal objects and passes it to the working <a href="https://root.cern.ch/doc/master/classTPad.html">TPad</a>. The <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> plotting functions would also return a reference to the generated <a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a> object to allow for additional stylising.</li>
</ul>
<p>The plotting functions will essentially be a improved <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> plotting interface using the <a href="https://root.cern.ch/doc/master/classRooCmdArg.html">RooCmdArg</a> class to change the behavior of the plotting:</p>
<div class="fragment"><div class="line">pad.Plot&lt;ObjType&gt;( <a class="code" href="classusr_1_1plt_1_1PadBase.html#ada457a73a1a38327303a6ffc9f19a6a2">PlotObj</a>, Cmd1, Cmd2, Cmd3,... );</div>
<div class="ttc" id="aclassusr_1_1plt_1_1PadBase_html_ada457a73a1a38327303a6ffc9f19a6a2"><div class="ttname"><a href="classusr_1_1plt_1_1PadBase.html#ada457a73a1a38327303a6ffc9f19a6a2">usr::plt::PadBase::PlotObj</a></div><div class="ttdeci">void PlotObj(TObject &amp;, Option_t *=&quot;&quot;)</div><div class="ttdoc">Interface to superseed the TObject::Draw() for generating plots.</div><div class="ttdef"><b>Definition:</b> PadBase.cc:235</div></div>
</div><!-- fragment --><p>For the case of plotting <a href="https://root.cern.ch/roofit-20-minutes">RooFit</a> objects, all RooFit defined <a href="https://root.cern.ch/doc/master/classRooCmdArg.html">RooCmdArg</a>s are acceptable, with some custom commands made designed additional enhancements.</p>
<h1>Object plotting behavior enhancements</h1>
<p>A few addition plotting behavior for objects are present:</p>
<ul>
<li><b>PlotType</b> allows for the specification of how the data should be presented: whether as scatter plot (data point with error bars), a function line with uncertainty band or standard solid histograms or histogram error boxes. Additional parsing for setting the styling of with CMS plotting conventions (ex. no x error bars should be present for equal-bin-width histograms...etc) are also present. More details would be given in the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a52854cd0946f580296f34ddd0cbef917" title="Plotting 1D histogram objects.">Pad1D::PlotHist()</a> and <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a36ca6919a50117a307b00e4eb110677a" title="Plotting x-y scatter graph objects.">Pad1D::PlotGraph()</a> functions.</li>
<li><b>TrackY</b> tells the pad whether for not to adjust the Y axis range depending on input object. If it is not specified, it is automatically determined as followed:<ul>
<li>If the object is a histogram, then only the maximum value is tracked for axis range adjustment (the default 'minimum value' is 0.3).</li>
<li>If the object is a <a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a>, and no histogram is already present in the pad, then both the maximum and minimum values are tracked. If any histogram is already present however, the new <a href="https://root.cern.ch/doc/master/classTGraph.html">TGraph</a> would not change the axis range.</li>
</ul>
</li>
<li><b>EntryText</b> tells the object to be added to the legend on the pad. What is to be presented in the legend would be automatically determined by the PlotType passed to the plot function.</li>
<li><b>VisualizeError</b> is now extended to include TF1, which takes a TFitResult to interpret for the error band should be drawn.</li>
<li><b>PlotUnder</b>. In ROOT, the first plotted objects are always placed at the back of the canvas. Sometimes this is not desireable, since the a object that is plotted later might want to be placed in the background, while required to be calculated only after a certain object has been generated (an example that comes to mind is the plotting of the RooFit objects, where the plotting of <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s depends on the existence of a <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a> object, unless explicitly specified). This option will be force a later plotted object to be behind a certain target.</li>
</ul>
<h1>Additional Pad plotting behavior enhancements</h1>
<ul>
<li>Standard CMS and luminosity labels text would be added to the pad via the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#aad95f7f3a6915f6721df119241ef0ee1" title="Drawing CMS label.">Pad1D::DrawCMSLabel()</a> and <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a9441be81ed4b9ac3823f6787c8cedab5" title="Drawing luminosity label.">Pad1D::DrawLuminosity()</a> functions. The CMS label would be placed on the top-left side inside the axis frame, while the luminosity label would be placed on the top-right side outside the axis frame.</li>
<li><p class="startli">If an EntryText is specified at any point in the pad's lifetime, A <a href="https://root.cern.ch/doc/master/classTLegend.html">TLegend</a> would be spawn on the the pad inside the axis frame. The size of the frame would be automatically adjusted, based on the entry text lengths and the number of entries specified. The position of the legend can be any of the 9 positions in the left&ndash;center&ndash;right, top&ndash;center&ndash;bottom system. By default, the legend is placed on the top-right, exploiting the fact that HEP 1D plots typically exhibit long trailing tails on the right.</p>
<p class="startli">An issue with ROOT object drawing is that the first object to be drawn has a smaller z index (placed towards the back), when usually the plotted towards the foreground are more 'important' (should be higher on the legend entries). So we will be using a stack to temporary store the legend entry and flushing it's content when a save function is called. When the flushing is called, additional method would also be used to determine the size of the legend, and the size of the legend would be adjusted accordingly. </p>
</li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8abc92e4404a07ea4fafd8ee4a5441eb"><td class="memItemLeft" align="right" valign="top"><a id="a8abc92e4404a07ea4fafd8ee4a5441eb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8abc92e4404a07ea4fafd8ee4a5441eb">rangetype</a> { <br />
&#160;&#160;<b>hist</b>
, <b>graph</b>
, <b>ratio</b>
, <b>pull</b>
, <br />
&#160;&#160;<b>aut</b>
<br />
 }</td></tr>
<tr class="memdesc:a8abc92e4404a07ea4fafd8ee4a5441eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for specifying y range adjustment type. <br /></td></tr>
<tr class="separator:a8abc92e4404a07ea4fafd8ee4a5441eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af811a25821542984632686b77719e3d4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#af811a25821542984632686b77719e3d4">~Pad1D</a> ()</td></tr>
<tr class="separator:af811a25821542984632686b77719e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78728a4674c71faf294a8ac515ee583"><td class="memItemLeft" align="right" valign="top"><a id="ac78728a4674c71faf294a8ac515ee583"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Pad1D</b> (const <a class="el" href="classusr_1_1plt_1_1Pad1D.html">Pad1D</a> &amp;)=delete</td></tr>
<tr class="separator:ac78728a4674c71faf294a8ac515ee583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad95f7f3a6915f6721df119241ef0ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aad95f7f3a6915f6721df119241ef0ee1">DrawCMSLabel</a> (const std::string &amp;=cap::prelim, const std::string &amp;main=&quot;CMS&quot;)</td></tr>
<tr class="memdesc:aad95f7f3a6915f6721df119241ef0ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drawing CMS label.  <a href="classusr_1_1plt_1_1Pad1D.html#aad95f7f3a6915f6721df119241ef0ee1">More...</a><br /></td></tr>
<tr class="separator:aad95f7f3a6915f6721df119241ef0ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9441be81ed4b9ac3823f6787c8cedab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a9441be81ed4b9ac3823f6787c8cedab5">DrawLuminosity</a> (const double luminosity)</td></tr>
<tr class="memdesc:a9441be81ed4b9ac3823f6787c8cedab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drawing luminosity label.  <a href="classusr_1_1plt_1_1Pad1D.html#a9441be81ed4b9ac3823f6787c8cedab5">More...</a><br /></td></tr>
<tr class="separator:a9441be81ed4b9ac3823f6787c8cedab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f35d9871ea075606b63bee19eac55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a871f35d9871ea075606b63bee19eac55">DrawLuminosity</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:a871f35d9871ea075606b63bee19eac55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drawing luminosity label.  <a href="classusr_1_1plt_1_1Pad1D.html#a871f35d9871ea075606b63bee19eac55">More...</a><br /></td></tr>
<tr class="separator:a871f35d9871ea075606b63bee19eac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2979843fc2bc6bcad63ee1dda4220290"><td class="memItemLeft" align="right" valign="top">TObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a2979843fc2bc6bcad63ee1dda4220290">GetAxisObject</a> () const</td></tr>
<tr class="memdesc:a2979843fc2bc6bcad63ee1dda4220290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning the TObject used for drawing the axis frame.  <a href="classusr_1_1plt_1_1Pad1D.html#a2979843fc2bc6bcad63ee1dda4220290">More...</a><br /></td></tr>
<tr class="separator:a2979843fc2bc6bcad63ee1dda4220290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c90d4877f10969d760c8a9975524a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a22c90d4877f10969d760c8a9975524a1">SetAxisFont</a> ()</td></tr>
<tr class="memdesc:a22c90d4877f10969d760c8a9975524a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the axis fonts according to canvas settings.  <a href="classusr_1_1plt_1_1Pad1D.html#a22c90d4877f10969d760c8a9975524a1">More...</a><br /></td></tr>
<tr class="separator:a22c90d4877f10969d760c8a9975524a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed478e638d860ae43b94b1e7ad7e254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a0ed478e638d860ae43b94b1e7ad7e254">SetHistAxisTitles</a> (const std::string &amp;title, const std::string &amp;unit=&quot;&quot;, const std::string &amp;ytitle=&quot;Events&quot;, const double forcebinwidth=<a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8d6974d40a82ec22e24694bcab2b30f0">autobinwidth</a>)</td></tr>
<tr class="memdesc:a0ed478e638d860ae43b94b1e7ad7e254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Naming x-y axis according to x axis unit and bin-width.  <a href="classusr_1_1plt_1_1Pad1D.html#a0ed478e638d860ae43b94b1e7ad7e254">More...</a><br /></td></tr>
<tr class="separator:a0ed478e638d860ae43b94b1e7ad7e254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58dfc9c463ad5f56c7ce305491ea0cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ab58dfc9c463ad5f56c7ce305491ea0cb">AutoSetYRange</a> (const <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8abc92e4404a07ea4fafd8ee4a5441eb">rangetype</a>=aut)</td></tr>
<tr class="memdesc:ab58dfc9c463ad5f56c7ce305491ea0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically adjusting y axis range according to tracked min/max values.  <a href="classusr_1_1plt_1_1Pad1D.html#ab58dfc9c463ad5f56c7ce305491ea0cb">More...</a><br /></td></tr>
<tr class="separator:ab58dfc9c463ad5f56c7ce305491ea0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1601f406c237e1c4a34c81223c9e64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a0e1601f406c237e1c4a34c81223c9e64">SetLogy</a> (int)</td></tr>
<tr class="separator:a0e1601f406c237e1c4a34c81223c9e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af995d0adfdc7d4d523c06f257142d47a"><td class="memItemLeft" align="right" valign="top"><a id="af995d0adfdc7d4d523c06f257142d47a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#af995d0adfdc7d4d523c06f257142d47a">SetLogx</a> (int)</td></tr>
<tr class="memdesc:af995d0adfdc7d4d523c06f257142d47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple passthrough function. <br /></td></tr>
<tr class="separator:af995d0adfdc7d4d523c06f257142d47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cd70b45b61ba135afa77eae787adc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a13cd70b45b61ba135afa77eae787adc7">AddLegendEntry</a> (TObject &amp;, const std::string &amp;title, const std::string &amp;format)</td></tr>
<tr class="memdesc:a13cd70b45b61ba135afa77eae787adc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly adding a TObject into the legend stack. Used for the creation of additional objects (such as guiding lines via V/HLine). Takes standard ROOT Flavour options to specify points.  <a href="classusr_1_1plt_1_1Pad1D.html#a13cd70b45b61ba135afa77eae787adc7">More...</a><br /></td></tr>
<tr class="separator:a13cd70b45b61ba135afa77eae787adc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743c3322507660b44f1ccd3da82c14b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a2743c3322507660b44f1ccd3da82c14b">FinalizeLegend</a> (const align x)</td></tr>
<tr class="separator:a2743c3322507660b44f1ccd3da82c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bcfa71a9850382836d41acbf4ede6e"><td class="memItemLeft" align="right" valign="top"><a id="a55bcfa71a9850382836d41acbf4ede6e"></a>
TLegend &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a55bcfa71a9850382836d41acbf4ede6e">Legend</a> ()</td></tr>
<tr class="memdesc:a55bcfa71a9850382836d41acbf4ede6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning reference to internal legend object. <br /></td></tr>
<tr class="separator:a55bcfa71a9850382836d41acbf4ede6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198138c5f550494aa1945daed22a8a09"><td class="memItemLeft" align="right" valign="top"><a id="a198138c5f550494aa1945daed22a8a09"></a>
<a class="el" href="classusr_1_1plt_1_1RooFrame.html">RooFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a198138c5f550494aa1945daed22a8a09">FrameObj</a> ()</td></tr>
<tr class="memdesc:a198138c5f550494aa1945daed22a8a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning reference to internal Roo1DFrame object. <br /></td></tr>
<tr class="separator:a198138c5f550494aa1945daed22a8a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7381a3ba207f448546f3d4f432f15d"><td class="memItemLeft" align="right" valign="top"><a id="a8d7381a3ba207f448546f3d4f432f15d"></a>
const <a class="el" href="classusr_1_1plt_1_1RooFrame.html">RooFrame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8d7381a3ba207f448546f3d4f432f15d">FrameObj</a> () const</td></tr>
<tr class="memdesc:a8d7381a3ba207f448546f3d4f432f15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning reference to internal Roo1DFrame object. <br /></td></tr>
<tr class="separator:a8d7381a3ba207f448546f3d4f432f15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ca67dd42f6e42bfe9088330a9d8ee"><td class="memItemLeft" align="right" valign="top"><a id="a934ca67dd42f6e42bfe9088330a9d8ee"></a>
<a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8abc92e4404a07ea4fafd8ee4a5441eb">rangetype</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a934ca67dd42f6e42bfe9088330a9d8ee">RangeType</a> ()</td></tr>
<tr class="memdesc:a934ca67dd42f6e42bfe9088330a9d8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning the stored y range adjustment type <br /></td></tr>
<tr class="separator:a934ca67dd42f6e42bfe9088330a9d8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a52854cd0946f580296f34ddd0cbef917"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a52854cd0946f580296f34ddd0cbef917">PlotHist</a> (TH1D &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a52854cd0946f580296f34ddd0cbef917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting 1D histogram objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a52854cd0946f580296f34ddd0cbef917">More...</a><br /></td></tr>
<tr class="separator:a52854cd0946f580296f34ddd0cbef917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7966698b713b3ddd8cd81a4670fc945"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae7966698b713b3ddd8cd81a4670fc945">PlotHist</a> (TH1D *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:ae7966698b713b3ddd8cd81a4670fc945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting 1D histogram objects.  <a href="classusr_1_1plt_1_1Pad1D.html#ae7966698b713b3ddd8cd81a4670fc945">More...</a><br /></td></tr>
<tr class="separator:ae7966698b713b3ddd8cd81a4670fc945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e43d8364c8ff6292c33e3948d6e805"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a63e43d8364c8ff6292c33e3948d6e805">PlotHist</a> (TH1D &amp;x)</td></tr>
<tr class="memdesc:a63e43d8364c8ff6292c33e3948d6e805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting 1D histogram objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a63e43d8364c8ff6292c33e3948d6e805">More...</a><br /></td></tr>
<tr class="separator:a63e43d8364c8ff6292c33e3948d6e805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81dc15a8d70dcfaa110fd0840ae063"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aac81dc15a8d70dcfaa110fd0840ae063">PlotHist</a> (TH1D *x)</td></tr>
<tr class="memdesc:aac81dc15a8d70dcfaa110fd0840ae063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting 1D histogram objects.  <a href="classusr_1_1plt_1_1Pad1D.html#aac81dc15a8d70dcfaa110fd0840ae063">More...</a><br /></td></tr>
<tr class="separator:aac81dc15a8d70dcfaa110fd0840ae063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef343cd12f9c706ebb5ee6b8b1c7f6b"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7ef343cd12f9c706ebb5ee6b8b1c7f6b"><td class="memTemplItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a7ef343cd12f9c706ebb5ee6b8b1c7f6b">PlotHist</a> (TH1D &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a7ef343cd12f9c706ebb5ee6b8b1c7f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting 1D histogram objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a7ef343cd12f9c706ebb5ee6b8b1c7f6b">More...</a><br /></td></tr>
<tr class="separator:a7ef343cd12f9c706ebb5ee6b8b1c7f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9688f51b4423cc9c246ecaec1b4bb7be"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a9688f51b4423cc9c246ecaec1b4bb7be"><td class="memTemplItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a9688f51b4423cc9c246ecaec1b4bb7be">PlotHist</a> (TH1D *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a9688f51b4423cc9c246ecaec1b4bb7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting 1D histogram objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a9688f51b4423cc9c246ecaec1b4bb7be">More...</a><br /></td></tr>
<tr class="separator:a9688f51b4423cc9c246ecaec1b4bb7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aafca9980d69d1e09ce049d158b0e584e"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aafca9980d69d1e09ce049d158b0e584e">PlotProfile</a> (TProfile &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:aafca9980d69d1e09ce049d158b0e584e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case for TProfile plotting.  <a href="classusr_1_1plt_1_1Pad1D.html#aafca9980d69d1e09ce049d158b0e584e">More...</a><br /></td></tr>
<tr class="separator:aafca9980d69d1e09ce049d158b0e584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b64024ae2f57df69e9f040a31cb4e7"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ab2b64024ae2f57df69e9f040a31cb4e7">PlotProfile</a> (TProfile *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:ab2b64024ae2f57df69e9f040a31cb4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case for TProfile plotting.  <a href="classusr_1_1plt_1_1Pad1D.html#ab2b64024ae2f57df69e9f040a31cb4e7">More...</a><br /></td></tr>
<tr class="separator:ab2b64024ae2f57df69e9f040a31cb4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85570690ce79e065b083eab26c471b"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a2a85570690ce79e065b083eab26c471b">PlotProfile</a> (TProfile &amp;x)</td></tr>
<tr class="memdesc:a2a85570690ce79e065b083eab26c471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case for TProfile plotting.  <a href="classusr_1_1plt_1_1Pad1D.html#a2a85570690ce79e065b083eab26c471b">More...</a><br /></td></tr>
<tr class="separator:a2a85570690ce79e065b083eab26c471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2bc2b251e12c8dd880435bdff42dcc"><td class="memItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a9e2bc2b251e12c8dd880435bdff42dcc">PlotProfile</a> (TProfile *x)</td></tr>
<tr class="memdesc:a9e2bc2b251e12c8dd880435bdff42dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case for TProfile plotting.  <a href="classusr_1_1plt_1_1Pad1D.html#a9e2bc2b251e12c8dd880435bdff42dcc">More...</a><br /></td></tr>
<tr class="separator:a9e2bc2b251e12c8dd880435bdff42dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc20ed94bc8da43e68a207fd34403d6d"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:afc20ed94bc8da43e68a207fd34403d6d"><td class="memTemplItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#afc20ed94bc8da43e68a207fd34403d6d">PlotProfile</a> (TProfile &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:afc20ed94bc8da43e68a207fd34403d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case for TProfile plotting.  <a href="classusr_1_1plt_1_1Pad1D.html#afc20ed94bc8da43e68a207fd34403d6d">More...</a><br /></td></tr>
<tr class="separator:afc20ed94bc8da43e68a207fd34403d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7760d8f1d0cdf66381b7c8eb293e55"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aac7760d8f1d0cdf66381b7c8eb293e55"><td class="memTemplItemLeft" align="right" valign="top">TH1D &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aac7760d8f1d0cdf66381b7c8eb293e55">PlotProfile</a> (TProfile *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:aac7760d8f1d0cdf66381b7c8eb293e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case for TProfile plotting.  <a href="classusr_1_1plt_1_1Pad1D.html#aac7760d8f1d0cdf66381b7c8eb293e55">More...</a><br /></td></tr>
<tr class="separator:aac7760d8f1d0cdf66381b7c8eb293e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abb4fb1cf077e58a82610098f067b9135"><td class="memItemLeft" align="right" valign="top">TEfficiency &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#abb4fb1cf077e58a82610098f067b9135">PlotEff</a> (TEfficiency &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:abb4fb1cf077e58a82610098f067b9135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting TEfficiency objects.  <a href="classusr_1_1plt_1_1Pad1D.html#abb4fb1cf077e58a82610098f067b9135">More...</a><br /></td></tr>
<tr class="separator:abb4fb1cf077e58a82610098f067b9135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade509d4cc57221bb395ae4d2e9238a28"><td class="memItemLeft" align="right" valign="top">TEfficiency &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ade509d4cc57221bb395ae4d2e9238a28">PlotEff</a> (TEfficiency *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:ade509d4cc57221bb395ae4d2e9238a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting TEfficiency objects.  <a href="classusr_1_1plt_1_1Pad1D.html#ade509d4cc57221bb395ae4d2e9238a28">More...</a><br /></td></tr>
<tr class="separator:ade509d4cc57221bb395ae4d2e9238a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ad4ef176729c102b4071f443ab8fc8"><td class="memItemLeft" align="right" valign="top">TEfficiency &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a11ad4ef176729c102b4071f443ab8fc8">PlotEff</a> (TEfficiency &amp;x)</td></tr>
<tr class="memdesc:a11ad4ef176729c102b4071f443ab8fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting TEfficiency objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a11ad4ef176729c102b4071f443ab8fc8">More...</a><br /></td></tr>
<tr class="separator:a11ad4ef176729c102b4071f443ab8fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef376e8075a5b3d423ed078edfd9a66"><td class="memItemLeft" align="right" valign="top">TEfficiency &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a5ef376e8075a5b3d423ed078edfd9a66">PlotEff</a> (TEfficiency *x)</td></tr>
<tr class="memdesc:a5ef376e8075a5b3d423ed078edfd9a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting TEfficiency objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a5ef376e8075a5b3d423ed078edfd9a66">More...</a><br /></td></tr>
<tr class="separator:a5ef376e8075a5b3d423ed078edfd9a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a056d9f575173de9d1bb4240d732ae"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa3a056d9f575173de9d1bb4240d732ae"><td class="memTemplItemLeft" align="right" valign="top">TEfficiency &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aa3a056d9f575173de9d1bb4240d732ae">PlotEff</a> (TEfficiency &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:aa3a056d9f575173de9d1bb4240d732ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting TEfficiency objects.  <a href="classusr_1_1plt_1_1Pad1D.html#aa3a056d9f575173de9d1bb4240d732ae">More...</a><br /></td></tr>
<tr class="separator:aa3a056d9f575173de9d1bb4240d732ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e74757ec2830a6ac9bac7c45e2b1d41"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a3e74757ec2830a6ac9bac7c45e2b1d41"><td class="memTemplItemLeft" align="right" valign="top">TEfficiency &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a3e74757ec2830a6ac9bac7c45e2b1d41">PlotEff</a> (TEfficiency *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a3e74757ec2830a6ac9bac7c45e2b1d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting TEfficiency objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a3e74757ec2830a6ac9bac7c45e2b1d41">More...</a><br /></td></tr>
<tr class="separator:a3e74757ec2830a6ac9bac7c45e2b1d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a36ca6919a50117a307b00e4eb110677a"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a36ca6919a50117a307b00e4eb110677a">PlotGraph</a> (TGraph &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a36ca6919a50117a307b00e4eb110677a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting x-y scatter graph objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a36ca6919a50117a307b00e4eb110677a">More...</a><br /></td></tr>
<tr class="separator:a36ca6919a50117a307b00e4eb110677a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faeadf03c6e8b917d9be26e27246cbd"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a4faeadf03c6e8b917d9be26e27246cbd">PlotGraph</a> (TGraph *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:a4faeadf03c6e8b917d9be26e27246cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting x-y scatter graph objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a4faeadf03c6e8b917d9be26e27246cbd">More...</a><br /></td></tr>
<tr class="separator:a4faeadf03c6e8b917d9be26e27246cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dadacc5bf0b7d99d46c5a93568abba"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae6dadacc5bf0b7d99d46c5a93568abba">PlotGraph</a> (TGraph &amp;x)</td></tr>
<tr class="memdesc:ae6dadacc5bf0b7d99d46c5a93568abba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting x-y scatter graph objects.  <a href="classusr_1_1plt_1_1Pad1D.html#ae6dadacc5bf0b7d99d46c5a93568abba">More...</a><br /></td></tr>
<tr class="separator:ae6dadacc5bf0b7d99d46c5a93568abba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e28adae679e94e37deb2950b46af4b"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aa1e28adae679e94e37deb2950b46af4b">PlotGraph</a> (TGraph *x)</td></tr>
<tr class="memdesc:aa1e28adae679e94e37deb2950b46af4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting x-y scatter graph objects.  <a href="classusr_1_1plt_1_1Pad1D.html#aa1e28adae679e94e37deb2950b46af4b">More...</a><br /></td></tr>
<tr class="separator:aa1e28adae679e94e37deb2950b46af4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8782257efd5be01aa6f4f805e734e8a8"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a8782257efd5be01aa6f4f805e734e8a8"><td class="memTemplItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8782257efd5be01aa6f4f805e734e8a8">PlotGraph</a> (TGraph &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a8782257efd5be01aa6f4f805e734e8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting x-y scatter graph objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a8782257efd5be01aa6f4f805e734e8a8">More...</a><br /></td></tr>
<tr class="separator:a8782257efd5be01aa6f4f805e734e8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1196fe82af6bb02ca7536bde5b9aee"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a4f1196fe82af6bb02ca7536bde5b9aee"><td class="memTemplItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a4f1196fe82af6bb02ca7536bde5b9aee">PlotGraph</a> (TGraph *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a4f1196fe82af6bb02ca7536bde5b9aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting x-y scatter graph objects.  <a href="classusr_1_1plt_1_1Pad1D.html#a4f1196fe82af6bb02ca7536bde5b9aee">More...</a><br /></td></tr>
<tr class="separator:a4f1196fe82af6bb02ca7536bde5b9aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad70690f2d8160849df791765b6cda04b"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b">PlotFunc</a> (TF1 &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:ad70690f2d8160849df791765b6cda04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting ROOT flavoured 1D function.  <a href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b">More...</a><br /></td></tr>
<tr class="separator:ad70690f2d8160849df791765b6cda04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d5a41991b79a01fe2be16014d8e069"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a98d5a41991b79a01fe2be16014d8e069">PlotFunc</a> (TF1 *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:a98d5a41991b79a01fe2be16014d8e069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting ROOT flavoured 1D function.  <a href="classusr_1_1plt_1_1Pad1D.html#a98d5a41991b79a01fe2be16014d8e069">More...</a><br /></td></tr>
<tr class="separator:a98d5a41991b79a01fe2be16014d8e069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3653ad04351072c992c65aa11303882"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ac3653ad04351072c992c65aa11303882">PlotFunc</a> (TF1 &amp;x)</td></tr>
<tr class="memdesc:ac3653ad04351072c992c65aa11303882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting ROOT flavoured 1D function.  <a href="classusr_1_1plt_1_1Pad1D.html#ac3653ad04351072c992c65aa11303882">More...</a><br /></td></tr>
<tr class="separator:ac3653ad04351072c992c65aa11303882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a5becac2f93a0bb7dd5a3a7a246575"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a86a5becac2f93a0bb7dd5a3a7a246575">PlotFunc</a> (TF1 *x)</td></tr>
<tr class="memdesc:a86a5becac2f93a0bb7dd5a3a7a246575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting ROOT flavoured 1D function.  <a href="classusr_1_1plt_1_1Pad1D.html#a86a5becac2f93a0bb7dd5a3a7a246575">More...</a><br /></td></tr>
<tr class="separator:a86a5becac2f93a0bb7dd5a3a7a246575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ded4c175adcb44b92e00aa3bd3488f"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ae1ded4c175adcb44b92e00aa3bd3488f"><td class="memTemplItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae1ded4c175adcb44b92e00aa3bd3488f">PlotFunc</a> (TF1 &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:ae1ded4c175adcb44b92e00aa3bd3488f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting ROOT flavoured 1D function.  <a href="classusr_1_1plt_1_1Pad1D.html#ae1ded4c175adcb44b92e00aa3bd3488f">More...</a><br /></td></tr>
<tr class="separator:ae1ded4c175adcb44b92e00aa3bd3488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3f4061b85e39202be06cdaea1b79b5"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a4c3f4061b85e39202be06cdaea1b79b5"><td class="memTemplItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a4c3f4061b85e39202be06cdaea1b79b5">PlotFunc</a> (TF1 *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a4c3f4061b85e39202be06cdaea1b79b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting ROOT flavoured 1D function.  <a href="classusr_1_1plt_1_1Pad1D.html#a4c3f4061b85e39202be06cdaea1b79b5">More...</a><br /></td></tr>
<tr class="separator:a4c3f4061b85e39202be06cdaea1b79b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a920475e93f4671bc4b7eafe72898d3e9"><td class="memItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a920475e93f4671bc4b7eafe72898d3e9">PlotData</a> (RooAbsData &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a920475e93f4671bc4b7eafe72898d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a920475e93f4671bc4b7eafe72898d3e9">More...</a><br /></td></tr>
<tr class="separator:a920475e93f4671bc4b7eafe72898d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad561aad2de79a33fbb3958219b98a339"><td class="memItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad561aad2de79a33fbb3958219b98a339">PlotData</a> (RooAbsData *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:ad561aad2de79a33fbb3958219b98a339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#ad561aad2de79a33fbb3958219b98a339">More...</a><br /></td></tr>
<tr class="separator:ad561aad2de79a33fbb3958219b98a339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca8fbccf80747c729439ccc49141de3"><td class="memItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a1ca8fbccf80747c729439ccc49141de3">PlotData</a> (RooAbsData &amp;x)</td></tr>
<tr class="memdesc:a1ca8fbccf80747c729439ccc49141de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a1ca8fbccf80747c729439ccc49141de3">More...</a><br /></td></tr>
<tr class="separator:a1ca8fbccf80747c729439ccc49141de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ff796681bb57e66b06beae2eae2b41"><td class="memItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a37ff796681bb57e66b06beae2eae2b41">PlotData</a> (RooAbsData *x)</td></tr>
<tr class="memdesc:a37ff796681bb57e66b06beae2eae2b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a37ff796681bb57e66b06beae2eae2b41">More...</a><br /></td></tr>
<tr class="separator:a37ff796681bb57e66b06beae2eae2b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551709f0e9a71fd961e708ecc0993175"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a551709f0e9a71fd961e708ecc0993175"><td class="memTemplItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a551709f0e9a71fd961e708ecc0993175">PlotData</a> (RooAbsData &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a551709f0e9a71fd961e708ecc0993175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a551709f0e9a71fd961e708ecc0993175">More...</a><br /></td></tr>
<tr class="separator:a551709f0e9a71fd961e708ecc0993175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a79df61937af9584bd8a3f89202f05"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a14a79df61937af9584bd8a3f89202f05"><td class="memTemplItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a14a79df61937af9584bd8a3f89202f05">PlotData</a> (RooAbsData *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a14a79df61937af9584bd8a3f89202f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsData.html">RooAbsData</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a14a79df61937af9584bd8a3f89202f05">More...</a><br /></td></tr>
<tr class="separator:a14a79df61937af9584bd8a3f89202f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9b7b84d34c8ad13901d9f4fd9f3ac6a2"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a9b7b84d34c8ad13901d9f4fd9f3ac6a2">PlotPdf</a> (RooAbsPdf &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a9b7b84d34c8ad13901d9f4fd9f3ac6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a9b7b84d34c8ad13901d9f4fd9f3ac6a2">More...</a><br /></td></tr>
<tr class="separator:a9b7b84d34c8ad13901d9f4fd9f3ac6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9f540fa71eb04b9cdefe08c2990b2"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a40d9f540fa71eb04b9cdefe08c2990b2">PlotPdf</a> (RooAbsPdf *x, const std::vector&lt; RooCmdArg &gt; &amp;list)</td></tr>
<tr class="memdesc:a40d9f540fa71eb04b9cdefe08c2990b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a40d9f540fa71eb04b9cdefe08c2990b2">More...</a><br /></td></tr>
<tr class="separator:a40d9f540fa71eb04b9cdefe08c2990b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8075c0596d982ee2cbae7bb04ccb59"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a6a8075c0596d982ee2cbae7bb04ccb59">PlotPdf</a> (RooAbsPdf &amp;x)</td></tr>
<tr class="memdesc:a6a8075c0596d982ee2cbae7bb04ccb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a6a8075c0596d982ee2cbae7bb04ccb59">More...</a><br /></td></tr>
<tr class="separator:a6a8075c0596d982ee2cbae7bb04ccb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d9c075d2d06ffd1ca4e7ae6f98d0f2"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a04d9c075d2d06ffd1ca4e7ae6f98d0f2">PlotPdf</a> (RooAbsPdf *x)</td></tr>
<tr class="memdesc:a04d9c075d2d06ffd1ca4e7ae6f98d0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a04d9c075d2d06ffd1ca4e7ae6f98d0f2">More...</a><br /></td></tr>
<tr class="separator:a04d9c075d2d06ffd1ca4e7ae6f98d0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2c07eee329b6b2d8e7345e32e19af4"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7c2c07eee329b6b2d8e7345e32e19af4"><td class="memTemplItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a7c2c07eee329b6b2d8e7345e32e19af4">PlotPdf</a> (RooAbsPdf &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a7c2c07eee329b6b2d8e7345e32e19af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#a7c2c07eee329b6b2d8e7345e32e19af4">More...</a><br /></td></tr>
<tr class="separator:a7c2c07eee329b6b2d8e7345e32e19af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf97fbac03051b083ead9a1b60bbd6f"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:adbf97fbac03051b083ead9a1b60bbd6f"><td class="memTemplItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#adbf97fbac03051b083ead9a1b60bbd6f">PlotPdf</a> (RooAbsPdf *x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:adbf97fbac03051b083ead9a1b60bbd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plotting RooFit's <a href="https://root.cern.ch/doc/master/classRooAbsPdf.html">RooAbsPdf</a>s.  <a href="classusr_1_1plt_1_1Pad1D.html#adbf97fbac03051b083ead9a1b60bbd6f">More...</a><br /></td></tr>
<tr class="separator:adbf97fbac03051b083ead9a1b60bbd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1eca42db9e402fb0d3d954b86226c379"><td class="memItemLeft" align="right" valign="top">TLine &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a1eca42db9e402fb0d3d954b86226c379">DrawHLine</a> (const double &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a1eca42db9e402fb0d3d954b86226c379"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for drawing a horizontal line across pad  <a href="classusr_1_1plt_1_1Pad1D.html#a1eca42db9e402fb0d3d954b86226c379">More...</a><br /></td></tr>
<tr class="separator:a1eca42db9e402fb0d3d954b86226c379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63db7da215d5ef78a72bacb12f363a2f"><td class="memItemLeft" align="right" valign="top">TLine &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a63db7da215d5ef78a72bacb12f363a2f">DrawHLine</a> (const double &amp;x)</td></tr>
<tr class="memdesc:a63db7da215d5ef78a72bacb12f363a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for drawing a horizontal line across pad  <a href="classusr_1_1plt_1_1Pad1D.html#a63db7da215d5ef78a72bacb12f363a2f">More...</a><br /></td></tr>
<tr class="separator:a63db7da215d5ef78a72bacb12f363a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f6d0ad72c654bef02f1fa631efc37b"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a41f6d0ad72c654bef02f1fa631efc37b"><td class="memTemplItemLeft" align="right" valign="top">TLine &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a41f6d0ad72c654bef02f1fa631efc37b">DrawHLine</a> (const double &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:a41f6d0ad72c654bef02f1fa631efc37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for drawing a horizontal line across pad  <a href="classusr_1_1plt_1_1Pad1D.html#a41f6d0ad72c654bef02f1fa631efc37b">More...</a><br /></td></tr>
<tr class="separator:a41f6d0ad72c654bef02f1fa631efc37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4279640d7943bcb7b307ca8696e1e430"><td class="memItemLeft" align="right" valign="top">TLine &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a4279640d7943bcb7b307ca8696e1e430">DrawVLine</a> (const double &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a4279640d7943bcb7b307ca8696e1e430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for drawing a vertical along in the pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a4279640d7943bcb7b307ca8696e1e430">More...</a><br /></td></tr>
<tr class="separator:a4279640d7943bcb7b307ca8696e1e430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359856570e93dee949ce9d4a61325efe"><td class="memItemLeft" align="right" valign="top">TLine &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a359856570e93dee949ce9d4a61325efe">DrawVLine</a> (const double &amp;x)</td></tr>
<tr class="memdesc:a359856570e93dee949ce9d4a61325efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for drawing a vertical along in the pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a359856570e93dee949ce9d4a61325efe">More...</a><br /></td></tr>
<tr class="separator:a359856570e93dee949ce9d4a61325efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe95b06b2bbe76cabd7cb7bed7b6f175"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:abe95b06b2bbe76cabd7cb7bed7b6f175"><td class="memTemplItemLeft" align="right" valign="top">TLine &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#abe95b06b2bbe76cabd7cb7bed7b6f175">DrawVLine</a> (const double &amp;x, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="memdesc:abe95b06b2bbe76cabd7cb7bed7b6f175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for drawing a vertical along in the pad.  <a href="classusr_1_1plt_1_1Pad1D.html#abe95b06b2bbe76cabd7cb7bed7b6f175">More...</a><br /></td></tr>
<tr class="separator:abe95b06b2bbe76cabd7cb7bed7b6f175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6286bbdce471b0378338fc95190907ca"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a6286bbdce471b0378338fc95190907ca">InnerTextLeft</a> () const</td></tr>
<tr class="memdesc:a6286bbdce471b0378338fc95190907ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a nice text placement in the corner of a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a6286bbdce471b0378338fc95190907ca">More...</a><br /></td></tr>
<tr class="separator:a6286bbdce471b0378338fc95190907ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bf50474fde6627ad6d48b7ee922ff6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#af7bf50474fde6627ad6d48b7ee922ff6">InnerTextRight</a> () const</td></tr>
<tr class="memdesc:af7bf50474fde6627ad6d48b7ee922ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a nice text placement in the corner of a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#af7bf50474fde6627ad6d48b7ee922ff6">More...</a><br /></td></tr>
<tr class="separator:af7bf50474fde6627ad6d48b7ee922ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946d2b424e5aaac84bba84aaa2074a30"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a946d2b424e5aaac84bba84aaa2074a30">InnerTextHCenter</a> () const</td></tr>
<tr class="memdesc:a946d2b424e5aaac84bba84aaa2074a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a nice text placement in the corner of a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a946d2b424e5aaac84bba84aaa2074a30">More...</a><br /></td></tr>
<tr class="separator:a946d2b424e5aaac84bba84aaa2074a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30baf303503eda0f94b89f353217118c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a30baf303503eda0f94b89f353217118c">InnerTextTop</a> () const</td></tr>
<tr class="memdesc:a30baf303503eda0f94b89f353217118c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a nice text placement in the corner of a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a30baf303503eda0f94b89f353217118c">More...</a><br /></td></tr>
<tr class="separator:a30baf303503eda0f94b89f353217118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d8a49d9e508226751a37a6e6dc6333"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#af4d8a49d9e508226751a37a6e6dc6333">InnerTextBottom</a> () const</td></tr>
<tr class="memdesc:af4d8a49d9e508226751a37a6e6dc6333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a nice text placement in the corner of a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#af4d8a49d9e508226751a37a6e6dc6333">More...</a><br /></td></tr>
<tr class="separator:af4d8a49d9e508226751a37a6e6dc6333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395ff1f9fc7969fe0a8a850fcb38da4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a3395ff1f9fc7969fe0a8a850fcb38da4">InnerTextVCenter</a> () const</td></tr>
<tr class="memdesc:a3395ff1f9fc7969fe0a8a850fcb38da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a nice text placement in the corner of a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a3395ff1f9fc7969fe0a8a850fcb38da4">More...</a><br /></td></tr>
<tr class="separator:a3395ff1f9fc7969fe0a8a850fcb38da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6224af08976efa4c106729a661989176"><td class="memItemLeft" align="right" valign="top"><a id="a6224af08976efa4c106729a661989176"></a>
TAxis &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a6224af08976efa4c106729a661989176">Xaxis</a> ()</td></tr>
<tr class="memdesc:a6224af08976efa4c106729a661989176"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference interface for getting axis (No null pointer handling) <br /></td></tr>
<tr class="separator:a6224af08976efa4c106729a661989176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f28364fff0ed0f0778b1229cd7c3ee"><td class="memItemLeft" align="right" valign="top"><a id="a97f28364fff0ed0f0778b1229cd7c3ee"></a>
TAxis &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a97f28364fff0ed0f0778b1229cd7c3ee">Yaxis</a> ()</td></tr>
<tr class="memdesc:a97f28364fff0ed0f0778b1229cd7c3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference interface for getting axis (No null pointer handling) <br /></td></tr>
<tr class="separator:a97f28364fff0ed0f0778b1229cd7c3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955bb184e8d4f44a9af6cdcfdb250995"><td class="memItemLeft" align="right" valign="top"><a id="a955bb184e8d4f44a9af6cdcfdb250995"></a>
const TAxis &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a955bb184e8d4f44a9af6cdcfdb250995">Xaxis</a> () const</td></tr>
<tr class="memdesc:a955bb184e8d4f44a9af6cdcfdb250995"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference interface for getting axis (No null pointer handling) <br /></td></tr>
<tr class="separator:a955bb184e8d4f44a9af6cdcfdb250995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284d59905ad4a5cf9034b8bab217a099"><td class="memItemLeft" align="right" valign="top"><a id="a284d59905ad4a5cf9034b8bab217a099"></a>
const TAxis &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a284d59905ad4a5cf9034b8bab217a099">Yaxis</a> () const</td></tr>
<tr class="memdesc:a284d59905ad4a5cf9034b8bab217a099"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference interface for getting axis (No null pointer handling) <br /></td></tr>
<tr class="separator:a284d59905ad4a5cf9034b8bab217a099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa722786ec11f8fe96d2d128d7cc303ef"><td class="memItemLeft" align="right" valign="top">TAxis *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aa722786ec11f8fe96d2d128d7cc303ef">GetXaxis</a> () const</td></tr>
<tr class="memdesc:aa722786ec11f8fe96d2d128d7cc303ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning pointer to axis object.  <a href="classusr_1_1plt_1_1Pad1D.html#aa722786ec11f8fe96d2d128d7cc303ef">More...</a><br /></td></tr>
<tr class="separator:aa722786ec11f8fe96d2d128d7cc303ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede7804ba18387cf9d63bef0e66e8ddc"><td class="memItemLeft" align="right" valign="top">TAxis *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aede7804ba18387cf9d63bef0e66e8ddc">GetYaxis</a> () const</td></tr>
<tr class="memdesc:aede7804ba18387cf9d63bef0e66e8ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returning pointer to axis object.  <a href="classusr_1_1plt_1_1Pad1D.html#aede7804ba18387cf9d63bef0e66e8ddc">More...</a><br /></td></tr>
<tr class="separator:aede7804ba18387cf9d63bef0e66e8ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adb9802740020ad1d8fdfad1472385945"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#adb9802740020ad1d8fdfad1472385945">GetDataMax</a> () const</td></tr>
<tr class="memdesc:adb9802740020ad1d8fdfad1472385945"><td class="mdescLeft">&#160;</td><td class="mdescRight">getting tracked y limit of data.  <a href="classusr_1_1plt_1_1Pad1D.html#adb9802740020ad1d8fdfad1472385945">More...</a><br /></td></tr>
<tr class="separator:adb9802740020ad1d8fdfad1472385945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184073003b7517d947a2cbb3e6e6c8f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a184073003b7517d947a2cbb3e6e6c8f8">GetDataMin</a> () const</td></tr>
<tr class="memdesc:a184073003b7517d947a2cbb3e6e6c8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">getting tracked y limit of data.  <a href="classusr_1_1plt_1_1Pad1D.html#a184073003b7517d947a2cbb3e6e6c8f8">More...</a><br /></td></tr>
<tr class="separator:a184073003b7517d947a2cbb3e6e6c8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab83eab10892672a673fc71e5d82fe874"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ab83eab10892672a673fc71e5d82fe874">GetXaxisMin</a> () const</td></tr>
<tr class="memdesc:ab83eab10892672a673fc71e5d82fe874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the x axis limits.  <a href="classusr_1_1plt_1_1Pad1D.html#ab83eab10892672a673fc71e5d82fe874">More...</a><br /></td></tr>
<tr class="separator:ab83eab10892672a673fc71e5d82fe874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09dd2fe7e34d51114bc27dca7c9b5e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a4f09dd2fe7e34d51114bc27dca7c9b5e">GetXaxisMax</a> () const</td></tr>
<tr class="memdesc:a4f09dd2fe7e34d51114bc27dca7c9b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the x axis limits.  <a href="classusr_1_1plt_1_1Pad1D.html#a4f09dd2fe7e34d51114bc27dca7c9b5e">More...</a><br /></td></tr>
<tr class="separator:a4f09dd2fe7e34d51114bc27dca7c9b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a315fdee802c6a640821c8a96bf4cf4b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a315fdee802c6a640821c8a96bf4cf4b0">GetYaxisMax</a> () const</td></tr>
<tr class="memdesc:a315fdee802c6a640821c8a96bf4cf4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting y axis limit.  <a href="classusr_1_1plt_1_1Pad1D.html#a315fdee802c6a640821c8a96bf4cf4b0">More...</a><br /></td></tr>
<tr class="separator:a315fdee802c6a640821c8a96bf4cf4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040f3fe32f6444fcd5deb4109a1ccf05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a040f3fe32f6444fcd5deb4109a1ccf05">GetYaxisMin</a> () const</td></tr>
<tr class="memdesc:a040f3fe32f6444fcd5deb4109a1ccf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting y axis limit.  <a href="classusr_1_1plt_1_1Pad1D.html#a040f3fe32f6444fcd5deb4109a1ccf05">More...</a><br /></td></tr>
<tr class="separator:a040f3fe32f6444fcd5deb4109a1ccf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aca0e9e6623384c841c90e676ba1d6ab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aca0e9e6623384c841c90e676ba1d6ab2">SetYaxisMax</a> (const double)</td></tr>
<tr class="memdesc:aca0e9e6623384c841c90e676ba1d6ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting y axis limit.  <a href="classusr_1_1plt_1_1Pad1D.html#aca0e9e6623384c841c90e676ba1d6ab2">More...</a><br /></td></tr>
<tr class="separator:aca0e9e6623384c841c90e676ba1d6ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cdde2371a935be70db081336966eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a30cdde2371a935be70db081336966eed">SetYaxisMin</a> (const double)</td></tr>
<tr class="memdesc:a30cdde2371a935be70db081336966eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting y axis limit.  <a href="classusr_1_1plt_1_1Pad1D.html#a30cdde2371a935be70db081336966eed">More...</a><br /></td></tr>
<tr class="separator:a30cdde2371a935be70db081336966eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae52990ae3e46775c4b40bcc87b045d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae52990ae3e46775c4b40bcc87b045d72">SetDataMax</a> (const double)</td></tr>
<tr class="memdesc:ae52990ae3e46775c4b40bcc87b045d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually overriding the stored y limit of data.  <a href="classusr_1_1plt_1_1Pad1D.html#ae52990ae3e46775c4b40bcc87b045d72">More...</a><br /></td></tr>
<tr class="separator:ae52990ae3e46775c4b40bcc87b045d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb86474ca1adcbd4c2d7ecf263aed4da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#abb86474ca1adcbd4c2d7ecf263aed4da">SetDataMin</a> (const double)</td></tr>
<tr class="memdesc:abb86474ca1adcbd4c2d7ecf263aed4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually overriding the stored y limit of data.  <a href="classusr_1_1plt_1_1Pad1D.html#abb86474ca1adcbd4c2d7ecf263aed4da">More...</a><br /></td></tr>
<tr class="separator:abb86474ca1adcbd4c2d7ecf263aed4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classusr_1_1plt_1_1PadBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classusr_1_1plt_1_1PadBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classusr_1_1plt_1_1PadBase.html">usr::plt::PadBase</a></td></tr>
<tr class="memitem:a7f55b5c7425cf36549fa5dc2258cc7e8 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a7f55b5c7425cf36549fa5dc2258cc7e8">~PadBase</a> ()</td></tr>
<tr class="separator:a7f55b5c7425cf36549fa5dc2258cc7e8 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e17a1d972bde423f8f6478c6524861 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a83e17a1d972bde423f8f6478c6524861"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PadBase</b> (const <a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;)=delete</td></tr>
<tr class="separator:a83e17a1d972bde423f8f6478c6524861 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45c672761e10f3ed026f3a1449ef7af inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="ac45c672761e10f3ed026f3a1449ef7af"></a>
<a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#ac45c672761e10f3ed026f3a1449ef7af">SetTextAlign</a> (const <a class="el" href="classusr_1_1plt_1_1font.html#a0356629488473f96e1de978c9180ef2a">font::align</a>)</td></tr>
<tr class="memdesc:ac45c672761e10f3ed026f3a1449ef7af inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually setting text alignment options. <br /></td></tr>
<tr class="separator:ac45c672761e10f3ed026f3a1449ef7af inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26e8940e656d5e5580bca19c5c8fbe inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a4a26e8940e656d5e5580bca19c5c8fbe"></a>
<a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>WriteLine</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a4a26e8940e656d5e5580bca19c5c8fbe inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e57b236ba14bedcd7ce79a879a612a inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memTemplParams" colspan="2"><a id="aa6e57b236ba14bedcd7ce79a879a612a"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aa6e57b236ba14bedcd7ce79a879a612a inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WriteLine</b> (const std::string &amp;str, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="separator:aa6e57b236ba14bedcd7ce79a879a612a inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d956c026f65089b07e9b2f57d406bfd inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a0d956c026f65089b07e9b2f57d406bfd"></a>
<a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a0d956c026f65089b07e9b2f57d406bfd">WriteAtData</a> (const double, const double, const std::string &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a0d956c026f65089b07e9b2f57d406bfd inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing latex text at data point. <br /></td></tr>
<tr class="separator:a0d956c026f65089b07e9b2f57d406bfd inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3899cd32159c067db3f5a1b6a1bce9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a8f3899cd32159c067db3f5a1b6a1bce9"></a>
<a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>WriteAtData</b> (const double x, const double y, const std::string &amp;str)</td></tr>
<tr class="separator:a8f3899cd32159c067db3f5a1b6a1bce9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eac8c8b06129f5cb9fd818dea888115 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memTemplParams" colspan="2"><a id="a0eac8c8b06129f5cb9fd818dea888115"></a>
template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a0eac8c8b06129f5cb9fd818dea888115 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WriteAtData</b> (const double x, const double y, const std::string &amp;str, const RooCmdArg &amp;arg1, Args ... args)</td></tr>
<tr class="separator:a0eac8c8b06129f5cb9fd818dea888115 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada457a73a1a38327303a6ffc9f19a6a2 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#ada457a73a1a38327303a6ffc9f19a6a2">PlotObj</a> (TObject &amp;, Option_t *=&quot;&quot;)</td></tr>
<tr class="memdesc:ada457a73a1a38327303a6ffc9f19a6a2 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to superseed the <code>TObject::Draw()</code> for generating plots.  <a href="classusr_1_1plt_1_1PadBase.html#ada457a73a1a38327303a6ffc9f19a6a2">More...</a><br /></td></tr>
<tr class="separator:ada457a73a1a38327303a6ffc9f19a6a2 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cb88e7b59ae654473c281609e3d758 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a39cb88e7b59ae654473c281609e3d758"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a39cb88e7b59ae654473c281609e3d758">PlotObj</a> (TObject *obj, Option_t *opt=&quot;&quot;)</td></tr>
<tr class="memdesc:a39cb88e7b59ae654473c281609e3d758 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer interface to PlotObj <br /></td></tr>
<tr class="separator:a39cb88e7b59ae654473c281609e3d758 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9ff95662b09fc15a684ce7f8a6b751 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a2b9ff95662b09fc15a684ce7f8a6b751"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasObject</b> (const TObject &amp;) const</td></tr>
<tr class="separator:a2b9ff95662b09fc15a684ce7f8a6b751 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef06c023448e3c1be9f4e7396acfd08c inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aef06c023448e3c1be9f4e7396acfd08c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasObject</b> (const TObject *obj) const</td></tr>
<tr class="separator:aef06c023448e3c1be9f4e7396acfd08c inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd68ff347ca1e8e2f213913576aa001 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memTemplParams" colspan="2">template&lt;typename ObjType , typename ... Args&gt; </td></tr>
<tr class="memitem:afdd68ff347ca1e8e2f213913576aa001 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memTemplItemLeft" align="right" valign="top">ObjType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#afdd68ff347ca1e8e2f213913576aa001">MakeObj</a> (Args ... args)</td></tr>
<tr class="separator:afdd68ff347ca1e8e2f213913576aa001 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f415006d7b9cf246deb14e0f79f7a4 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a37f415006d7b9cf246deb14e0f79f7a4">ClaimObject</a> (TObject *)</td></tr>
<tr class="memdesc:a37f415006d7b9cf246deb14e0f79f7a4 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allowing the Pad to claim ownership of some plot object.  <a href="classusr_1_1plt_1_1PadBase.html#a37f415006d7b9cf246deb14e0f79f7a4">More...</a><br /></td></tr>
<tr class="separator:a37f415006d7b9cf246deb14e0f79f7a4 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82374297b57c2aea6b07d552e9b78338 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a82374297b57c2aea6b07d552e9b78338">MoveTargetToBefore</a> (const TObject &amp;target, const TObject &amp;before)</td></tr>
<tr class="memdesc:a82374297b57c2aea6b07d552e9b78338 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moving a target object to before another object on the TPad.  <a href="classusr_1_1plt_1_1PadBase.html#a82374297b57c2aea6b07d552e9b78338">More...</a><br /></td></tr>
<tr class="separator:a82374297b57c2aea6b07d552e9b78338 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc407e60ce8632fecf4f343246bdbc inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aa8cc407e60ce8632fecf4f343246bdbc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFillColorAlpha</b> (const int x, const float y)</td></tr>
<tr class="separator:aa8cc407e60ce8632fecf4f343246bdbc inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c8d28e318184768bca4d721bf6f2b0 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a33c8d28e318184768bca4d721bf6f2b0">ParentCanvas</a> () const</td></tr>
<tr class="memdesc:a33c8d28e318184768bca4d721bf6f2b0 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning referece to parent canvas.  <a href="classusr_1_1plt_1_1PadBase.html#a33c8d28e318184768bca4d721bf6f2b0">More...</a><br /></td></tr>
<tr class="separator:a33c8d28e318184768bca4d721bf6f2b0 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85518917748deefb9e8c1ade2256c5c inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#ab85518917748deefb9e8c1ade2256c5c">ParentCanvas</a> ()</td></tr>
<tr class="memdesc:ab85518917748deefb9e8c1ade2256c5c inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning referece to parent canvas.  <a href="classusr_1_1plt_1_1PadBase.html#ab85518917748deefb9e8c1ade2256c5c">More...</a><br /></td></tr>
<tr class="separator:ab85518917748deefb9e8c1ade2256c5c inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d6749e8e8216190970c1277eb84b6a inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="af5d6749e8e8216190970c1277eb84b6a"></a>
const TPad &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>TPad_</b> () const</td></tr>
<tr class="separator:af5d6749e8e8216190970c1277eb84b6a inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffb628f462a6df204f974d5abb4b8b9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a4ffb628f462a6df204f974d5abb4b8b9"></a>
TPad &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>TPad_</b> ()</td></tr>
<tr class="separator:a4ffb628f462a6df204f974d5abb4b8b9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfabf6fb1a2a1df860d5555c4aadd11 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="afbfabf6fb1a2a1df860d5555c4aadd11"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#afbfabf6fb1a2a1df860d5555c4aadd11">RelWidth</a> () const</td></tr>
<tr class="memdesc:afbfabf6fb1a2a1df860d5555c4aadd11 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensions relative to the parent canvas. <br /></td></tr>
<tr class="separator:afbfabf6fb1a2a1df860d5555c4aadd11 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8877d2c461de1436531f85a0bffaa9b inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aa8877d2c461de1436531f85a0bffaa9b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#aa8877d2c461de1436531f85a0bffaa9b">RelHeight</a> () const</td></tr>
<tr class="memdesc:aa8877d2c461de1436531f85a0bffaa9b inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensions relative to the parent canvas. <br /></td></tr>
<tr class="separator:aa8877d2c461de1436531f85a0bffaa9b inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48f1274d7ff9716d9e28558b955513 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a3d48f1274d7ff9716d9e28558b955513"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a3d48f1274d7ff9716d9e28558b955513">AbsWidth</a> () const</td></tr>
<tr class="memdesc:a3d48f1274d7ff9716d9e28558b955513 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute dimensions of the pad. <br /></td></tr>
<tr class="separator:a3d48f1274d7ff9716d9e28558b955513 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b43e2ee33b0a9640aaeb5dd6bcd6189 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a0b43e2ee33b0a9640aaeb5dd6bcd6189"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a0b43e2ee33b0a9640aaeb5dd6bcd6189">AbsHeight</a> () const</td></tr>
<tr class="memdesc:a0b43e2ee33b0a9640aaeb5dd6bcd6189 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute dimensions of the pad. <br /></td></tr>
<tr class="separator:a0b43e2ee33b0a9640aaeb5dd6bcd6189 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1457e75e905131243920bd3419f0744d inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a1457e75e905131243920bd3419f0744d"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a1457e75e905131243920bd3419f0744d">FontSize</a> () const</td></tr>
<tr class="memdesc:a1457e75e905131243920bd3419f0744d inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the font setting in the parent canvas. <br /></td></tr>
<tr class="separator:a1457e75e905131243920bd3419f0744d inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd2b5977b2d45a58c94f81971c51d79 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aacd2b5977b2d45a58c94f81971c51d79"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#aacd2b5977b2d45a58c94f81971c51d79">FontFace</a> () const</td></tr>
<tr class="memdesc:aacd2b5977b2d45a58c94f81971c51d79 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the font setting in the parent canvas. <br /></td></tr>
<tr class="separator:aacd2b5977b2d45a58c94f81971c51d79 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444bbeb5e3ee34fc7f0b115348cd20b4 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a444bbeb5e3ee34fc7f0b115348cd20b4"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a444bbeb5e3ee34fc7f0b115348cd20b4">LineHeight</a> () const</td></tr>
<tr class="memdesc:a444bbeb5e3ee34fc7f0b115348cd20b4 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the font setting in the parent canvas. <br /></td></tr>
<tr class="separator:a444bbeb5e3ee34fc7f0b115348cd20b4 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39056266b868db6ce2e8fe8b13f1e287 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a39056266b868db6ce2e8fe8b13f1e287"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a39056266b868db6ce2e8fe8b13f1e287">RelTextHeight</a> () const</td></tr>
<tr class="memdesc:a39056266b868db6ce2e8fe8b13f1e287 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">font settings relative to the pad dimensions. <br /></td></tr>
<tr class="separator:a39056266b868db6ce2e8fe8b13f1e287 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272f7a644055fa56ee75804040707d0 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a5272f7a644055fa56ee75804040707d0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a5272f7a644055fa56ee75804040707d0">RelLineHeight</a> () const</td></tr>
<tr class="memdesc:a5272f7a644055fa56ee75804040707d0 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">font settings relative to the pad dimensions. <br /></td></tr>
<tr class="separator:a5272f7a644055fa56ee75804040707d0 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a222e520ba89dc6e00ec0d0acc8972 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a41a222e520ba89dc6e00ec0d0acc8972">SetTextCursor</a> (const double, const double)</td></tr>
<tr class="memdesc:a41a222e520ba89dc6e00ec0d0acc8972 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing text a designated cursor position.  <a href="classusr_1_1plt_1_1PadBase.html#a41a222e520ba89dc6e00ec0d0acc8972">More...</a><br /></td></tr>
<tr class="separator:a41a222e520ba89dc6e00ec0d0acc8972 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faf9627393e23d615e8c3bf5cc688d9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a6faf9627393e23d615e8c3bf5cc688d9">SetTextCursor</a> (const double, const double, const <a class="el" href="classusr_1_1plt_1_1font.html#a0356629488473f96e1de978c9180ef2a">font::align</a>)</td></tr>
<tr class="memdesc:a6faf9627393e23d615e8c3bf5cc688d9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing text a designated cursor position.  <a href="classusr_1_1plt_1_1PadBase.html#a6faf9627393e23d615e8c3bf5cc688d9">More...</a><br /></td></tr>
<tr class="separator:a6faf9627393e23d615e8c3bf5cc688d9 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f530ac7f6aeee4b2bdf6465548f9ec inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classusr_1_1plt_1_1PadBase.html">PadBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a18f530ac7f6aeee4b2bdf6465548f9ec">WriteLine</a> (const std::string &amp;, const std::vector&lt; RooCmdArg &gt; &amp;)</td></tr>
<tr class="memdesc:a18f530ac7f6aeee4b2bdf6465548f9ec inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing text a designated cursor position.  <a href="classusr_1_1plt_1_1PadBase.html#a18f530ac7f6aeee4b2bdf6465548f9ec">More...</a><br /></td></tr>
<tr class="separator:a18f530ac7f6aeee4b2bdf6465548f9ec inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990fc425143f3cf0ecccd5edc930d95e inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a990fc425143f3cf0ecccd5edc930d95e"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a990fc425143f3cf0ecccd5edc930d95e">GetTopMargin</a> () const</td></tr>
<tr class="memdesc:a990fc425143f3cf0ecccd5edc930d95e inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:a990fc425143f3cf0ecccd5edc930d95e inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c70d58a548fb9175623007b5a4d46b8 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a5c70d58a548fb9175623007b5a4d46b8"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a5c70d58a548fb9175623007b5a4d46b8">GetLeftMargin</a> () const</td></tr>
<tr class="memdesc:a5c70d58a548fb9175623007b5a4d46b8 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:a5c70d58a548fb9175623007b5a4d46b8 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ecd0e642c3b5c85a3120eeecceb495 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="af2ecd0e642c3b5c85a3120eeecceb495"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#af2ecd0e642c3b5c85a3120eeecceb495">GetRightMargin</a> () const</td></tr>
<tr class="memdesc:af2ecd0e642c3b5c85a3120eeecceb495 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:af2ecd0e642c3b5c85a3120eeecceb495 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b98665efe3b04de6b59785c38516d2 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a61b98665efe3b04de6b59785c38516d2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a61b98665efe3b04de6b59785c38516d2">GetBottomMargin</a> () const</td></tr>
<tr class="memdesc:a61b98665efe3b04de6b59785c38516d2 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:a61b98665efe3b04de6b59785c38516d2 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9adbf76693de6f6a792e40c42eec43d inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="ab9adbf76693de6f6a792e40c42eec43d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#ab9adbf76693de6f6a792e40c42eec43d">SetTopMargin</a> (const float x)</td></tr>
<tr class="memdesc:ab9adbf76693de6f6a792e40c42eec43d inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:ab9adbf76693de6f6a792e40c42eec43d inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e61ba7e28cff0f14528422c489805 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a187e61ba7e28cff0f14528422c489805"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a187e61ba7e28cff0f14528422c489805">SetLeftMargin</a> (const float x)</td></tr>
<tr class="memdesc:a187e61ba7e28cff0f14528422c489805 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:a187e61ba7e28cff0f14528422c489805 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446e8dc2b68afd16f1b24696ffcc63a5 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a446e8dc2b68afd16f1b24696ffcc63a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a446e8dc2b68afd16f1b24696ffcc63a5">SetRightMargin</a> (const float x)</td></tr>
<tr class="memdesc:a446e8dc2b68afd16f1b24696ffcc63a5 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:a446e8dc2b68afd16f1b24696ffcc63a5 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6df3cfda1bbfda5c6c0805e77c2cc1 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a6d6df3cfda1bbfda5c6c0805e77c2cc1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a6d6df3cfda1bbfda5c6c0805e77c2cc1">SetBottomMargin</a> (const float x)</td></tr>
<tr class="memdesc:a6d6df3cfda1bbfda5c6c0805e77c2cc1 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-through interface for Margin control. <br /></td></tr>
<tr class="separator:a6d6df3cfda1bbfda5c6c0805e77c2cc1 inherit pub_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8d6974d40a82ec22e24694bcab2b30f0"><td class="memItemLeft" align="right" valign="top"><a id="a8d6974d40a82ec22e24694bcab2b30f0"></a>
static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8d6974d40a82ec22e24694bcab2b30f0">autobinwidth</a> = -1</td></tr>
<tr class="memdesc:a8d6974d40a82ec22e24694bcab2b30f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">static flag for bin-width determination. <br /></td></tr>
<tr class="separator:a8d6974d40a82ec22e24694bcab2b30f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32c88ea1025be2f846a0dae66998429"><td class="memItemLeft" align="right" valign="top"><a id="ae32c88ea1025be2f846a0dae66998429"></a>
static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae32c88ea1025be2f846a0dae66998429">forcevarbinwidth</a> = 0</td></tr>
<tr class="memdesc:ae32c88ea1025be2f846a0dae66998429"><td class="mdescLeft">&#160;</td><td class="mdescRight">static flag for forcing the variable bin-width scheme. <br /></td></tr>
<tr class="separator:ae32c88ea1025be2f846a0dae66998429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0f1de81ce7a5fb1cf145fee91955180d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a0f1de81ce7a5fb1cf145fee91955180d">Pad1D</a> (<a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *, const <a class="el" href="structusr_1_1plt_1_1PadSize.html">PadSize</a> &amp;, const <a class="el" href="structusr_1_1plt_1_1RangeByVar.html">RangeByVar</a> &amp;)</td></tr>
<tr class="memdesc:a0f1de81ce7a5fb1cf145fee91955180d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing a <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> using a <a href="https://root.cern.ch/doc/master/classRooRealVar.html">RooRealVar</a>  <a href="classusr_1_1plt_1_1Pad1D.html#a0f1de81ce7a5fb1cf145fee91955180d">More...</a><br /></td></tr>
<tr class="separator:a0f1de81ce7a5fb1cf145fee91955180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90d0506e975f5a12fb90ca9403c36fb"><td class="memItemLeft" align="right" valign="top"><a id="aa90d0506e975f5a12fb90ca9403c36fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#aa90d0506e975f5a12fb90ca9403c36fb">Pad1D</a> (<a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *, const <a class="el" href="structusr_1_1plt_1_1PadSize.html">PadSize</a> &amp;, const double min, const double max)</td></tr>
<tr class="memdesc:aa90d0506e975f5a12fb90ca9403c36fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> with a limit x range. <br /></td></tr>
<tr class="separator:aa90d0506e975f5a12fb90ca9403c36fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ed6af673bf0a6188705c6a014eb98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a352ed6af673bf0a6188705c6a014eb98">Pad1D</a> (<a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *, const <a class="el" href="structusr_1_1plt_1_1PadSize.html">PadSize</a> &amp;)</td></tr>
<tr class="memdesc:a352ed6af673bf0a6188705c6a014eb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> with only dimension specifications.  <a href="classusr_1_1plt_1_1Pad1D.html#a352ed6af673bf0a6188705c6a014eb98">More...</a><br /></td></tr>
<tr class="separator:a352ed6af673bf0a6188705c6a014eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009a13deb1306cf370785b602533739f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a009a13deb1306cf370785b602533739f">InitDraw</a> ()</td></tr>
<tr class="memdesc:a009a13deb1306cf370785b602533739f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional routines after pad spawning.  <a href="classusr_1_1plt_1_1Pad1D.html#a009a13deb1306cf370785b602533739f">More...</a><br /></td></tr>
<tr class="separator:a009a13deb1306cf370785b602533739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4299da435d73d91ce3f872d625324d58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a4299da435d73d91ce3f872d625324d58">Finalize</a> ()</td></tr>
<tr class="memdesc:a4299da435d73d91ce3f872d625324d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">additional steps before canvas saving.  <a href="classusr_1_1plt_1_1Pad1D.html#a4299da435d73d91ce3f872d625324d58">More...</a><br /></td></tr>
<tr class="separator:a4299da435d73d91ce3f872d625324d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b18db0d1bf7925ddbef5f2d64f55a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ac2b18db0d1bf7925ddbef5f2d64f55a1">AutoSetYRangeHist</a> ()</td></tr>
<tr class="memdesc:ac2b18db0d1bf7925ddbef5f2d64f55a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y range setting optimized for histogram data presentation.  <a href="classusr_1_1plt_1_1Pad1D.html#ac2b18db0d1bf7925ddbef5f2d64f55a1">More...</a><br /></td></tr>
<tr class="separator:ac2b18db0d1bf7925ddbef5f2d64f55a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5ef30071be090a0b34b3657ebd7151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a1f5ef30071be090a0b34b3657ebd7151">AutoSetYRangeGraph</a> ()</td></tr>
<tr class="memdesc:a1f5ef30071be090a0b34b3657ebd7151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y axis range setting optimized for scatter data presentation.  <a href="classusr_1_1plt_1_1Pad1D.html#a1f5ef30071be090a0b34b3657ebd7151">More...</a><br /></td></tr>
<tr class="separator:a1f5ef30071be090a0b34b3657ebd7151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037acd167dddd7224e486eea6e94dcb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a037acd167dddd7224e486eea6e94dcb4">AutoSetYRangeRatio</a> ()</td></tr>
<tr class="memdesc:a037acd167dddd7224e486eea6e94dcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y axis range setting optimized for data ratio comparison.  <a href="classusr_1_1plt_1_1Pad1D.html#a037acd167dddd7224e486eea6e94dcb4">More...</a><br /></td></tr>
<tr class="separator:a037acd167dddd7224e486eea6e94dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f89f62fc327fb3da36e549e392699c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a1f89f62fc327fb3da36e549e392699c0">AutoSetYRangePull</a> ()</td></tr>
<tr class="memdesc:a1f89f62fc327fb3da36e549e392699c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Y axis range setting optimized for pull results comparison.  <a href="classusr_1_1plt_1_1Pad1D.html#a1f89f62fc327fb3da36e549e392699c0">More...</a><br /></td></tr>
<tr class="separator:a1f89f62fc327fb3da36e549e392699c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbae52a4871ef8cbf546ed86d2ecc4b5"><td class="memItemLeft" align="right" valign="top"><a id="abbae52a4871ef8cbf546ed86d2ecc4b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#abbae52a4871ef8cbf546ed86d2ecc4b5">FixVLines</a> ()</td></tr>
<tr class="memdesc:abbae52a4871ef8cbf546ed86d2ecc4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the vertical lines according to the data plotted on the pad. <br /></td></tr>
<tr class="separator:abbae52a4871ef8cbf546ed86d2ecc4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06abe815599e0c66ecdc57f588ce6e3e"><td class="memItemLeft" align="right" valign="top"><a id="a06abe815599e0c66ecdc57f588ce6e3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a06abe815599e0c66ecdc57f588ce6e3e">_init_legend</a> ()</td></tr>
<tr class="memdesc:a06abe815599e0c66ecdc57f588ce6e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legend creation with consistent font settings. Plotting immediate to have the object booked under the Pads list of primitives. <br /></td></tr>
<tr class="separator:a06abe815599e0c66ecdc57f588ce6e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b89008af5334081e44d4c48a364515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#af6b89008af5334081e44d4c48a364515">AddLegendEntry</a> (TH1D &amp;, const RooCmdArg &amp;, const RooCmdArg &amp;)</td></tr>
<tr class="memdesc:af6b89008af5334081e44d4c48a364515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding legend entry for a histogram object.  <a href="classusr_1_1plt_1_1Pad1D.html#af6b89008af5334081e44d4c48a364515">More...</a><br /></td></tr>
<tr class="separator:af6b89008af5334081e44d4c48a364515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858893552cebe6479e905d803b710f85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a858893552cebe6479e905d803b710f85">AddLegendEntry</a> (TGraph &amp;, const RooCmdArg &amp;, const RooCmdArg &amp;)</td></tr>
<tr class="separator:a858893552cebe6479e905d803b710f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2873892633ea51409c43d5e1974e898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae2873892633ea51409c43d5e1974e898">AddLegendEntry</a> (TEfficiency &amp;, const RooCmdArg &amp;, const RooCmdArg &amp;)</td></tr>
<tr class="memdesc:ae2873892633ea51409c43d5e1974e898"><td class="mdescLeft">&#160;</td><td class="mdescRight">adding legend entry for TEfficiency object.  <a href="classusr_1_1plt_1_1Pad1D.html#ae2873892633ea51409c43d5e1974e898">More...</a><br /></td></tr>
<tr class="separator:ae2873892633ea51409c43d5e1974e898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30055693800662b5035100e2e601e5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad30055693800662b5035100e2e601e5f">TrackObjectY</a> (const TObject &amp;obj, const int <a class="el" href="group__PlotUtilsArgument.html#ga9d8b6ab04917cc082bf20a35dfe915b5">tracky</a>)</td></tr>
<tr class="memdesc:ad30055693800662b5035100e2e601e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the stored _datamin, and _datamax variable according to object.  <a href="classusr_1_1plt_1_1Pad1D.html#ad30055693800662b5035100e2e601e5f">More...</a><br /></td></tr>
<tr class="separator:ad30055693800662b5035100e2e601e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ce99e1ffd88c5221601096dd899b1"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a9d4ce99e1ffd88c5221601096dd899b1">MakePdfGraph</a> (RooAbsPdf &amp;pdf, const <a class="el" href="classusr_1_1RooArgContainer.html">RooArgContainer</a> &amp;arglist)</td></tr>
<tr class="memdesc:a9d4ce99e1ffd88c5221601096dd899b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for generating a TGraph representation of a RooAbsPdf plot.  <a href="classusr_1_1plt_1_1Pad1D.html#a9d4ce99e1ffd88c5221601096dd899b1">More...</a><br /></td></tr>
<tr class="separator:a9d4ce99e1ffd88c5221601096dd899b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a77f21450b22c4f2f72ff41bf38a06"><td class="memItemLeft" align="right" valign="top"><a id="a75a77f21450b22c4f2f72ff41bf38a06"></a>
TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a75a77f21450b22c4f2f72ff41bf38a06">MakeTF1Graph</a> (TF1 &amp;, const <a class="el" href="classusr_1_1RooArgContainer.html">RooArgContainer</a> &amp;arglist)</td></tr>
<tr class="memdesc:a75a77f21450b22c4f2f72ff41bf38a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating a graph representation of the TF1 object. <br /></td></tr>
<tr class="separator:a75a77f21450b22c4f2f72ff41bf38a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae475e3f98744af74f5311d7e9bc8b084"><td class="memItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ae475e3f98744af74f5311d7e9bc8b084">MakeDataGraph</a> (RooAbsData &amp;data, const <a class="el" href="classusr_1_1RooArgContainer.html">RooArgContainer</a> &amp;arglist)</td></tr>
<tr class="memdesc:ae475e3f98744af74f5311d7e9bc8b084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for generating the a TGraph representing a RooAbsData plot.  <a href="classusr_1_1plt_1_1Pad1D.html#ae475e3f98744af74f5311d7e9bc8b084">More...</a><br /></td></tr>
<tr class="separator:ae475e3f98744af74f5311d7e9bc8b084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adb9a13f09641b64d845dcddc65c163"><td class="memItemLeft" align="right" valign="top">TGraphAsymmErrors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a3adb9a13f09641b64d845dcddc65c163">GenGraph</a> (RooAbsData &amp;data, RooLinkedList &amp;arglist)</td></tr>
<tr class="memdesc:a3adb9a13f09641b64d845dcddc65c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for generating RooAbsData plots onto a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#a3adb9a13f09641b64d845dcddc65c163">More...</a><br /></td></tr>
<tr class="separator:a3adb9a13f09641b64d845dcddc65c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa11c06bc2f95bdff624a3b9806e1bd5"><td class="memItemLeft" align="right" valign="top">TGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#afa11c06bc2f95bdff624a3b9806e1bd5">GenGraph</a> (RooAbsPdf &amp;pdf, RooLinkedList &amp;arglist)</td></tr>
<tr class="memdesc:afa11c06bc2f95bdff624a3b9806e1bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for generating RooAbsPdf plots onto a Pad.  <a href="classusr_1_1plt_1_1Pad1D.html#afa11c06bc2f95bdff624a3b9806e1bd5">More...</a><br /></td></tr>
<tr class="separator:afa11c06bc2f95bdff624a3b9806e1bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90eefa579442355eed869d501c6b912"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ac90eefa579442355eed869d501c6b912">CheckLogy</a> () const</td></tr>
<tr class="memdesc:ac90eefa579442355eed869d501c6b912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking if the data in the plot objects are positive definite.  <a href="classusr_1_1plt_1_1Pad1D.html#ac90eefa579442355eed869d501c6b912">More...</a><br /></td></tr>
<tr class="separator:ac90eefa579442355eed869d501c6b912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ccd9bdca1e9c6f24a2b40d28d1a47"><td class="memItemLeft" align="right" valign="top"><a id="a8e4ccd9bdca1e9c6f24a2b40d28d1a47"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckLogx</b> () const</td></tr>
<tr class="separator:a8e4ccd9bdca1e9c6f24a2b40d28d1a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classusr_1_1plt_1_1PadBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classusr_1_1plt_1_1PadBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classusr_1_1plt_1_1PadBase.html">usr::plt::PadBase</a></td></tr>
<tr class="memitem:a7979f842994e3a97bdad63c0b32dac5a inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a7979f842994e3a97bdad63c0b32dac5a">PadBase</a> (<a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *, const <a class="el" href="structusr_1_1plt_1_1PadSize.html">PadSize</a> &amp;)</td></tr>
<tr class="memdesc:a7979f842994e3a97bdad63c0b32dac5a inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of the new pad object requires the new wrapper class <a class="el" href="structusr_1_1plt_1_1PadSize.html" title="A constructor helper class for Pad objects.">PadSize</a>.  <a href="classusr_1_1plt_1_1PadBase.html#a7979f842994e3a97bdad63c0b32dac5a">More...</a><br /></td></tr>
<tr class="separator:a7979f842994e3a97bdad63c0b32dac5a inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679062202c69abe2b50d07a5e6323a4a inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a679062202c69abe2b50d07a5e6323a4a"></a>
const <a class="el" href="classusr_1_1plt.html#ae22b321ed2ac10245bb71031aa268431">FontSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a679062202c69abe2b50d07a5e6323a4a">Font</a> () const</td></tr>
<tr class="memdesc:a679062202c69abe2b50d07a5e6323a4a inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning reference to the font settings stored in the parent canvas. <br /></td></tr>
<tr class="separator:a679062202c69abe2b50d07a5e6323a4a inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba669e9f6c857f81316feb2a2312958 inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aaba669e9f6c857f81316feb2a2312958"></a>
TList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#aaba669e9f6c857f81316feb2a2312958">GetListOfPrimitives</a> () const</td></tr>
<tr class="memdesc:aaba669e9f6c857f81316feb2a2312958 inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the list of objects to be plotted on the pad. <br /></td></tr>
<tr class="separator:aaba669e9f6c857f81316feb2a2312958 inherit pro_methods_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a0fcdb4ed40ed7d7ffb4c0906810513d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a0fcdb4ed40ed7d7ffb4c0906810513d7">SetAxisTitle</a> (TAxis &amp;, const std::string &amp;title, const std::string &amp;unit=&quot;&quot;)</td></tr>
<tr class="memdesc:a0fcdb4ed40ed7d7ffb4c0906810513d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">setting axis title according to given unit.  <a href="classusr_1_1plt_1_1Pad1D.html#a0fcdb4ed40ed7d7ffb4c0906810513d7">More...</a><br /></td></tr>
<tr class="separator:a0fcdb4ed40ed7d7ffb4c0906810513d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adb11c96327a6267fd4ab4d356041bc32"><td class="memItemLeft" align="right" valign="top"><a id="adb11c96327a6267fd4ab4d356041bc32"></a>
<a class="el" href="classusr_1_1plt_1_1RooFrame.html">RooFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#adb11c96327a6267fd4ab4d356041bc32">_frame</a></td></tr>
<tr class="memdesc:adb11c96327a6267fd4ab4d356041bc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">RooPlot object used for generating graphs for ROOFIT objects. <br /></td></tr>
<tr class="separator:adb11c96327a6267fd4ab4d356041bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aa6311fc0ae85840130079dade951d"><td class="memItemLeft" align="right" valign="top"><a id="a03aa6311fc0ae85840130079dade951d"></a>
THStack *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a03aa6311fc0ae85840130079dade951d">_workingstack</a></td></tr>
<tr class="memdesc:a03aa6311fc0ae85840130079dade951d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a href="https://root.cern.ch/doc/master/classTHStack.html">THStack</a> object for assisting with stacked histogram plots. <br /></td></tr>
<tr class="separator:a03aa6311fc0ae85840130079dade951d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd35e1657be4b84a80f98db4da87846"><td class="memItemLeft" align="right" valign="top"><a id="abbd35e1657be4b84a80f98db4da87846"></a>
<a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8abc92e4404a07ea4fafd8ee4a5441eb">rangetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#abbd35e1657be4b84a80f98db4da87846">_prevrangetype</a></td></tr>
<tr class="memdesc:abbd35e1657be4b84a80f98db4da87846"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range type used to adjust the Y axis range on the previous adjustment call. <br /></td></tr>
<tr class="separator:abbd35e1657be4b84a80f98db4da87846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa61dec235e26211844cecc60a070560"><td class="memItemLeft" align="right" valign="top"><a id="afa61dec235e26211844cecc60a070560"></a>
TLegend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#afa61dec235e26211844cecc60a070560">_legend</a></td></tr>
<tr class="memdesc:afa61dec235e26211844cecc60a070560"><td class="mdescLeft">&#160;</td><td class="mdescRight">the Legend object <br /></td></tr>
<tr class="separator:afa61dec235e26211844cecc60a070560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af4c69e4a03731a0f7f010bd0de8f4"><td class="memItemLeft" align="right" valign="top"><a id="ad3af4c69e4a03731a0f7f010bd0de8f4"></a>
align&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad3af4c69e4a03731a0f7f010bd0de8f4">_legendposition</a></td></tr>
<tr class="memdesc:ad3af4c69e4a03731a0f7f010bd0de8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of the legend object in the pad <br /></td></tr>
<tr class="separator:ad3af4c69e4a03731a0f7f010bd0de8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3626e4e347d3a33e9888888e652a7401"><td class="memItemLeft" align="right" valign="top"><a id="a3626e4e347d3a33e9888888e652a7401"></a>
std::vector&lt; TLine * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a3626e4e347d3a33e9888888e652a7401">_linelist</a></td></tr>
<tr class="memdesc:a3626e4e347d3a33e9888888e652a7401"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of lines that need finalizing just before plot is finalized <br /></td></tr>
<tr class="separator:a3626e4e347d3a33e9888888e652a7401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5a01017805323b69f1bde2290d62cbcb"><td class="memItemLeft" align="right" valign="top"><a id="a5a01017805323b69f1bde2290d62cbcb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a5a01017805323b69f1bde2290d62cbcb">_datamax</a></td></tr>
<tr class="memdesc:a5a01017805323b69f1bde2290d62cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">tracking the min/max values of the data plotted on the pad <br  />
 <br /></td></tr>
<tr class="separator:a5a01017805323b69f1bde2290d62cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf07a91d48622a9bfb5cae9726d677fa"><td class="memItemLeft" align="right" valign="top"><a id="adf07a91d48622a9bfb5cae9726d677fa"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1Pad1D.html#adf07a91d48622a9bfb5cae9726d677fa">_datamin</a></td></tr>
<tr class="memdesc:adf07a91d48622a9bfb5cae9726d677fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">tracking the min/max values of the data plotted on the pad <br  />
 <br /></td></tr>
<tr class="separator:adf07a91d48622a9bfb5cae9726d677fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classusr_1_1plt_1_1PadBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classusr_1_1plt_1_1PadBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classusr_1_1plt_1_1PadBase.html">usr::plt::PadBase</a></td></tr>
<tr class="memitem:a8914c7abe90b2bc13050570cd4246e82 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="a8914c7abe90b2bc13050570cd4246e82"></a>
TLatex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#a8914c7abe90b2bc13050570cd4246e82">_latex</a></td></tr>
<tr class="memdesc:a8914c7abe90b2bc13050570cd4246e82 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latex object used for text writing. <br /></td></tr>
<tr class="separator:a8914c7abe90b2bc13050570cd4246e82 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa064196d8f70fecac62b72fcc93fcb58 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aa064196d8f70fecac62b72fcc93fcb58"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#aa064196d8f70fecac62b72fcc93fcb58">_latex_cursorx</a></td></tr>
<tr class="memdesc:aa064196d8f70fecac62b72fcc93fcb58 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">coordinates to plot the next line of latex text <br /></td></tr>
<tr class="separator:aa064196d8f70fecac62b72fcc93fcb58 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa08613e61a1609166843f8d7a8a6fb1 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="afa08613e61a1609166843f8d7a8a6fb1"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#afa08613e61a1609166843f8d7a8a6fb1">_latex_cursory</a></td></tr>
<tr class="memdesc:afa08613e61a1609166843f8d7a8a6fb1 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">coordinates to plot the next line of latex text, automatically updates when <a class="el" href="classusr_1_1plt_1_1PadBase.html#a18f530ac7f6aeee4b2bdf6465548f9ec" title="Writing text a designated cursor position.">WriteLine()</a> is called. <br /></td></tr>
<tr class="separator:afa08613e61a1609166843f8d7a8a6fb1 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee110214377dd7940e21798387f434 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="ae4ee110214377dd7940e21798387f434"></a>
std::vector&lt; TObject * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusr_1_1plt_1_1PadBase.html#ae4ee110214377dd7940e21798387f434">_generated_objects</a></td></tr>
<tr class="memdesc:ae4ee110214377dd7940e21798387f434 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">a lot of objects for plotting will be dynamically generated (ex. text objects ) The Pad object will then claim ownership of these objects and will be cleaned when the object is deleted. <br /></td></tr>
<tr class="separator:ae4ee110214377dd7940e21798387f434 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad946cf89e19123cba9f8e1a0c767cdb0 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="ad946cf89e19123cba9f8e1a0c767cdb0"></a>
<a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_parentcanvas</b></td></tr>
<tr class="separator:ad946cf89e19123cba9f8e1a0c767cdb0 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddfbd7032039ed308bff92de0f55851 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memItemLeft" align="right" valign="top"><a id="aeddfbd7032039ed308bff92de0f55851"></a>
TPad *&#160;</td><td class="memItemRight" valign="bottom"><b>_pad</b></td></tr>
<tr class="separator:aeddfbd7032039ed308bff92de0f55851 inherit pro_attribs_classusr_1_1plt_1_1PadBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9816083e25bae0b2f472e19382136687"><td class="memItemLeft" align="right" valign="top"><a id="a9816083e25bae0b2f472e19382136687"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Canvas</b></td></tr>
<tr class="separator:a9816083e25bae0b2f472e19382136687"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f1de81ce7a5fb1cf145fee91955180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1de81ce7a5fb1cf145fee91955180d">&#9670;&nbsp;</a></span>Pad1D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usr::plt::Pad1D::Pad1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusr_1_1plt_1_1PadSize.html">PadSize</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusr_1_1plt_1_1RangeByVar.html">RangeByVar</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will make the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> instance properly spawn the _frame that is capable for generating plotting objects for RooFit data objects. </p>

</div>
</div>
<a id="a352ed6af673bf0a6188705c6a014eb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352ed6af673bf0a6188705c6a014eb98">&#9670;&nbsp;</a></span>Pad1D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usr::plt::Pad1D::Pad1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classusr_1_1plt_1_1Canvas.html">Canvas</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structusr_1_1plt_1_1PadSize.html">PadSize</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This would the be most typical construction for the plotting of ROOT objects. Note that the axis range would be determined by the object that is plotted first into the Pad. So take care of plotting order if that is an issue.. </p>

</div>
</div>
<a id="af811a25821542984632686b77719e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af811a25821542984632686b77719e3d4">&#9670;&nbsp;</a></span>~Pad1D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">usr::plt::Pad1D::~Pad1D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since all ownership is handled by _frame, do additional deletion class is needed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae2873892633ea51409c43d5e1974e898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2873892633ea51409c43d5e1974e898">&#9670;&nbsp;</a></span>AddLegendEntry() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AddLegendEntry </td>
          <td>(</td>
          <td class="paramtype">TEfficiency &amp;&#160;</td>
          <td class="paramname"><em>eff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>entryopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>plotopt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adding the a legend entry to the internal legend if the EntryText was used for plotting a histogram. The PlotType argument used for plotting the TEfficiency would be used to determine what attributes should be used in the legend:</p><ul>
<li>plotype::scatter: Point and line</li>
<li>plotype::hist: Fill only</li>
<li>plottype::histerr: Fill only</li>
<li>other/undetermined: all attributes would be used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eff</td><td>Efficiency object to be added to legend. </td></tr>
    <tr><td class="paramname">entryopt</td><td>text for entry in legend. </td></tr>
    <tr><td class="paramname">plotopt</td><td>plotting options used for graph object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a858893552cebe6479e905d803b710f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858893552cebe6479e905d803b710f85">&#9670;&nbsp;</a></span>AddLegendEntry() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AddLegendEntry </td>
          <td>(</td>
          <td class="paramtype">TGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>entryopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>plotopt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief adding legend entry for graph object.</p>
<p>Adding the a legend entry to the internal legend if the EntryText was used for plotting a histogram. The PlotType argument used for plotting the histogram would be used to determine what attributes should be used in the legend:</p><ul>
<li>plotype::simplefunc: only the line attribute</li>
<li>plotype::fittedfunc: line and fill attributes</li>
<li>plottype::scatter: point and line attributes. whether the vertical or the horizontal line should be used is determined by the error bar in the graph. if the error is zero throughout the datapoints, the corresponding bars would not be added to the legend either.</li>
<li>other/undetermined: all attributes would be used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph to be added to legend. </td></tr>
    <tr><td class="paramname">entryopt</td><td>text for entry in legend. </td></tr>
    <tr><td class="paramname">plotopt</td><td>plotting options used for graph object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6b89008af5334081e44d4c48a364515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b89008af5334081e44d4c48a364515">&#9670;&nbsp;</a></span>AddLegendEntry() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AddLegendEntry </td>
          <td>(</td>
          <td class="paramtype">TH1D &amp;&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>entryopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>plotopt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adding the a legend entry to the internal legend if the EntryText was used for plotting a histogram. The PlotType argument used for plotting the histogram would be used to determine what attributes should be used in the legend:</p><ul>
<li>plottype::hist: Line and fill attributes</li>
<li>plottype::histerr: Only the fill attribute (since we are using error boxes)</li>
<li>pltotype::histstack: Only the fill attribute (avoid lines)</li>
<li>plottype::scatter: Point and Line attributes, whether the horizontal line would be used is also determined by the variable bin-width of the histgram.</li>
<li>other/undetermined: all attributes would be used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>The histogram that the legend should link to. </td></tr>
    <tr><td class="paramname">entryopt</td><td>The texted to be placed in the legend. </td></tr>
    <tr><td class="paramname">plotopt</td><td>Options used for plotting histogram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13cd70b45b61ba135afa77eae787adc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cd70b45b61ba135afa77eae787adc7">&#9670;&nbsp;</a></span>AddLegendEntry() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AddLegendEntry </td>
          <td>(</td>
          <td class="paramtype">TObject &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that unlike Histograms and Graphs, this is assumed to be placed at the end of the Legend entries. </p>

</div>
</div>
<a id="ab58dfc9c463ad5f56c7ce305491ea0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58dfc9c463ad5f56c7ce305491ea0cb">&#9670;&nbsp;</a></span>AutoSetYRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AutoSetYRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8abc92e4404a07ea4fafd8ee4a5441eb">rangetype</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>aut</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatically adjusting the Y axis range according the the data's min max value that are tracked by the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a>. A few types are present:</p><ul>
<li>rangetype::hist: The Y range optimized for the presentation histograms. Mainly adjusting the max value, leaving a larger margin above the maximum peak. See <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ac2b18db0d1bf7925ddbef5f2d64f55a1" title="Y range setting optimized for histogram data presentation.">AutoSetYRangeHist()</a>.</li>
<li>rangetype::graph: The Y range is optimized for the presentation of graphs. Adjusting both the min and max range so that the data would fit comfortably in the frame. See <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a1f5ef30071be090a0b34b3657ebd7151" title="Y axis range setting optimized for scatter data presentation.">AutoSetYRangeGraph()</a>.</li>
<li>rangetype::ratio: The Y range would be symmetric around 1. See <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a037acd167dddd7224e486eea6e94dcb4" title="Y axis range setting optimized for data ratio comparison.">AutoSetYRangeRatio()</a>.</li>
<li>rangetype::pull: The Y range would be symmetric around 0. See <a class="el" href="classusr_1_1plt_1_1Pad1D.html#a1f89f62fc327fb3da36e549e392699c0" title="Y axis range setting optimized for pull results comparison.">AutoSetYRangePull()</a> More details would be given in the implementations in the protected member functions.</li>
</ul>
<p>In the case the the user want's this to be automatically determined, if any histogram like data exists in the pad, this method used would be the rangetype::hist, otherwise if only TGraph-like data exists in the pad, the rangetype::graph would be used. </p>

</div>
</div>
<a id="a1f5ef30071be090a0b34b3657ebd7151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5ef30071be090a0b34b3657ebd7151">&#9670;&nbsp;</a></span>AutoSetYRangeGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AutoSetYRangeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The data range recorded by the Pad would take up 10/13 of the total y range, 2/13 of the frame would be left for the top margin, and 1/13 would be left for the bottom margin. In case a log plot is requested the "data
minimum" would be hard clipped at 1e-6. </p>

</div>
</div>
<a id="ac2b18db0d1bf7925ddbef5f2d64f55a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b18db0d1bf7925ddbef5f2d64f55a1">&#9670;&nbsp;</a></span>AutoSetYRangeHist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AutoSetYRangeHist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The minimum y axis value is set to be exactly the recorded data minimum (0.3 is TrackY used for all histogram object was set to be automatic). The maximum y axis value is set such that y range of the data only spans the bottom 4/5 of the entire frame, leaving much margin on top for labels and legends. This setting is true for both log and non-log plots, with the expection being that in the case of the log plots, the minimum value is hard set to a minimum of 1e-6. </p>

</div>
</div>
<a id="a1f89f62fc327fb3da36e549e392699c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f89f62fc327fb3da36e549e392699c0">&#9670;&nbsp;</a></span>AutoSetYRangePull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AutoSetYRangePull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The y axis range would be centered around 1. with the range extended to contain the data min/max values, round to the closest 0.1 to avoid funny tick values. The maximum range is hard set to be -5 &ndash; 5 to avoid details around 0 being obscured by extreme values. (If there is nothing in your plot with this range, there might be something wrong with your data...) An additional 10% margin is left on top and bottom for aesthetic reasons. </p>

</div>
</div>
<a id="a037acd167dddd7224e486eea6e94dcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037acd167dddd7224e486eea6e94dcb4">&#9670;&nbsp;</a></span>AutoSetYRangeRatio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::AutoSetYRangeRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The y axis range would be centered around 1. With the range extended to contain the data min/max values, rounded to the closest 0.1 to avoid funny tick values. The maximum range would be -0.1,2.1 to avoid details being lost around data values close to 1. (If there is still nothing in your plot, then there might be something wrong with your data...) An additional 5% margin is left on top and bottom for aesthetic reasons. </p>

</div>
</div>
<a id="ac90eefa579442355eed869d501c6b912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90eefa579442355eed869d501c6b912">&#9670;&nbsp;</a></span>CheckLogy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool usr::plt::Pad1D::CheckLogy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To avoid the case where there are negative numbers or zeros in the plot data when setting the plot range to be log scaled. All plot objects with values less than 0 with have it's contents shifted to the minimal positive double. </p>

</div>
</div>
<a id="aad95f7f3a6915f6721df119241ef0ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad95f7f3a6915f6721df119241ef0ee1">&#9670;&nbsp;</a></span>DrawCMSLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::DrawCMSLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>cap::prelim</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>main</em> = <code>&quot;CMS&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drawing the CMS label inside the frame at the top left corner. Additional styling will include:</p><ul>
<li>The font size of the label will be a "large" variant to the <a class="el" href="classusr_1_1plt_1_1Canvas.html" title="Extending the TCanvas class for better saving and padâ€“canvas hierarchy relations.">Canvas</a> settings</li>
<li>The Top left corner of the text would be set to 1.5 times the tick length.</li>
<li>The man label (CMS) would be set to bold</li>
<li>The second label (if defined, such as "Preliminary") would be set to italic. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The secondary tag to be displayed below the CMS label font. </td></tr>
    <tr><td class="paramname">main</td><td>The main tag to be plotted (default to CMS but could be changed if you are working for another experiment) </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a1eca42db9e402fb0d3d954b86226c379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eca42db9e402fb0d3d954b86226c379">&#9670;&nbsp;</a></span>DrawHLine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TLine &amp; usr::plt::Pad1D::DrawHLine </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drawing horizontal line.</p>
<p>Drawing a horizontal line across the pad at a fixed y value. Accepts the LineColor, LineStyle, LineWidth options for change the styling of the line. Also returns a reference to the line generated. </p>

</div>
</div>
<a id="a63db7da215d5ef78a72bacb12f363a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63db7da215d5ef78a72bacb12f363a2f">&#9670;&nbsp;</a></span>DrawHLine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLine&amp; usr::plt::Pad1D::DrawHLine </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Drawing horizontal line.</p>
<p>Drawing a horizontal line across the pad at a fixed y value. Accepts the LineColor, LineStyle, LineWidth options for change the styling of the line. Also returns a reference to the line generated. </p>

</div>
</div>
<a id="a41f6d0ad72c654bef02f1fa631efc37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f6d0ad72c654bef02f1fa631efc37b">&#9670;&nbsp;</a></span>DrawHLine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLine&amp; usr::plt::Pad1D::DrawHLine </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Drawing horizontal line.</p>
<p>Drawing a horizontal line across the pad at a fixed y value. Accepts the LineColor, LineStyle, LineWidth options for change the styling of the line. Also returns a reference to the line generated. </p>

</div>
</div>
<a id="a9441be81ed4b9ac3823f6787c8cedab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9441be81ed4b9ac3823f6787c8cedab5">&#9670;&nbsp;</a></span>DrawLuminosity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::DrawLuminosity </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lumi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writing the luminosity label in the standard format of "XX.X fb^{-1} (13TeV)" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lumi</td><td>The luminosity in units of fb-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a871f35d9871ea075606b63bee19eac55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871f35d9871ea075606b63bee19eac55">&#9670;&nbsp;</a></span>DrawLuminosity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::DrawLuminosity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writing the Luminosity label outside of the frame on the top-right corner. This string in directly pass to the TLatex object, so all styling here would be user defined. The font setting would be identical to that of the canvas setting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the string to use as the luminosity label </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4279640d7943bcb7b307ca8696e1e430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4279640d7943bcb7b307ca8696e1e430">&#9670;&nbsp;</a></span>DrawVLine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TLine &amp; usr::plt::Pad1D::DrawVLine </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drawing vertical line.</p>
<p>Drawing a vertical line across the pad at a fixed x value. Accepts the LineColor, LineStyle, LineWidth options for change the styling of the line. Also return a reference to the line generated. </p>

</div>
</div>
<a id="a359856570e93dee949ce9d4a61325efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359856570e93dee949ce9d4a61325efe">&#9670;&nbsp;</a></span>DrawVLine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLine&amp; usr::plt::Pad1D::DrawVLine </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Drawing vertical line.</p>
<p>Drawing a vertical line across the pad at a fixed x value. Accepts the LineColor, LineStyle, LineWidth options for change the styling of the line. Also return a reference to the line generated. </p>

</div>
</div>
<a id="abe95b06b2bbe76cabd7cb7bed7b6f175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe95b06b2bbe76cabd7cb7bed7b6f175">&#9670;&nbsp;</a></span>DrawVLine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLine&amp; usr::plt::Pad1D::DrawVLine </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Drawing vertical line.</p>
<p>Drawing a vertical line across the pad at a fixed x value. Accepts the LineColor, LineStyle, LineWidth options for change the styling of the line. Also return a reference to the line generated. </p>

</div>
</div>
<a id="a4299da435d73d91ce3f872d625324d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4299da435d73d91ce3f872d625324d58">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Additional steps:</p><ol type="1">
<li>Redrawing axis to ensure nothing is covering the frame.</li>
<li>Making the legend object, and ensuring all specificed legend entries are placed in the legend. </li>
</ol>

<p>Reimplemented from <a class="el" href="classusr_1_1plt_1_1PadBase.html#a313a3475752c7347003538df365a5ede">usr::plt::PadBase</a>.</p>

</div>
</div>
<a id="a2743c3322507660b44f1ccd3da82c14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2743c3322507660b44f1ccd3da82c14b">&#9670;&nbsp;</a></span>FinalizeLegend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::FinalizeLegend </td>
          <td>(</td>
          <td class="paramtype">const align&#160;</td>
          <td class="paramname"><em>newposition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generating the TLegend object. One can assign a new position in the frame (one of 9, in the left&ndash;center&ndash;right, top&ndash;center&ndash;bottom system) is required. </p>

</div>
</div>
<a id="a3adb9a13f09641b64d845dcddc65c163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adb9a13f09641b64d845dcddc65c163">&#9670;&nbsp;</a></span>GenGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors &amp; usr::plt::Pad1D::GenGraph </td>
          <td>(</td>
          <td class="paramtype">RooAbsData &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RooLinkedList &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throws an invalid_argument exception when the plotting call fails. </p>

</div>
</div>
<a id="afa11c06bc2f95bdff624a3b9806e1bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa11c06bc2f95bdff624a3b9806e1bd5">&#9670;&nbsp;</a></span>GenGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph &amp; usr::plt::Pad1D::GenGraph </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RooLinkedList &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throws and invalid_argument exception when the plotting call fails. </p>

</div>
</div>
<a id="a2979843fc2bc6bcad63ee1dda4220290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2979843fc2bc6bcad63ee1dda4220290">&#9670;&nbsp;</a></span>GetAxisObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TObject * usr::plt::Pad1D::GetAxisObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Getting the pointer to the TObject responsible for drawing the axis. Based on how the Various Draw functions works, this will be the first object on the TPad that is either a TH1 or a TGraph. The code for iterating through the objects in the pad is copied from the <a href="https://root.cern.ch/doc/master/TPad_8cxx_source.html#l05243">TPad::RedrawAxis()</a> code. </p>

</div>
</div>
<a id="adb9802740020ad1d8fdfad1472385945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9802740020ad1d8fdfad1472385945">&#9670;&nbsp;</a></span>GetDataMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::plt::Pad1D::GetDataMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Directly returning the double stored by the class. </p>

</div>
</div>
<a id="a184073003b7517d947a2cbb3e6e6c8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184073003b7517d947a2cbb3e6e6c8f8">&#9670;&nbsp;</a></span>GetDataMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::plt::Pad1D::GetDataMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Directly returning the double stored by the class. </p>

</div>
</div>
<a id="aa722786ec11f8fe96d2d128d7cc303ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa722786ec11f8fe96d2d128d7cc303ef">&#9670;&nbsp;</a></span>GetXaxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TAxis * usr::plt::Pad1D::GetXaxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROOT style pointer interface for getting the axis object used for plotting the axis frame. </p>

</div>
</div>
<a id="a4f09dd2fe7e34d51114bc27dca7c9b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f09dd2fe7e34d51114bc27dca7c9b5e">&#9670;&nbsp;</a></span>GetXaxisMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::plt::Pad1D::GetXaxisMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since this would not be altered thoughout the plotting function calls, we directly use the in-built function of the TAxis object. </p>

</div>
</div>
<a id="ab83eab10892672a673fc71e5d82fe874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83eab10892672a673fc71e5d82fe874">&#9670;&nbsp;</a></span>GetXaxisMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::plt::Pad1D::GetXaxisMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since this would not be altered thoughout the plotting function calls, we directly use the in-built function of the TAxis object. </p>

</div>
</div>
<a id="aede7804ba18387cf9d63bef0e66e8ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede7804ba18387cf9d63bef0e66e8ddc">&#9670;&nbsp;</a></span>GetYaxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TAxis * usr::plt::Pad1D::GetYaxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROOT style pointer interface for getting the axis object used for plotting the axis frame. </p>

</div>
</div>
<a id="a315fdee802c6a640821c8a96bf4cf4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315fdee802c6a640821c8a96bf4cf4b0">&#9670;&nbsp;</a></span>GetYaxisMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::plt::Pad1D::GetYaxisMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Y axis plotting range is not defined by the Y axis object itself, but rather the <a class="el" href="VectorUtils_8hpp.html#a8dcc2e38b21fe4190215416b8401eb82" title="Get the Maximum element value in a vector.">GetMaximum()</a> function of the object used for drawing the Y axis of the canvas. This function would return an NAN the the GetAxisObject is not found. </p>

</div>
</div>
<a id="a040f3fe32f6444fcd5deb4109a1ccf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040f3fe32f6444fcd5deb4109a1ccf05">&#9670;&nbsp;</a></span>GetYaxisMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double usr::plt::Pad1D::GetYaxisMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Y axis plotting range is not defined by the Y axis object itself, but rather the <a class="el" href="VectorUtils_8hpp.html#a8dcc2e38b21fe4190215416b8401eb82" title="Get the Maximum element value in a vector.">GetMaximum()</a> function of the object used for drawing the Y axis of the canvas. This function would return an NAN the the GetAxisObject is not found. </p>

</div>
</div>
<a id="a009a13deb1306cf370785b602533739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009a13deb1306cf370785b602533739f">&#9670;&nbsp;</a></span>InitDraw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::InitDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In case a RooPlot is requested, ust that to draw the frame first to avoid graphs messing up the plot range. </p>

<p>Reimplemented from <a class="el" href="classusr_1_1plt_1_1PadBase.html#a923d211f54162b8ecb301f4daeba87e6">usr::plt::PadBase</a>.</p>

</div>
</div>
<a id="af4d8a49d9e508226751a37a6e6dc6333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d8a49d9e508226751a37a6e6dc6333">&#9670;&nbsp;</a></span>InnerTextBottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float usr::plt::Pad1D::InnerTextBottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extra margin based on the current axis tick-length would be added. </p>

</div>
</div>
<a id="a946d2b424e5aaac84bba84aaa2074a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946d2b424e5aaac84bba84aaa2074a30">&#9670;&nbsp;</a></span>InnerTextHCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float usr::plt::Pad1D::InnerTextHCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extra margin based on the current axis tick-length would be added. </p>

</div>
</div>
<a id="a6286bbdce471b0378338fc95190907ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6286bbdce471b0378338fc95190907ca">&#9670;&nbsp;</a></span>InnerTextLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float usr::plt::Pad1D::InnerTextLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extra margin based on the current axis tick-length would be added. </p>

</div>
</div>
<a id="af7bf50474fde6627ad6d48b7ee922ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bf50474fde6627ad6d48b7ee922ff6">&#9670;&nbsp;</a></span>InnerTextRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float usr::plt::Pad1D::InnerTextRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extra margin based on the current axis tick-length would be added. </p>

</div>
</div>
<a id="a30baf303503eda0f94b89f353217118c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30baf303503eda0f94b89f353217118c">&#9670;&nbsp;</a></span>InnerTextTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float usr::plt::Pad1D::InnerTextTop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extra margin based on the current axis tick-length would be added. </p>

</div>
</div>
<a id="a3395ff1f9fc7969fe0a8a850fcb38da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3395ff1f9fc7969fe0a8a850fcb38da4">&#9670;&nbsp;</a></span>InnerTextVCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float usr::plt::Pad1D::InnerTextVCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extra margin based on the current axis tick-length would be added. </p>

</div>
</div>
<a id="ae475e3f98744af74f5311d7e9bc8b084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae475e3f98744af74f5311d7e9bc8b084">&#9670;&nbsp;</a></span>MakeDataGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors &amp; usr::plt::Pad1D::MakeDataGraph </td>
          <td>(</td>
          <td class="paramtype">RooAbsData &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1RooArgContainer.html">RooArgContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will detect the binning method specified by the various options (using the present binning of the <a class="el" href="classusr_1_1plt_1_1RooFrame.html" title="Simple class for exposing additional variables and functions of the RooPlot object.">RooFrame</a> variable otherwise), and in the case of uniform binning, suppress the x axis error bars, as specified by the CMS publication conventions. Additionally, Bins with zero entires would have their y error bars suppressed. </p>

</div>
</div>
<a id="a9d4ce99e1ffd88c5221601096dd899b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4ce99e1ffd88c5221601096dd899b1">&#9670;&nbsp;</a></span>MakePdfGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph &amp; usr::plt::Pad1D::MakePdfGraph </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classusr_1_1RooArgContainer.html">RooArgContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the case the RooFit::Visualization is used, this function generates two graphs via the in-built RooFit methods , one for the central plot, and the other the contor of the uncertainty. This function then recalculates the two graphs into a single TGraph with uncertainty, which is makes manipulating the the plot results of a single RooAbsPdf instance more intuitive (changing the plot style of a single object, rather than two). </p>

</div>
</div>
<a id="a920475e93f4671bc4b7eafe72898d3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920475e93f4671bc4b7eafe72898d3e9">&#9670;&nbsp;</a></span>PlotData() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors &amp; usr::plt::Pad1D::PlotData </td>
          <td>(</td>
          <td class="paramtype">RooAbsData &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for plotting all of the RooAbsData objects, the supported options allowed include:</p><ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options. With the excpetion of RooFit::DrawOptions.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. By default, the scatter plot method would be used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used. Notice that this method is overwritten by the RooFit::Invisible option, which forces the object to be hidden.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, only the maximum value would be used.</li>
</ul>
<p>Additional automation of options include suppressing the X error bars of the generated graph if an equal binning is used for the data set and the RooFit::XErrorSize is not specified. This is to align the plotting style conventions within the CMS collaboration. Another change to the graphs is that the y uncertainties in the zero bins are suppressed, again, to align with the plotting style conventions.</p>
<p>The function returns a reference to the generated TGraph object by the underlying RooPlot object, The object would be owned by the RooPlot and be destroyed when the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> goes out of scope. </p>

</div>
</div>
<a id="a1ca8fbccf80747c729439ccc49141de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca8fbccf80747c729439ccc49141de3">&#9670;&nbsp;</a></span>PlotData() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors&amp; usr::plt::Pad1D::PlotData </td>
          <td>(</td>
          <td class="paramtype">RooAbsData &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for plotting all of the RooAbsData objects, the supported options allowed include:</p><ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options. With the excpetion of RooFit::DrawOptions.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. By default, the scatter plot method would be used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used. Notice that this method is overwritten by the RooFit::Invisible option, which forces the object to be hidden.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, only the maximum value would be used.</li>
</ul>
<p>Additional automation of options include suppressing the X error bars of the generated graph if an equal binning is used for the data set and the RooFit::XErrorSize is not specified. This is to align the plotting style conventions within the CMS collaboration. Another change to the graphs is that the y uncertainties in the zero bins are suppressed, again, to align with the plotting style conventions.</p>
<p>The function returns a reference to the generated TGraph object by the underlying RooPlot object, The object would be owned by the RooPlot and be destroyed when the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> goes out of scope. </p>

</div>
</div>
<a id="a551709f0e9a71fd961e708ecc0993175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551709f0e9a71fd961e708ecc0993175">&#9670;&nbsp;</a></span>PlotData() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors&amp; usr::plt::Pad1D::PlotData </td>
          <td>(</td>
          <td class="paramtype">RooAbsData &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for plotting all of the RooAbsData objects, the supported options allowed include:</p><ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options. With the excpetion of RooFit::DrawOptions.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. By default, the scatter plot method would be used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used. Notice that this method is overwritten by the RooFit::Invisible option, which forces the object to be hidden.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, only the maximum value would be used.</li>
</ul>
<p>Additional automation of options include suppressing the X error bars of the generated graph if an equal binning is used for the data set and the RooFit::XErrorSize is not specified. This is to align the plotting style conventions within the CMS collaboration. Another change to the graphs is that the y uncertainties in the zero bins are suppressed, again, to align with the plotting style conventions.</p>
<p>The function returns a reference to the generated TGraph object by the underlying RooPlot object, The object would be owned by the RooPlot and be destroyed when the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> goes out of scope. </p>

</div>
</div>
<a id="a37ff796681bb57e66b06beae2eae2b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ff796681bb57e66b06beae2eae2b41">&#9670;&nbsp;</a></span>PlotData() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors&amp; usr::plt::Pad1D::PlotData </td>
          <td>(</td>
          <td class="paramtype">RooAbsData *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for plotting all of the RooAbsData objects, the supported options allowed include:</p><ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options. With the excpetion of RooFit::DrawOptions.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. By default, the scatter plot method would be used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used. Notice that this method is overwritten by the RooFit::Invisible option, which forces the object to be hidden.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, only the maximum value would be used.</li>
</ul>
<p>Additional automation of options include suppressing the X error bars of the generated graph if an equal binning is used for the data set and the RooFit::XErrorSize is not specified. This is to align the plotting style conventions within the CMS collaboration. Another change to the graphs is that the y uncertainties in the zero bins are suppressed, again, to align with the plotting style conventions.</p>
<p>The function returns a reference to the generated TGraph object by the underlying RooPlot object, The object would be owned by the RooPlot and be destroyed when the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> goes out of scope. </p>

</div>
</div>
<a id="a14a79df61937af9584bd8a3f89202f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a79df61937af9584bd8a3f89202f05">&#9670;&nbsp;</a></span>PlotData() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors&amp; usr::plt::Pad1D::PlotData </td>
          <td>(</td>
          <td class="paramtype">RooAbsData *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for plotting all of the RooAbsData objects, the supported options allowed include:</p><ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options. With the excpetion of RooFit::DrawOptions.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. By default, the scatter plot method would be used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used. Notice that this method is overwritten by the RooFit::Invisible option, which forces the object to be hidden.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, only the maximum value would be used.</li>
</ul>
<p>Additional automation of options include suppressing the X error bars of the generated graph if an equal binning is used for the data set and the RooFit::XErrorSize is not specified. This is to align the plotting style conventions within the CMS collaboration. Another change to the graphs is that the y uncertainties in the zero bins are suppressed, again, to align with the plotting style conventions.</p>
<p>The function returns a reference to the generated TGraph object by the underlying RooPlot object, The object would be owned by the RooPlot and be destroyed when the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> goes out of scope. </p>

</div>
</div>
<a id="ad561aad2de79a33fbb3958219b98a339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad561aad2de79a33fbb3958219b98a339">&#9670;&nbsp;</a></span>PlotData() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraphAsymmErrors&amp; usr::plt::Pad1D::PlotData </td>
          <td>(</td>
          <td class="paramtype">RooAbsData *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function for plotting all of the RooAbsData objects, the supported options allowed include:</p><ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options. With the excpetion of RooFit::DrawOptions.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. By default, the scatter plot method would be used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used. Notice that this method is overwritten by the RooFit::Invisible option, which forces the object to be hidden.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, only the maximum value would be used.</li>
</ul>
<p>Additional automation of options include suppressing the X error bars of the generated graph if an equal binning is used for the data set and the RooFit::XErrorSize is not specified. This is to align the plotting style conventions within the CMS collaboration. Another change to the graphs is that the y uncertainties in the zero bins are suppressed, again, to align with the plotting style conventions.</p>
<p>The function returns a reference to the generated TGraph object by the underlying RooPlot object, The object would be owned by the RooPlot and be destroyed when the <a class="el" href="classusr_1_1plt_1_1Pad1D.html" title="Specialized class for 1D data plotting.">Pad1D</a> goes out of scope. </p>

</div>
</div>
<a id="abb4fb1cf077e58a82610098f067b9135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4fb1cf077e58a82610098f067b9135">&#9670;&nbsp;</a></span>PlotEff() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TEfficiency &amp; usr::plt::Pad1D::PlotEff </td>
          <td>(</td>
          <td class="paramtype">TEfficiency &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plotting a TEfficiency object.</p>
<p>Supported options are:</p><ul>
<li>PlotType: Definining how the data should be presented<ul>
<li>plottype::scatter (default) - Plotting points with error bars, unfortunately, because the TEfficiency object has plotting functions similar to TGraphs and not TH1Ds, we cannot force the uniform bin display to have no x-error bars.</li>
<li>plottype::hist - Plotting as histograms. Because graphical options are using TGraphs and not TH1Ds, we are using the bar options ("B"). So we cannot have an unfilled color.</li>
<li>plottype::histerr - Drawing uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions. </li>
</ul>

</div>
</div>
<a id="a11ad4ef176729c102b4071f443ab8fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ad4ef176729c102b4071f443ab8fc8">&#9670;&nbsp;</a></span>PlotEff() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TEfficiency&amp; usr::plt::Pad1D::PlotEff </td>
          <td>(</td>
          <td class="paramtype">TEfficiency &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TEfficiency object.</p>
<p>Supported options are:</p><ul>
<li>PlotType: Definining how the data should be presented<ul>
<li>plottype::scatter (default) - Plotting points with error bars, unfortunately, because the TEfficiency object has plotting functions similar to TGraphs and not TH1Ds, we cannot force the uniform bin display to have no x-error bars.</li>
<li>plottype::hist - Plotting as histograms. Because graphical options are using TGraphs and not TH1Ds, we are using the bar options ("B"). So we cannot have an unfilled color.</li>
<li>plottype::histerr - Drawing uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions. </li>
</ul>

</div>
</div>
<a id="aa3a056d9f575173de9d1bb4240d732ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a056d9f575173de9d1bb4240d732ae">&#9670;&nbsp;</a></span>PlotEff() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TEfficiency&amp; usr::plt::Pad1D::PlotEff </td>
          <td>(</td>
          <td class="paramtype">TEfficiency &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TEfficiency object.</p>
<p>Supported options are:</p><ul>
<li>PlotType: Definining how the data should be presented<ul>
<li>plottype::scatter (default) - Plotting points with error bars, unfortunately, because the TEfficiency object has plotting functions similar to TGraphs and not TH1Ds, we cannot force the uniform bin display to have no x-error bars.</li>
<li>plottype::hist - Plotting as histograms. Because graphical options are using TGraphs and not TH1Ds, we are using the bar options ("B"). So we cannot have an unfilled color.</li>
<li>plottype::histerr - Drawing uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions. </li>
</ul>

</div>
</div>
<a id="a5ef376e8075a5b3d423ed078edfd9a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef376e8075a5b3d423ed078edfd9a66">&#9670;&nbsp;</a></span>PlotEff() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TEfficiency&amp; usr::plt::Pad1D::PlotEff </td>
          <td>(</td>
          <td class="paramtype">TEfficiency *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TEfficiency object.</p>
<p>Supported options are:</p><ul>
<li>PlotType: Definining how the data should be presented<ul>
<li>plottype::scatter (default) - Plotting points with error bars, unfortunately, because the TEfficiency object has plotting functions similar to TGraphs and not TH1Ds, we cannot force the uniform bin display to have no x-error bars.</li>
<li>plottype::hist - Plotting as histograms. Because graphical options are using TGraphs and not TH1Ds, we are using the bar options ("B"). So we cannot have an unfilled color.</li>
<li>plottype::histerr - Drawing uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions. </li>
</ul>

</div>
</div>
<a id="a3e74757ec2830a6ac9bac7c45e2b1d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e74757ec2830a6ac9bac7c45e2b1d41">&#9670;&nbsp;</a></span>PlotEff() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TEfficiency&amp; usr::plt::Pad1D::PlotEff </td>
          <td>(</td>
          <td class="paramtype">TEfficiency *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TEfficiency object.</p>
<p>Supported options are:</p><ul>
<li>PlotType: Definining how the data should be presented<ul>
<li>plottype::scatter (default) - Plotting points with error bars, unfortunately, because the TEfficiency object has plotting functions similar to TGraphs and not TH1Ds, we cannot force the uniform bin display to have no x-error bars.</li>
<li>plottype::hist - Plotting as histograms. Because graphical options are using TGraphs and not TH1Ds, we are using the bar options ("B"). So we cannot have an unfilled color.</li>
<li>plottype::histerr - Drawing uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions. </li>
</ul>

</div>
</div>
<a id="ade509d4cc57221bb395ae4d2e9238a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade509d4cc57221bb395ae4d2e9238a28">&#9670;&nbsp;</a></span>PlotEff() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TEfficiency&amp; usr::plt::Pad1D::PlotEff </td>
          <td>(</td>
          <td class="paramtype">TEfficiency *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TEfficiency object.</p>
<p>Supported options are:</p><ul>
<li>PlotType: Definining how the data should be presented<ul>
<li>plottype::scatter (default) - Plotting points with error bars, unfortunately, because the TEfficiency object has plotting functions similar to TGraphs and not TH1Ds, we cannot force the uniform bin display to have no x-error bars.</li>
<li>plottype::hist - Plotting as histograms. Because graphical options are using TGraphs and not TH1Ds, we are using the bar options ("B"). So we cannot have an unfilled color.</li>
<li>plottype::histerr - Drawing uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions. </li>
</ul>

</div>
</div>
<a id="ad70690f2d8160849df791765b6cda04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70690f2d8160849df791765b6cda04b">&#9670;&nbsp;</a></span>PlotFunc() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TGraph &amp; usr::plt::Pad1D::PlotFunc </td>
          <td>(</td>
          <td class="paramtype">TF1 &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plotting a TF1 object is done by generating a TGraph with 300 samples points across the x axis, and plotting the TGraph instead. All TGraph plotting options will be available for the TF1 plotting. There is a new plotting options VisualizeError, which generates a TGraphErrors graph by randomly sampling the parameter space according to the correlation matrix given by a <a href="https://root.cern.ch/doc/master/classTFitResult.html">TFitResult</a>. </p>

</div>
</div>
<a id="ac3653ad04351072c992c65aa11303882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3653ad04351072c992c65aa11303882">&#9670;&nbsp;</a></span>PlotFunc() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotFunc </td>
          <td>(</td>
          <td class="paramtype">TF1 &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TF1 object is done by generating a TGraph with 300 samples points across the x axis, and plotting the TGraph instead. All TGraph plotting options will be available for the TF1 plotting. There is a new plotting options VisualizeError, which generates a TGraphErrors graph by randomly sampling the parameter space according to the correlation matrix given by a <a href="https://root.cern.ch/doc/master/classTFitResult.html">TFitResult</a>. </p>

</div>
</div>
<a id="ae1ded4c175adcb44b92e00aa3bd3488f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ded4c175adcb44b92e00aa3bd3488f">&#9670;&nbsp;</a></span>PlotFunc() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotFunc </td>
          <td>(</td>
          <td class="paramtype">TF1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TF1 object is done by generating a TGraph with 300 samples points across the x axis, and plotting the TGraph instead. All TGraph plotting options will be available for the TF1 plotting. There is a new plotting options VisualizeError, which generates a TGraphErrors graph by randomly sampling the parameter space according to the correlation matrix given by a <a href="https://root.cern.ch/doc/master/classTFitResult.html">TFitResult</a>. </p>

</div>
</div>
<a id="a86a5becac2f93a0bb7dd5a3a7a246575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a5becac2f93a0bb7dd5a3a7a246575">&#9670;&nbsp;</a></span>PlotFunc() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotFunc </td>
          <td>(</td>
          <td class="paramtype">TF1 *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TF1 object is done by generating a TGraph with 300 samples points across the x axis, and plotting the TGraph instead. All TGraph plotting options will be available for the TF1 plotting. There is a new plotting options VisualizeError, which generates a TGraphErrors graph by randomly sampling the parameter space according to the correlation matrix given by a <a href="https://root.cern.ch/doc/master/classTFitResult.html">TFitResult</a>. </p>

</div>
</div>
<a id="a4c3f4061b85e39202be06cdaea1b79b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3f4061b85e39202be06cdaea1b79b5">&#9670;&nbsp;</a></span>PlotFunc() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotFunc </td>
          <td>(</td>
          <td class="paramtype">TF1 *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TF1 object is done by generating a TGraph with 300 samples points across the x axis, and plotting the TGraph instead. All TGraph plotting options will be available for the TF1 plotting. There is a new plotting options VisualizeError, which generates a TGraphErrors graph by randomly sampling the parameter space according to the correlation matrix given by a <a href="https://root.cern.ch/doc/master/classTFitResult.html">TFitResult</a>. </p>

</div>
</div>
<a id="a98d5a41991b79a01fe2be16014d8e069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d5a41991b79a01fe2be16014d8e069">&#9670;&nbsp;</a></span>PlotFunc() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotFunc </td>
          <td>(</td>
          <td class="paramtype">TF1 *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TF1 object is done by generating a TGraph with 300 samples points across the x axis, and plotting the TGraph instead. All TGraph plotting options will be available for the TF1 plotting. There is a new plotting options VisualizeError, which generates a TGraphErrors graph by randomly sampling the parameter space according to the correlation matrix given by a <a href="https://root.cern.ch/doc/master/classTFitResult.html">TFitResult</a>. </p>

</div>
</div>
<a id="a36ca6919a50117a307b00e4eb110677a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ca6919a50117a307b00e4eb110677a">&#9670;&nbsp;</a></span>PlotGraph() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TGraph &amp; usr::plt::Pad1D::PlotGraph </td>
          <td>(</td>
          <td class="paramtype">TGraph &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plotting of the TGraph object has the following supporting options:</p>
<ul>
<li><code>PlotType</code>: Defining how the data should be represented on the Pad. The supported types are:<ul>
<li><code>plottype::simplefunc</code>(default): single polyline joining the data points. This is used if the graph represents a function sample.</li>
<li><code>plottype::fittedfunc</code>: a polyline joining the data points with the Y error represented with a shaded region. This is used if the graph represents a function sample with additional sampling for fitting uncertainties</li>
<li><code>plottype::scatter</code>: plotting the data as data points with error bars. Unlike the histograms, this would not attempt to adjust the x error bars.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting </p>

</div>
</div>
<a id="ae6dadacc5bf0b7d99d46c5a93568abba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dadacc5bf0b7d99d46c5a93568abba">&#9670;&nbsp;</a></span>PlotGraph() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotGraph </td>
          <td>(</td>
          <td class="paramtype">TGraph &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of the TGraph object has the following supporting options:</p>
<ul>
<li><code>PlotType</code>: Defining how the data should be represented on the Pad. The supported types are:<ul>
<li><code>plottype::simplefunc</code>(default): single polyline joining the data points. This is used if the graph represents a function sample.</li>
<li><code>plottype::fittedfunc</code>: a polyline joining the data points with the Y error represented with a shaded region. This is used if the graph represents a function sample with additional sampling for fitting uncertainties</li>
<li><code>plottype::scatter</code>: plotting the data as data points with error bars. Unlike the histograms, this would not attempt to adjust the x error bars.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting </p>

</div>
</div>
<a id="a8782257efd5be01aa6f4f805e734e8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8782257efd5be01aa6f4f805e734e8a8">&#9670;&nbsp;</a></span>PlotGraph() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotGraph </td>
          <td>(</td>
          <td class="paramtype">TGraph &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of the TGraph object has the following supporting options:</p>
<ul>
<li><code>PlotType</code>: Defining how the data should be represented on the Pad. The supported types are:<ul>
<li><code>plottype::simplefunc</code>(default): single polyline joining the data points. This is used if the graph represents a function sample.</li>
<li><code>plottype::fittedfunc</code>: a polyline joining the data points with the Y error represented with a shaded region. This is used if the graph represents a function sample with additional sampling for fitting uncertainties</li>
<li><code>plottype::scatter</code>: plotting the data as data points with error bars. Unlike the histograms, this would not attempt to adjust the x error bars.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting </p>

</div>
</div>
<a id="aa1e28adae679e94e37deb2950b46af4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e28adae679e94e37deb2950b46af4b">&#9670;&nbsp;</a></span>PlotGraph() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotGraph </td>
          <td>(</td>
          <td class="paramtype">TGraph *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of the TGraph object has the following supporting options:</p>
<ul>
<li><code>PlotType</code>: Defining how the data should be represented on the Pad. The supported types are:<ul>
<li><code>plottype::simplefunc</code>(default): single polyline joining the data points. This is used if the graph represents a function sample.</li>
<li><code>plottype::fittedfunc</code>: a polyline joining the data points with the Y error represented with a shaded region. This is used if the graph represents a function sample with additional sampling for fitting uncertainties</li>
<li><code>plottype::scatter</code>: plotting the data as data points with error bars. Unlike the histograms, this would not attempt to adjust the x error bars.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting </p>

</div>
</div>
<a id="a4f1196fe82af6bb02ca7536bde5b9aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1196fe82af6bb02ca7536bde5b9aee">&#9670;&nbsp;</a></span>PlotGraph() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotGraph </td>
          <td>(</td>
          <td class="paramtype">TGraph *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of the TGraph object has the following supporting options:</p>
<ul>
<li><code>PlotType</code>: Defining how the data should be represented on the Pad. The supported types are:<ul>
<li><code>plottype::simplefunc</code>(default): single polyline joining the data points. This is used if the graph represents a function sample.</li>
<li><code>plottype::fittedfunc</code>: a polyline joining the data points with the Y error represented with a shaded region. This is used if the graph represents a function sample with additional sampling for fitting uncertainties</li>
<li><code>plottype::scatter</code>: plotting the data as data points with error bars. Unlike the histograms, this would not attempt to adjust the x error bars.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting </p>

</div>
</div>
<a id="a4faeadf03c6e8b917d9be26e27246cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faeadf03c6e8b917d9be26e27246cbd">&#9670;&nbsp;</a></span>PlotGraph() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotGraph </td>
          <td>(</td>
          <td class="paramtype">TGraph *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of the TGraph object has the following supporting options:</p>
<ul>
<li><code>PlotType</code>: Defining how the data should be represented on the Pad. The supported types are:<ul>
<li><code>plottype::simplefunc</code>(default): single polyline joining the data points. This is used if the graph represents a function sample.</li>
<li><code>plottype::fittedfunc</code>: a polyline joining the data points with the Y error represented with a shaded region. This is used if the graph represents a function sample with additional sampling for fitting uncertainties</li>
<li><code>plottype::scatter</code>: plotting the data as data points with error bars. Unlike the histograms, this would not attempt to adjust the x error bars.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, both the maximum and minimum will be tracked if this graph is the first thing to be plotted on the pad (excluding the histogram used for handling the axis), otherwise, nothing will be tracked.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting </p>

</div>
</div>
<a id="a52854cd0946f580296f34ddd0cbef917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52854cd0946f580296f34ddd0cbef917">&#9670;&nbsp;</a></span>PlotHist() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TH1D &amp; usr::plt::Pad1D::PlotHist </td>
          <td>(</td>
          <td class="paramtype">TH1D &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plotting 1D histograms accepts these options:</p><ul>
<li>PlotType: Defining how the binned data should be represented on the pad, following types are supported<ul>
<li>plottype::hist (default) - standard square curve/block diagram for displaying a diagram, equivalent to the <code>"HIST"</code> options provided in the TH1 object.</li>
<li>plottype::scatter - Plotting points with error bars. Complying to the CMS plotting convention with the horizontal error bar being suppressed for fixed bin-width data.</li>
<li>plottype::histstack - Stacking this histogram into the histogram stack on the Pad. If the stack doesn't already exist, a new stack is created. Note that all histograms in the stack will be plotted with the hist style and cannot be changed. Notice that the stack must be plotted consecutively, meaning that any non histstack options would cause the stack to be finalized and plotted onto the Pad.</li>
<li>plottype::histnewstack - Force the creation of the new histogram stack, used only if you are plotting two histogram stacks in the same Pad.</li>
<li>plottype::histerr - Drawing histogram uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added histogram. By default, only the max values of the histogram would be used.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting behavior, given more freedom to what the final plot will look like (See the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b" title="Plotting ROOT flavoured 1D function.">Pad1D::PlotFunc()</a> method for more details). This design aspect is in stark contrast with the design of ROOT objects. So beware of unwanted behaviour. </p>

</div>
</div>
<a id="a63e43d8364c8ff6292c33e3948d6e805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e43d8364c8ff6292c33e3948d6e805">&#9670;&nbsp;</a></span>PlotHist() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotHist </td>
          <td>(</td>
          <td class="paramtype">TH1D &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting 1D histograms accepts these options:</p><ul>
<li>PlotType: Defining how the binned data should be represented on the pad, following types are supported<ul>
<li>plottype::hist (default) - standard square curve/block diagram for displaying a diagram, equivalent to the <code>"HIST"</code> options provided in the TH1 object.</li>
<li>plottype::scatter - Plotting points with error bars. Complying to the CMS plotting convention with the horizontal error bar being suppressed for fixed bin-width data.</li>
<li>plottype::histstack - Stacking this histogram into the histogram stack on the Pad. If the stack doesn't already exist, a new stack is created. Note that all histograms in the stack will be plotted with the hist style and cannot be changed. Notice that the stack must be plotted consecutively, meaning that any non histstack options would cause the stack to be finalized and plotted onto the Pad.</li>
<li>plottype::histnewstack - Force the creation of the new histogram stack, used only if you are plotting two histogram stacks in the same Pad.</li>
<li>plottype::histerr - Drawing histogram uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added histogram. By default, only the max values of the histogram would be used.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting behavior, given more freedom to what the final plot will look like (See the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b" title="Plotting ROOT flavoured 1D function.">Pad1D::PlotFunc()</a> method for more details). This design aspect is in stark contrast with the design of ROOT objects. So beware of unwanted behaviour. </p>

</div>
</div>
<a id="a7ef343cd12f9c706ebb5ee6b8b1c7f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef343cd12f9c706ebb5ee6b8b1c7f6b">&#9670;&nbsp;</a></span>PlotHist() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotHist </td>
          <td>(</td>
          <td class="paramtype">TH1D &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting 1D histograms accepts these options:</p><ul>
<li>PlotType: Defining how the binned data should be represented on the pad, following types are supported<ul>
<li>plottype::hist (default) - standard square curve/block diagram for displaying a diagram, equivalent to the <code>"HIST"</code> options provided in the TH1 object.</li>
<li>plottype::scatter - Plotting points with error bars. Complying to the CMS plotting convention with the horizontal error bar being suppressed for fixed bin-width data.</li>
<li>plottype::histstack - Stacking this histogram into the histogram stack on the Pad. If the stack doesn't already exist, a new stack is created. Note that all histograms in the stack will be plotted with the hist style and cannot be changed. Notice that the stack must be plotted consecutively, meaning that any non histstack options would cause the stack to be finalized and plotted onto the Pad.</li>
<li>plottype::histnewstack - Force the creation of the new histogram stack, used only if you are plotting two histogram stacks in the same Pad.</li>
<li>plottype::histerr - Drawing histogram uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added histogram. By default, only the max values of the histogram would be used.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting behavior, given more freedom to what the final plot will look like (See the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b" title="Plotting ROOT flavoured 1D function.">Pad1D::PlotFunc()</a> method for more details). This design aspect is in stark contrast with the design of ROOT objects. So beware of unwanted behaviour. </p>

</div>
</div>
<a id="aac81dc15a8d70dcfaa110fd0840ae063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac81dc15a8d70dcfaa110fd0840ae063">&#9670;&nbsp;</a></span>PlotHist() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotHist </td>
          <td>(</td>
          <td class="paramtype">TH1D *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting 1D histograms accepts these options:</p><ul>
<li>PlotType: Defining how the binned data should be represented on the pad, following types are supported<ul>
<li>plottype::hist (default) - standard square curve/block diagram for displaying a diagram, equivalent to the <code>"HIST"</code> options provided in the TH1 object.</li>
<li>plottype::scatter - Plotting points with error bars. Complying to the CMS plotting convention with the horizontal error bar being suppressed for fixed bin-width data.</li>
<li>plottype::histstack - Stacking this histogram into the histogram stack on the Pad. If the stack doesn't already exist, a new stack is created. Note that all histograms in the stack will be plotted with the hist style and cannot be changed. Notice that the stack must be plotted consecutively, meaning that any non histstack options would cause the stack to be finalized and plotted onto the Pad.</li>
<li>plottype::histnewstack - Force the creation of the new histogram stack, used only if you are plotting two histogram stacks in the same Pad.</li>
<li>plottype::histerr - Drawing histogram uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added histogram. By default, only the max values of the histogram would be used.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting behavior, given more freedom to what the final plot will look like (See the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b" title="Plotting ROOT flavoured 1D function.">Pad1D::PlotFunc()</a> method for more details). This design aspect is in stark contrast with the design of ROOT objects. So beware of unwanted behaviour. </p>

</div>
</div>
<a id="a9688f51b4423cc9c246ecaec1b4bb7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9688f51b4423cc9c246ecaec1b4bb7be">&#9670;&nbsp;</a></span>PlotHist() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotHist </td>
          <td>(</td>
          <td class="paramtype">TH1D *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting 1D histograms accepts these options:</p><ul>
<li>PlotType: Defining how the binned data should be represented on the pad, following types are supported<ul>
<li>plottype::hist (default) - standard square curve/block diagram for displaying a diagram, equivalent to the <code>"HIST"</code> options provided in the TH1 object.</li>
<li>plottype::scatter - Plotting points with error bars. Complying to the CMS plotting convention with the horizontal error bar being suppressed for fixed bin-width data.</li>
<li>plottype::histstack - Stacking this histogram into the histogram stack on the Pad. If the stack doesn't already exist, a new stack is created. Note that all histograms in the stack will be plotted with the hist style and cannot be changed. Notice that the stack must be plotted consecutively, meaning that any non histstack options would cause the stack to be finalized and plotted onto the Pad.</li>
<li>plottype::histnewstack - Force the creation of the new histogram stack, used only if you are plotting two histogram stacks in the same Pad.</li>
<li>plottype::histerr - Drawing histogram uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added histogram. By default, only the max values of the histogram would be used.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting behavior, given more freedom to what the final plot will look like (See the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b" title="Plotting ROOT flavoured 1D function.">Pad1D::PlotFunc()</a> method for more details). This design aspect is in stark contrast with the design of ROOT objects. So beware of unwanted behaviour. </p>

</div>
</div>
<a id="ae7966698b713b3ddd8cd81a4670fc945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7966698b713b3ddd8cd81a4670fc945">&#9670;&nbsp;</a></span>PlotHist() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotHist </td>
          <td>(</td>
          <td class="paramtype">TH1D *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting 1D histograms accepts these options:</p><ul>
<li>PlotType: Defining how the binned data should be represented on the pad, following types are supported<ul>
<li>plottype::hist (default) - standard square curve/block diagram for displaying a diagram, equivalent to the <code>"HIST"</code> options provided in the TH1 object.</li>
<li>plottype::scatter - Plotting points with error bars. Complying to the CMS plotting convention with the horizontal error bar being suppressed for fixed bin-width data.</li>
<li>plottype::histstack - Stacking this histogram into the histogram stack on the Pad. If the stack doesn't already exist, a new stack is created. Note that all histograms in the stack will be plotted with the hist style and cannot be changed. Notice that the stack must be plotted consecutively, meaning that any non histstack options would cause the stack to be finalized and plotted onto the Pad.</li>
<li>plottype::histnewstack - Force the creation of the new histogram stack, used only if you are plotting two histogram stacks in the same Pad.</li>
<li>plottype::histerr - Drawing histogram uncertainty as a shaded box region.</li>
<li>Raw string: The user can use the ROOT style string options to define how the Histogram options should be plotted. The strings <code>"SAME"</code> and <code>"HIST"</code> would be handed by the functions and will be stripped.</li>
</ul>
</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added histogram. By default, only the max values of the histogram would be used.</li>
<li>PlotUnder: Specifying the that plot object be plotted underneath a specific object. Not that if the object specified in PlotUnder is not found in the pad, this option will have no effect and will raise no excpetions.</li>
</ul>
<p>One side note is that fitted functions will have its DrawOptions cleared from the histogram! The user should be the one explicitly invoking the plotting behavior, given more freedom to what the final plot will look like (See the <a class="el" href="classusr_1_1plt_1_1Pad1D.html#ad70690f2d8160849df791765b6cda04b" title="Plotting ROOT flavoured 1D function.">Pad1D::PlotFunc()</a> method for more details). This design aspect is in stark contrast with the design of ROOT objects. So beware of unwanted behaviour. </p>

</div>
</div>
<a id="a9b7b84d34c8ad13901d9f4fd9f3ac6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7b84d34c8ad13901d9f4fd9f3ac6a2">&#9670;&nbsp;</a></span>PlotPdf() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TGraph &amp; usr::plt::Pad1D::PlotPdf </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf &amp;&#160;</td>
          <td class="paramname"><em>pdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plotting of RooAbsPdf objects by generating the TGraphs using a RooPlot object and plotting the graphs onto the TPad. The supported options are:</p>
<ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options, with the excpetion of the RooFit::DrawOptions method.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. If not specified, the simplefunc or fittedfunc methods will be used, depending on if the RooFit::VisualizeError is used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, RooPdf objects would not be used to adjust the axis range.</li>
</ul>
<p>Additional automation of options include additional generation for RooFit::VisualizeError. The stock RooPlot generates are contour line for the uncertainty range rather than a line with error, making styling of a PDF with uncertainty rather tedious. This functions takes the generated TGraphs by the RooPlot and recalculated a TGraph with uncertainty. The newly calculated graph will be placed under the ownership of the Pad. </p>

</div>
</div>
<a id="a6a8075c0596d982ee2cbae7bb04ccb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8075c0596d982ee2cbae7bb04ccb59">&#9670;&nbsp;</a></span>PlotPdf() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotPdf </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of RooAbsPdf objects by generating the TGraphs using a RooPlot object and plotting the graphs onto the TPad. The supported options are:</p>
<ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options, with the excpetion of the RooFit::DrawOptions method.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. If not specified, the simplefunc or fittedfunc methods will be used, depending on if the RooFit::VisualizeError is used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, RooPdf objects would not be used to adjust the axis range.</li>
</ul>
<p>Additional automation of options include additional generation for RooFit::VisualizeError. The stock RooPlot generates are contour line for the uncertainty range rather than a line with error, making styling of a PDF with uncertainty rather tedious. This functions takes the generated TGraphs by the RooPlot and recalculated a TGraph with uncertainty. The newly calculated graph will be placed under the ownership of the Pad. </p>

</div>
</div>
<a id="a7c2c07eee329b6b2d8e7345e32e19af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2c07eee329b6b2d8e7345e32e19af4">&#9670;&nbsp;</a></span>PlotPdf() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotPdf </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of RooAbsPdf objects by generating the TGraphs using a RooPlot object and plotting the graphs onto the TPad. The supported options are:</p>
<ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options, with the excpetion of the RooFit::DrawOptions method.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. If not specified, the simplefunc or fittedfunc methods will be used, depending on if the RooFit::VisualizeError is used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, RooPdf objects would not be used to adjust the axis range.</li>
</ul>
<p>Additional automation of options include additional generation for RooFit::VisualizeError. The stock RooPlot generates are contour line for the uncertainty range rather than a line with error, making styling of a PDF with uncertainty rather tedious. This functions takes the generated TGraphs by the RooPlot and recalculated a TGraph with uncertainty. The newly calculated graph will be placed under the ownership of the Pad. </p>

</div>
</div>
<a id="a04d9c075d2d06ffd1ca4e7ae6f98d0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d9c075d2d06ffd1ca4e7ae6f98d0f2">&#9670;&nbsp;</a></span>PlotPdf() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotPdf </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of RooAbsPdf objects by generating the TGraphs using a RooPlot object and plotting the graphs onto the TPad. The supported options are:</p>
<ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options, with the excpetion of the RooFit::DrawOptions method.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. If not specified, the simplefunc or fittedfunc methods will be used, depending on if the RooFit::VisualizeError is used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, RooPdf objects would not be used to adjust the axis range.</li>
</ul>
<p>Additional automation of options include additional generation for RooFit::VisualizeError. The stock RooPlot generates are contour line for the uncertainty range rather than a line with error, making styling of a PDF with uncertainty rather tedious. This functions takes the generated TGraphs by the RooPlot and recalculated a TGraph with uncertainty. The newly calculated graph will be placed under the ownership of the Pad. </p>

</div>
</div>
<a id="adbf97fbac03051b083ead9a1b60bbd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf97fbac03051b083ead9a1b60bbd6f">&#9670;&nbsp;</a></span>PlotPdf() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotPdf </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of RooAbsPdf objects by generating the TGraphs using a RooPlot object and plotting the graphs onto the TPad. The supported options are:</p>
<ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options, with the excpetion of the RooFit::DrawOptions method.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. If not specified, the simplefunc or fittedfunc methods will be used, depending on if the RooFit::VisualizeError is used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, RooPdf objects would not be used to adjust the axis range.</li>
</ul>
<p>Additional automation of options include additional generation for RooFit::VisualizeError. The stock RooPlot generates are contour line for the uncertainty range rather than a line with error, making styling of a PDF with uncertainty rather tedious. This functions takes the generated TGraphs by the RooPlot and recalculated a TGraph with uncertainty. The newly calculated graph will be placed under the ownership of the Pad. </p>

</div>
</div>
<a id="a40d9f540fa71eb04b9cdefe08c2990b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d9f540fa71eb04b9cdefe08c2990b2">&#9670;&nbsp;</a></span>PlotPdf() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TGraph&amp; usr::plt::Pad1D::PlotPdf </td>
          <td>(</td>
          <td class="paramtype">RooAbsPdf *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting of RooAbsPdf objects by generating the TGraphs using a RooPlot object and plotting the graphs onto the TPad. The supported options are:</p>
<ul>
<li><em>Any</em> RooCmdArg supported by the RooAbsData::plotOn function. These will take precedence to custom defined options, with the excpetion of the RooFit::DrawOptions method.</li>
<li>PlotType: Specifying the representation for the data object on the Pad. Any of the types valid for the PlotGraph functions would be valid. If not specified, the simplefunc or fittedfunc methods will be used, depending on if the RooFit::VisualizeError is used.</li>
<li>EntryText: String to add in the legend entry. If this options is not present, then this object will NOT appear in the generated legend. Notice that the attributes to display in the legend would be generated from the PlotType used.</li>
<li>TrackY: Whether or not the y-axis range should be adjusted according to the newly added graph. By default, RooPdf objects would not be used to adjust the axis range.</li>
</ul>
<p>Additional automation of options include additional generation for RooFit::VisualizeError. The stock RooPlot generates are contour line for the uncertainty range rather than a line with error, making styling of a PDF with uncertainty rather tedious. This functions takes the generated TGraphs by the RooPlot and recalculated a TGraph with uncertainty. The newly calculated graph will be placed under the ownership of the Pad. </p>

</div>
</div>
<a id="aafca9980d69d1e09ce049d158b0e584e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafca9980d69d1e09ce049d158b0e584e">&#9670;&nbsp;</a></span>PlotProfile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TH1D &amp; usr::plt::Pad1D::PlotProfile </td>
          <td>(</td>
          <td class="paramtype">TProfile &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plotting a TProfile object.</p>
<p>Due to inheritance between TProfile and the TH1D, the original PlotHist doesn't work with TProfile. Instead, this functions generates a new TH1D from the TProfile using the ProjectionX function. The return value would then be the newly generated histogram. So beware of unexpected behaviour. </p>

</div>
</div>
<a id="a2a85570690ce79e065b083eab26c471b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85570690ce79e065b083eab26c471b">&#9670;&nbsp;</a></span>PlotProfile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotProfile </td>
          <td>(</td>
          <td class="paramtype">TProfile &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TProfile object.</p>
<p>Due to inheritance between TProfile and the TH1D, the original PlotHist doesn't work with TProfile. Instead, this functions generates a new TH1D from the TProfile using the ProjectionX function. The return value would then be the newly generated histogram. So beware of unexpected behaviour. </p>

</div>
</div>
<a id="afc20ed94bc8da43e68a207fd34403d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc20ed94bc8da43e68a207fd34403d6d">&#9670;&nbsp;</a></span>PlotProfile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotProfile </td>
          <td>(</td>
          <td class="paramtype">TProfile &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TProfile object.</p>
<p>Due to inheritance between TProfile and the TH1D, the original PlotHist doesn't work with TProfile. Instead, this functions generates a new TH1D from the TProfile using the ProjectionX function. The return value would then be the newly generated histogram. So beware of unexpected behaviour. </p>

</div>
</div>
<a id="a9e2bc2b251e12c8dd880435bdff42dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2bc2b251e12c8dd880435bdff42dcc">&#9670;&nbsp;</a></span>PlotProfile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotProfile </td>
          <td>(</td>
          <td class="paramtype">TProfile *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TProfile object.</p>
<p>Due to inheritance between TProfile and the TH1D, the original PlotHist doesn't work with TProfile. Instead, this functions generates a new TH1D from the TProfile using the ProjectionX function. The return value would then be the newly generated histogram. So beware of unexpected behaviour. </p>

</div>
</div>
<a id="aac7760d8f1d0cdf66381b7c8eb293e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7760d8f1d0cdf66381b7c8eb293e55">&#9670;&nbsp;</a></span>PlotProfile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotProfile </td>
          <td>(</td>
          <td class="paramtype">TProfile *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RooCmdArg &amp;&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TProfile object.</p>
<p>Due to inheritance between TProfile and the TH1D, the original PlotHist doesn't work with TProfile. Instead, this functions generates a new TH1D from the TProfile using the ProjectionX function. The return value would then be the newly generated histogram. So beware of unexpected behaviour. </p>

</div>
</div>
<a id="ab2b64024ae2f57df69e9f040a31cb4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b64024ae2f57df69e9f040a31cb4e7">&#9670;&nbsp;</a></span>PlotProfile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TH1D&amp; usr::plt::Pad1D::PlotProfile </td>
          <td>(</td>
          <td class="paramtype">TProfile *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RooCmdArg &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plotting a TProfile object.</p>
<p>Due to inheritance between TProfile and the TH1D, the original PlotHist doesn't work with TProfile. Instead, this functions generates a new TH1D from the TProfile using the ProjectionX function. The return value would then be the newly generated histogram. So beware of unexpected behaviour. </p>

</div>
</div>
<a id="a22c90d4877f10969d760c8a9975524a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c90d4877f10969d760c8a9975524a1">&#9670;&nbsp;</a></span>SetAxisFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetAxisFont </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Setting the axis font based on the <a class="el" href="classusr_1_1plt_1_1Canvas.html" title="Extending the TCanvas class for better saving and padâ€“canvas hierarchy relations.">Canvas</a> settings. The axis title should be the same size as the <a class="el" href="classusr_1_1plt_1_1Canvas.html" title="Extending the TCanvas class for better saving and padâ€“canvas hierarchy relations.">Canvas</a> font, while the label (numbers) would be the scale to the latex "small" format. </p>

<p>Reimplemented in <a class="el" href="classusr_1_1plt_1_1Bottom1DPad.html#ac28cd2b07196a7276b48d207bedafd82">usr::plt::Bottom1DPad</a>, and <a class="el" href="classusr_1_1plt_1_1Top1DPad.html#a624353c9d7b8c919bdfdcee5ab38db02">usr::plt::Top1DPad</a>.</p>

</div>
</div>
<a id="a0fcdb4ed40ed7d7ffb4c0906810513d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdb4ed40ed7d7ffb4c0906810513d7">&#9670;&nbsp;</a></span>SetAxisTitle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetAxisTitle </td>
          <td>(</td>
          <td class="paramtype">TAxis &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Standard format of naming an axis with a certain unit. This fixes the format to "Title [unit]"" (if the unit is not a null string). For the units, both the small and square braces are accepted by the CMS publication standard, the choice of using the square braces is arbitrary. </p>

</div>
</div>
<a id="ae52990ae3e46775c4b40bcc87b045d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52990ae3e46775c4b40bcc87b045d72">&#9670;&nbsp;</a></span>SetDataMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetDataMax </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Directly returning the double stored by the class. </p>

</div>
</div>
<a id="abb86474ca1adcbd4c2d7ecf263aed4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb86474ca1adcbd4c2d7ecf263aed4da">&#9670;&nbsp;</a></span>SetDataMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetDataMin </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Directly returning the double stored by the class. </p>

</div>
</div>
<a id="a0ed478e638d860ae43b94b1e7ad7e254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed478e638d860ae43b94b1e7ad7e254">&#9670;&nbsp;</a></span>SetHistAxisTitles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetHistAxisTitles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ytitle</em> = <code>&quot;Events&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>forcebinwidth</em> = <code><a class="el" href="classusr_1_1plt_1_1Pad1D.html#a8d6974d40a82ec22e24694bcab2b30f0">autobinwidth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for naming both the X axis and Y axis according to the standard, format. The x axis would be the simples case of "title [unit]", but the y axis would be in the format of "Events/ [bin-width unit]" if the histogram has a uniformed bin width. In the case that the bin-width is not uniformed, then the y axis title should simply be "Events". The final flag allows for forcing the bin-width to be a certain value, and not be calculated automatically.</p>
<p>Special not is that the bin-width would at most be set to two digits after the decimal point. If you need more precision, consider scaling your x axis as it makes reading the diagram difficult. </p>

</div>
</div>
<a id="a0e1601f406c237e1c4a34c81223c9e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1601f406c237e1c4a34c81223c9e64">&#9670;&nbsp;</a></span>SetLogy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetLogy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aside from calling the TPad::SetLogy() function, the AutoSetYRange is also called to adjust the Y axis range appropriately. </p>

</div>
</div>
<a id="aca0e9e6623384c841c90e676ba1d6ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0e9e6623384c841c90e676ba1d6ab2">&#9670;&nbsp;</a></span>SetYaxisMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetYaxisMax </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Again, setting the y axis limit should call the SetMaximum() function of the object used for drawing the Y axis. </p>

</div>
</div>
<a id="a30cdde2371a935be70db081336966eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cdde2371a935be70db081336966eed">&#9670;&nbsp;</a></span>SetYaxisMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::SetYaxisMin </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Again, setting the y axis limit should call the SetMaximum() function of the object used for drawing the Y axis. </p>

</div>
</div>
<a id="ad30055693800662b5035100e2e601e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30055693800662b5035100e2e601e5f">&#9670;&nbsp;</a></span>TrackObjectY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usr::plt::Pad1D::TrackObjectY </td>
          <td>(</td>
          <td class="paramtype">const TObject &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>tracky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moving to a private helper function to reduce verbosity in main implementation function </p>

</div>
</div>

<p><code>#include &lt;<a class="el" href="Pad1D_8hpp_source.html">Pad1D.hpp</a>&gt;</code></p>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/github/workspace/PlotUtils/interface/<a class="el" href="Pad1D_8hpp_source.html">Pad1D.hpp</a></li>
<li>/github/workspace/PlotUtils/src/<a class="el" href="Pad1D_8cc.html">Pad1D.cc</a></li>
<li>/github/workspace/PlotUtils/src/<a class="el" href="Pad1D__Axis_8cc.html">Pad1D_Axis.cc</a></li>
<li>/github/workspace/PlotUtils/src/<a class="el" href="Pad1D__Draw_8cc.html">Pad1D_Draw.cc</a></li>
<li>/github/workspace/PlotUtils/src/<a class="el" href="Pad1D__Legend_8cc.html">Pad1D_Legend.cc</a></li>
<li>/github/workspace/PlotUtils/src/<a class="el" href="Pad1D__Plot_8cc.html">Pad1D_Plot.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
